<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem;">
            <b>React Training</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Vorbereitung</span></h3>
            <p>
              <span class="transparent-bg"
                >git clone https://github.com/nilshartmann/react-training</span
              >
            </p>
            <p>
              <span class="transparent-bg">oder: git pull</span>
            </p>
          </div>
          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2020_1211_react.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >oder online:
                <a href="https://react.schule/2020_1211_react"
                  >https://react.schule/2020_1211_react</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center;">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px;">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
              <p>Alle Dienstleistungen <b>auch online!</b></p>
            </div>
            <div style="margin-left: 15px;">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px;"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Zeitplan</h3>
          <p><b>Dienstag</b></p>
          <ul style="font-size: 85%;">
            <li>
              9:00 bis 12:30 Uhr
            </li>
            <li>Mittagspause</li>
            <li>13:30 bis 17:00 Uhr</li>
          </ul>
          <p><b>Mittwoch</b></p>
          <ul style="font-size: 85%;">
            <li>
              9:00 bis 12:30 Uhr
            </li>
            <li>Mittagspause</li>
            <li>13:30 bis 17:00 Uhr</li>
          </ul>
          <p>Kürze Pausen zwischendurch</p>
        </section>

        <section>
          <h2>Agenda</h2>
          <ul style="font-size: 85%;">
            <li>
              <a href="#/t1">Teil I: React Einführung</a>
            </li>
            <li>
              <a href="#/t2">Teil II: React-Komponenten (Details)</a>
            </li>
            <li>
              <a href="#/t3">Teil III: React-Komponenten: Hierarchien und Anwendungen</a>
            </li>
            <li style="margin-bottom: 20px;">
              <a href="#/t-server">Teil IV: Daten lesen und schreiben vom Server</a>
            </li>
            <li style="margin-bottom: 20px;">
              <a href="#/t-typescript">Teil V: TypeScript und React</a>
            </li>
            <li style="margin-bottom: 20px;">
              <a href="#/t-test">Teil VI: Testen von React Anwendungen (am Beispiel Material-UI)</a>
            </li>
            <li>
              <a href="#/t-state">Teil VIII: Statemanagement:</a>
              React <a href="#/t-context">Context</a>, <a href="#/t-redux">Redux</a> und
              <a href="#/t-mobx">MobX</a>
            </li>
          </ul>
          <div style="font-size: 80%;">
            <p><b>Jederzeit:</b> Fragen und Diskussionen!</p>
            <p>Fragen per Audio oder per Chat</p>
          </div>
        </section>

        <section id="t1">
          <h1>Teil 1</h1>
          <h2>React Einführung</h2>
        </section>

        <section>
          <h3>Beispiel-Anwendung</h3>
          <a target="_blank" href="http://localhost:3000">
            <img src="blog-example/blog-example.png" style="height: 650px;" />
          </a>
        </section>

        <section id="react">
          <h2>React</h2>
          <p>
            <a href="https://reactjs.org" target="_blank">https://reactjs.org</a>
          </p>
        </section>

        <section>
          <h2>React</h2>
          <ul>
            <li class="fragment">Minimales API</li>
            <li class="fragment">
              Minimales Feature Set
              <ul>
                <li>Ihr könnt/müsst viele Entscheidungen selber treffen</li>
              </ul>
            </li>

            <li class="fragment">
              Bewusste Verstöße gegen Best-Practices
              <ul>
                <li>
                  <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank"
                    >Pete Hunt: Rethinking Best Practices (YouTube)</a
                  >
                </li>
                <li>
                  <a href="https://www.youtube.com/watch?v=DgVS-zXgMTk" target="_blank"
                    >Pete Hunt: Rethinking Best Practices, update (YouTube)</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Komponenten in React</h3>
          <p>
            <em>Zentrales Konzept in React: <b>Komponenten</b></em>
          </p>
          <img style="height: 800px;" class="fragment" src="slides/images/soc.png" />
        </section>

        <section>
          <h3>Komponenten in React</h3>
          <p style="font-size: smaller;">Unser Beispiel in Komponenten</p>
          <img src="blog-example/blog-example.png" style="height: 650px;" />
        </section>

        <section>
          <h3>React Komponenten</h3>
          <ul>
            <li class="fragment">bestehen aus <b>Logik und UI</b></li>
            <li class="fragment">
              <b>keine Templatesprache (?)</b>
            </li>
            <li class="fragment">werden <b>deklarativ</b> beschrieben</li>
            <li class="fragment">
              werden immer <b>komplett gerendert</b> (kein 2-Wege-Data-Binding)
            </li>
            <li class="fragment">werden zu <b>ganzen Anwendungen</b> aggregiert</li>
          </ul>
        </section>

        <section>
          <h3>React Komponenten</h3>
          <ul>
            <li class="fragment">
              Werden als <b>Funktion mit Hooks</b> oder <b>ES6 Klasse</b> implementiert
              <ul>
                <li>Hooks seit React 16.8 (Februar 2019)</li>
                <li>Klassen (noch?) verbreitet in bestehendem Code</li>
              </ul>
            </li>

            <li class="fragment">
              Keine Templatesprache
              <ul>
                <li>Wir schreiben unsere UI komplett in JavaScript</li>
                <li>
                  React bringt eine Spracherweiterung für JS mit, die es uns erlaubt HTML-artigen
                  Code in JavaScript zu schreiben (JSX)
                </li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h2>Unsere erste React-Komponente</h2>
          <h3>Sehen wir uns die wichtigsten Konzepte einer React-Komponente im Code an</h3>

          <ul>
            <li>Schritt-für-Schritt (<code>blog-example/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>PostEditor.js</code>
          <pre><code data-trim contenteditable>
  import React from "react";
  
  export default function PostEditor() {
    const [title, setTitle] = React.useState("");
  
    return (
      &lt;div>
        &lt;label>
          Title
          &lt;input onChange={event => setTitle(event.target.value)} value={title} />
        &lt;/label>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Einbinden der Anwendung in die HTML-Seite</h3>
          <div class="fragment">
            <p>
              <code>index.html</code>
            </p>
            <pre><code data-trim contenteditable>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div class="fragment">
            <p>
              <code>index.js</code>
            </p>
            <pre><code data-trim contenteditable class="javascript">
  import React from 'react';
  import ReactDOM from 'react-dom';
  
  import PostEditor from './PostEditor';
  
  ReactDOM.render(&lt;PostEditor />, 
    document.getElementById('root')
  );
  </code></pre>
          </div>
        </section>

        <section data-state="js-exkurs">
          <h2>React Devtools</h2>
          <em>React Developer Tools für Chrome und Firefox</em>
          <p>Untersuchen einer laufenden React Anwendung</p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>

        <section data-state="js-exkurs">
          <h3>create-react-app</h3>
          <a
            href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents"
            target="_blank"
            >User Guide</a
          >
          <p>Bootstrap von neuen React Anwendung</p>
          <p>Fertige Konfiguration von React und Webpack mit TypeScript, Sass, Linter</p>
          <p>Beispiel: npx create-react-app --template typescript my_new_app_name</p>
        </section>

        <section>
          <h3>Der Trainingsworkspace</h3>
          <ul class="x-list">
            <li style="margin-bottom: 40px;"><code>2020_1211_react.html</code>: Die Slides</li>
            <li class="fragment" style="margin-bottom: 40px;">
              Der Code ist im <code><b>blog-example</b></code> Verzeichnis
            </li>

            <li class="fragment" style="margin-bottom: 40px;">
              <code>blog-example/<b>workspace</b></code
              >: Verzeichnis für Eure Übungen <br />👉&nbsp;<b>Empfehlung</b>: nur diesen Ordner in
              IDE/Editor öffnen
            </li>
            <li class="fragment">
              <code>blog-example/<b>material</b></code
              >: Code für einige der Übungen
            </li>
            <li class="fragment">
              <code>blog-example/<b>steps</b></code
              >: Fertiger Source-Code nach jeder Übung
            </li>
            <li class="fragment">
              <code>blog-example/steps/XX/<b>build/index.html</b></code
              >: Die fertige Anwendung nach einem Schritt zum Öffnen im Browser
            </li>
          </ul>
        </section>
        <section>
          <h2>Übung #1: Hello-World</h2>
          <h3>
            <em>Mit Tools, Workspace und React vertraut machen</em>
          </h3>
        </section>
        <section>
          <h3>Schritt #1: Tool Chain starten</h3>

          <ol class="fragment" style="font-size: 85%;">
            <li>
              <code>cd blog-example/workspace</code>
            </li>
            <li class="fragment">
              <code>npm install</code>
            </li>

            <li class="fragment">
              <code>npm start</code>
            </li>

            <li class="fragment">
              Der Browser sollte automatisch
              <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>
              öffnen
            </li>

            <li class="fragment">Wenn Du "Hello, World" im Browser siehst, ist alles gut!</li>
          </ol>
        </section>
        <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <em>Der erste kleine Schritt für die PostEditor-Komponente</em>
          <ul>
            <li class="fragment">Ersetze den "statischen" Code in <code>PostEditor.js</code></li>
            <li class="fragment">Die Komponente soll <b>PostEditor</b> heißen</li>
            <li class="fragment">
              Sie sollte einen Zustand/State (<code>title</code>) und ein Eingabefeld dafür haben
            </li>
            <li class="fragment">
              Als Hilfe kannst Du den Code aus den
              <a href="#interaktiv-hellomessage">vorherigen Slides</a> ansehen.
            </li>

            <li class="fragment">
              <em>Optional: mache ein paar Experimente mit der Komponente, zum Beispiel:</em>
              <ul>
                <li>
                  Kannst Du unter dem Eingabefeld den gerade eingegebenen Text ausgeben lassen, so
                  dass dieser immer dem aktuellen Inhalt des Eingabefeldes entspricht?
                </li>
              </ul>
            </li>
            <li class="fragment">
              Eine mögliche <b>Lösung</b> für diese Aufgabe findest Du in
              <code>blog-example/steps/1-hello-world</code>
            </li>
          </ul>
        </section>

        <section id="t2">
          <h1>Teil II</h1>
          <h2>React Komponenten</h2>
        </section>

        <section>
          <h2>React Dokumentation</h2>
          <p>
            <a href="https://reactjs.org/docs/hello-world.html">
              https://reactjs.org/docs/hello-world.html
            </a>
          </p>
        </section>

        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%;" class="fragment">
              Wird wie HTML hingeschrieben, inkl Attribute:
              <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              Achtung! <code>class</code>-Attribut heißt <code>className</code>:
              <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              Attribute, die keine Strings sind, müssen in {} eingeschlossen werden:
              <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              Kann pures JavaScript enthalten, eingeschlossen in {}:
              <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
            </li>

            <li style="font-size: 80%;" class="fragment">
              CSS-Eigenschaften werden als Objekt übergeben in Camel-Case-Notation:
              <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%;" class="fragment">
              Fragmente (rendern selber kein Element in den DOM, nur ihre Kind-Elemente):
              <pre><code class="xml" contenteditable data-trim>
function Choice() { 
  return &lt;&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt;/>              
}  
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              null, false oder boolean, um nichts zu rendern:
              <pre><code class="xml" contenteditable data-trim>
function ErrorMessage(props) {
  if (!props.msg) {
    return null; // oder false oder true
  }

  return <h1>Fehler: {props.msg}</h1>;
}              
                    </code></pre>
            </li>

            <li style="font-size: 80%;" class="fragment">
              Kommentare
              <pre><code class="xml" contenteditable data-trim>
  function MyComponent() {
    return <div>
      { /* hier ist javascript, deswegen block-kommentare erlaubt */ }
    </div>;
  }              
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Im Detail: Zustand einer Komponente und der useState-Hook</h3>
          <ul class="fragement">
            <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
            <li class="fragment"><b>Werte</b> üblicherweise immutable</li>
            <li class="fragment">Arbeiten mit Zustand über <b>useState</b>-Hook</li>
            <li class="fragment">
              useState liefert Array mit zwei Werten zurück: aktuellen Zustand, und setter-Funktion
              um Zustand zu verändern
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function HelloWorld() {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
          <ul>
            <li class="fragment">
              Aufruf des Setters <b>löst erneutes rendern der <i>gesamten</i> Komponente aus</b>
            </li>
            <li class="fragment">
              Es können mehrere States erzeugt werden, durch Verwendung mehrerer useState-Aufrufe
            </li>
            <li class="fragment">
              <b>Zustand</b> ist eines der <b>zentralen</b> Konzepte von React
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Mit React Hooks kann sich eine Komponente in Zustand und Lebenszyklus "einhaken"</em>
          <ul>
            <li class="fragment">
              Hooks sind "normale" Funktionen, müssen aber mit <code>use</code> beginnen (useState,
              useEffect, ...)
            </li>
            <li class="fragment">
              Beispiel: Importieren und verwenden von Hooks

              <pre><code class="javascript" contenteditable data-trim>
                import * as React from "react";

                function HelloWorld() {
                  const [title, setTitle] = React.useState("");
                  // ...
                }
                                  </code></pre>
              <pre class="fragment"><code class="javascript" contenteditable data-trim>
                                      import React, { useState } from "react";
                      
                                      function HelloWorld() {
                                        const [title, setTitle] = useState("");
                                        // ...
                                      }
                                                        </code></pre>

              <ul>
                <li class="fragment">
                  (<code>React</code> muss immer <b>importiert</b> werden, wenn JSX verwendet wird!)
                </li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Es gibt einige Regeln zu beachten, bei der Verwendung von Hooks 👆</em>
          <p style="font-size: 75%; margin-top: 0;">
            <a href="https://reactjs.org/docs/hooks-rules.html"
              >(https://reactjs.org/docs/hooks-rules.html)</a
            >
          </p>
          <div class="fragment">
            <p>Einschränkungen:</p>
            <ul>
              <li class="fragment">
                Hooks können nur in Funktionskomponenten (und anderen Hooks) aufgerufen werden
              </li>
              <li class="fragment">
                Hooks müssen immer in derselben Reihenfolge und auf Top-Level-Ebene verwendet werden
                <ul>
                  <li>Verboten z.B. in Schleifen, if-Abfragen oder in anderen Funktionen</li>
                </ul>
              </li>
              <li class="fragment">
                Es gibt ein
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                zur korrekten Verwendung der Hooks
              </li>
            </ul>
          </div>
          <p class="fragment">
            <em
              >Der Hooks-Mechanismus basiert intern darauf, dass React sich die Reihenfolge der
              <code>useXyz</code>-Aufrufe merkt!</em
            >
          </p>
        </section>
        <section>
          <h3>React Hooks</h3>

          <em>Beispiele für korrekte und unerlaubte Verwendung</em>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              // ERLAUBT:
              function HelloWorld() {
                const [greeting, setGreeting] = React.useState("");
                const [name, setName] = React.useState("");
                // ...
              }
                                </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                                    // ERLAUBT:
                                    function HelloWorld() {
                                      const [greeting, setGreeting] = React.useState("");
                                      const uppercaseGreeting = greeting.toUpperCase(); 
                                      const [name, setName] = React.useState("");
                                      // ...
                                    }
                                                      </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                                    // VERBOTEN:
                                    function HelloWorld() {
                                      const [greeting, setGreeting] = React.useState("");
                                      if (greeting !== null) {
                                        const [name, setName] = React.useState("");
                                      }
                                      // ...
                                    }
                                                      </code></pre>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Beispiele für korrekte und unerlaubte Verwendung #2</em>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            // VERBOTEN:
            function HelloWorld() {
              const [greeting, setGreeting] = React.useState("");
              if (greeting === null) {
                return <h1>Please enter greeting first</h1>;
              }
              const [name, setName] = React.useState("");
              // ...
            }
                              </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              // VERBOTEN 
              function HelloWorld() {
                function initState() {
                  return React.useState("");
                }
                const [greeting, setGreeting] = initState();
              }
            </code></pre>
        </section>
        <section>
          <h3>useState: Details</h3>
          <em>Wird verwendet, um den internen Zustand (State) einer Komponente zu verwalten</em>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                function PostEditor() {
                  const [title, setTitle] = React.useState("");

                  // Aufruf von setTitle führt dazu, dass Komponente neu gerendert wird
                  // d.h. diese Funktion (PostEditor) wird erneut ausgeführt
                }
              </code></pre>
        </section>
        <!-- - - - - - - - - - - - - - - - PROPS HIER ERST - - - - - - - - - - - - - - -  -->
        <section>
          <h3>React: Properties</h3>
          <ul>
            <li class="fragment">
              Mit <b>Properties</b> können einer Komponente von <b>außen</b> Werte und Eigenschaften
              übergeben werden

              <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function PostEditor() {
                // type, onChange und value sind Properties!

                return (
                  &lt;input type="text" onChange={() => setTitle("...")} value={title}&lt;/h1>
                );
              }
            }
            </code></pre>
            </li>
            <li class="fragment">
              <b>Properties</b> können innerhalb der Komponente nicht verändert werden
            </li>
            <li class="fragment">
              Zum Vergleich: <b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der
              Komponente (die verändert werden kann)
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") einer Komponente</h3>
          <ul>
            <li>Komponenten können beliebig eigene Properties definieren</li>
            <li class="fragment">
              Bei der Angabe der Properties bei der Verwendung einer Komponente werden die
              Properties wie von HTML gewohnt in der Notiation
              <code>name=value</code> hingeschrieben
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
&lt;PostEditor initialTitle="Hello" initialBody="World" />
 </code></pre>

          <ul>
            <li class="fragment">
              ...alle angegebenen Properties werden "gesammelt" und in <b>einem</b> Objekt im 1.
              Methoden-Parameter an Komponente übergeben
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function PostEditor(props) {
                // props: { initialTitle: "Hello", initialBody: "World" }
                const [title, setTitle] = React.useState(props.title);
                const [body, setBody] = React.useState(props.body);

                return ...;
              }
            }
            </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Mit Destructuring
function PostEditor({initialTitle, initialBody}) {
   const [title, setTitle] = React.useState(title);
   const [body, setBody] = React.useState(body);

   return ...;
  }
}
                </code></pre>
        </section>

        <section>
          <h3>Properties: Typen</h3>
          <ul>
            <li>
              Properties können alle bekannten JavaScript-Typen aufnehmen und sind grundsätzlich
              optional
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function UserDetails(props) {
   return &lt;div>
     Address: {props.address.street} {props.address.city}
     Member since: {props.memberSince} years
     {props.premium ? "Premium" : "Regular"} membership
     &lt;/div>
  }
}
                </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Verwendung
const address = { street: "Highway", city: "Hamburg" };                   

&lt;UserDetails address={address} memberSince={2} />
  </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// oder:
&lt;UserDetails address={{ street: "Highway", city: "Hamburg" }} memberSince={2} />

                </code></pre>
        </section>
        <section>
          <h3>Render Zyklus</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section>

        <section>
          <h2>Übung 2: Post-Editor für unsere Anwendung</h2>
          <em><b>Erweitere deine Komponente um neue Features und Properties</b></em>
        </section>
        <section>
          <h3>Schritte 1/2</h3>
          <ol class="x-list">
            <li>
              Zusätzlich zum "title", sollte es einen weiteren Zustand und eine Textarea geben:
              <code>body</code>. Ein <code>textarea</code>-Element hat dieselbe API wie ein
              <code>input</code>-Feld.
            </li>
            <li>
              Füge einen "Clear"-Button hinzu, der beide Eingabefeld leert. Das Property auf dem
              Button ist <code>onClick</code>.
              <ul>
                <li>
                  Der "clear"-Button sollte disabled sein, solange beide Felder leer sind. Um ein
                  button-Element zu disablen, kannst Du das <code>disabled</code> Property auf
                  <code>true</code> setzen.
                </li>
              </ul>
            </li>
          </ol>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Schritte 2/2</h3>
          <ol start="3" class="x-list">
            <li>
              Passe die Signatur der PostEditor-Funktion an, so dass die Komponente Properties für
              die initiale Belegung der beiden Eingabefelder (title und body) entgegen nimmt. Die
              Properties sollen <code>initialTitle</code> bzw. <code>initialBody</code> heißen.
            </li>
            <li>
              Modifiziere die useState-Aufrufe, so dass sie als initial Werte die entsprechenden
              Werte aus den Properties übernehmen (statt wie bisher ein Leerstring)
            </li>
            <li>
              Die Komponente sollte weiterhin auch funktionieren, wenn der Aufrufer <em>keine</em>
              Properties übergibt.
            </li>
            <li>
              Übergib bei der Verwendung von PostEditor in <code>index.js</code> Initial-Werte für
              die beiden Properties
            </li>
            <li class="fragment" style="margin-top: 2rem;">
              Eine mögliche <b>Lösung</b> für diese Aufgabe findest Du in
              <code>blog-example/steps/2-editor-mit-props</code>
            </li>
          </ol>
        </section>

        <section>
          <h3>Virtual DOM</h3>
          <p>"Rendern" hat leider doppelte Bedeutung!</p>
          <img src="slides/images/vdom.png" style="height: 650px;" />
        </section>

        <section>
          <h3>Virtual DOM</h3>
          <p>Beispiel: <code>blog-example/steps/2b-rendering</code></p>
        </section>

        <!-- PROPS HIER ERST ENDE -->

        <section id="t3">
          <h1>Teil III</h1>
          <h2>React: Hierarchien und Anwendungen</h2>
          <code>blog-example/steps/3-hierarchy</code>
        </section>

        <section>
          <h3>Listen</h3>
          <p>JSX hat keine eigenen Konstrukte für Listen</p>
          <p class="fragment">
            Üblicherweise verwendet man
            <code>Array.map()</code> um eine Liste von Objekten in eine Liste von JSX Elementen zu
            überführen
          </p>
          <p class="fragment">
            Jedes JSX Element in der Liste benötigt einen <em>List-weit eindeutigen <b>key</b></em>
          </p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
const posts = [
  { id: 0, title: 'Hello World', body: 'Lorem ipsum' },
  { id: 1, title: 'React in a Nutshell', body: 'Lets get started with React' }
];

function PostList(props) {
  return props.posts.map(post => (
    &lt;article key={post.id}>
        &lt;h1>{post.title}&lt;/h1>
        &lt;p>{post.body}&lt;/p>
    &lt;/article>
  ))
}
</code></pre>
        </section>

        <section>
          <h2>Komponenten-Hierarchien</h2>
        </section>

        <section>
          <h3>Wie kommuniziert unsere Anwendung?</h3>
          <p>Wir haben nun <b>zwei</b> Views: Blog-List und Post-Editor</p>
          <p>Welche ist sichtbar?</p>
          <p>Wie fließen die Daten zwischen den beiden Komponenten?</p>
        </section>

        <section>
          <h3>👉 Wir bauen eine <b>Anwendung</b>: mit Blog-List und Post-Editor</h3>
        </section>

        <section>
          <h3>Datenfluss in React-Anwendungen</h3>
          <ol>
            <li>
              In React Anwendungen, Komponenten werden in Hierarchien zu Anwendungen aggregiert.
              Eine "Anwendung" ist nichts weiter als eine Sammlung von Komponenten
            </li>
            <li class="fragment">
              Innerhalb der Hierarchie wird immer nur <b>in eine Richtung</b> kommuniziert:
              <b>Eltern</b>-Komponenten geben <b>properties</b> an ihre <b>Kinder</b>
            </li>
            <li class="fragment">
              Mit den Properties können Daten (Blog Post, angemeldeter Benutzer, ...) von "oben"
              nach "unten" gereicht werden. Das kann über mehr als eine Hierarchie-Ebene passieren.
              <p>
                (Eine Komponente kann die Properties oder einen Teil davon ihrerseits weiter nach
                "unten" reichen)
              </p>
            </li>
            <li class="fragment">
              Mit Properties können außerdem <b>callback-Funktionen</b> nach unten gereicht werden.
            </li>
            <li class="fragment">
              Eine Kind-Komponente kann die übergebene Funktion aufrufen und ein "Event" (mit oder
              ohne Daten) an ihre Eltern-Komponente schicken. <br />Dieses Verfahren haben wir
              bereits beim onChange-Property am input-Feld gesehen!
            </li>
          </ol>
        </section>

        <section>
          <h3>Smart und Dumb-Komponenten #1</h3>

          <p class="fragment">
            Zur Erinnerung: in React bauen wir Komponenten. Komponenten bestehen aus Logik, Zustand
            und UI (HTML-Elemente und Styling)
          </p>
          <p class="fragment">
            Ein bekanntes Muster ist, die Komponenten in zwei Arten aufzuteilen:
            <b>Smart (oder Controller)</b>- und <b>Dumb oder (Presentation-)</b>-Komponenten
          </p>
          <p class="fragment">
            Technisch sind die Komponenten identisch, also "normale" React-Komponenten
          </p>
          <p class="fragment">Nur ihre <b>Aufgabe</b> ist anders definiert...</p>
        </section>

        <section>
          <h3>Smart und Dumb-Komponenten #2</h3>
          <p class="fragment">Smart-Komponenten enthalten Logik und Zustand</p>
          <p class="fragment">Dumb-Komponenten sind nur zur Darstellung der Daten</p>
          <p class="fragment">
            Smart-Komponenten reichen Zustand in die Dumb-Komponenten. Diese zeigen den Zustand an
          </p>
          <p class="fragment">
            Smart-Komponenten reichen Callback-Funktion als Event-Handler an die Dumb-Komponenten
          </p>
          <p class="fragment">
            Wenn in Dumb-Komponenten ein Ereignis eintritt (z.B. Button-Click oder Texteingabe),
            wird eine Callback-Funktion aufgerufen
          </p>
          <p class="fragment">
            Die Callback-Funktion wird dann in der Smart-Komponente aufgerufen und die Verarbeitung
            ausgeführt
          </p>
          <p class="fragment">
            Die Smart-Komponente setzt ihren Zustand neu, und rendert sich und ihre Kinder (die
            Dumb-Komponenten) neu <br /><b
              >Der "Gesamt-Zustand" der Anwendung bleibt somit immer konsistent!</b
            >
          </p>
        </section>
        <section>
          <img src="slides/images/blogpost-app-hierarchy.png" />
        </section>

        <section>
          <h3>Beispiel</h3>

          <p>
            Unsere Smart-Komponente hält eine Liste von Blog-Posts und steuert, welche Ansicht aktiv
            ist
          </p>
          <p>Die Smart-Komponente gibt die Liste der Blog-Posts an die BlogList zum Anzeigen</p>
          <p>
            Die Smart-Komponente gibt jeweils eine Callback-Funktion an die BlogList und die
            PostEditor
          </p>

          <pre><code>
function App() {
  const [posts, setPosts] = React.useState([]);
  const [view, setView] = React.useState("list");

  function addPost(newPost) {
    // Neuen Post hinzufügen
    setPosts([...posts, newPost]);

    // Wieder Liste anzeigen
    setView("list");
  }

  if (view === "list") {
    return &lt;BlogList posts={posts} onAdd={() => setView("PostEditor")} />
  }

  return &lt;PostEditor onAdd={addPost} />

}            
</code></pre>
        </section>

        <section>
          <h3>Beispiel #2</h3>

          <p>
            Die BlogList zeigt die übergebene Liste nur an und informiert die App, wenn auf den
            "Add"-Button gedrückt wurde
          </p>
          <p>Die App kann dann die andere Komponente (PostEditor) anzeigen</p>

          <pre><code>
  function BlogList(props) {

    return &lt;div>
      // ... Liste anzeigen ...
      &lt;button onClick={props.onAdd}>Add Blog Post&lt;/button>
    &lt;/div>;
  }            
  </code></pre>
        </section>

        <section>
          <h3>Beispiel #3</h3>

          <p>
            Die PostEditor erfasst einen neuen BlogPost und übergibt diesen der Callback-Funktion,
            so dass die App-Komponente ihn in die Liste der BlogPosts (State) einfügen kann
          </p>
          <pre><code>
  function PostEditor(props) {
    const [title, setTitle] = React.useState("");
    const [body, setBody] = React.useState("");

    function addPost() {
      const newPost = {
        title, body
      }

      // App-Komponente informieren
      props.onAdd(newPost);
    }

    return &lt;div>
      // ... Formular rendern ...
      &lt;button onClick={addPost}>Save Post&lt;/button>
    &lt;/div>;
  }            
  </code></pre>
        </section>

        <section>
          <h2>Übung: Baue eine komplette "Anwendung"</h2>
          <p>
            <em>
              Integriere deine bestehende <code>PostEditor</code>-Komponente und die neue
              <code>PostList</code> Komponente über die <code>App</code>-Komponente</em
            >
          </p>
        </section>
        <section>
          <h3>Schritte</h3>
          <ol class="xx-list">
            <li>
              kopiere das Material aus <code>blog-example/material/3-hierarchy/src</code> in deinen
              source Ordner
              <span style="font-size: 85%;"
                >(Du kannst deinen eigenen <code>PostEditor</code> verwenden oder den aus
                material/3-hierarchy)</span
              >
            </li>

            <li>
              Erweitere die <code>App</code> Komponente, so dass sie den
              <code>PostEditor</code> anzeigt, wenn der User auf den <code>Add</code> Button klickt.
              <p>- In <code>App.js</code> stehen TODOs mit weiteren Infos</p>
            </li>
            <li>
              Im<code>PostEditor</code> benötigst Du einen Save Button, der die übergebene
              Callback-Funktion aufruft, die von der <code>App</code> als Property
              (<code>onSave</code>) übergeben wird. <br />Siehe TODO in
              <code>blog-example/material/3-hierarchy/src/PostEditor.js</code>
            </li>
            <li class="fragment" style="margin-top: 2rem;">
              Eine mögliche <b>Lösung</b> für diese Aufgabe findest Du in
              <code>blog-example/steps/3-hierarchy</code>
            </li>
          </ol>
        </section>

        <!-- ANFANG KLASSEN -->
        <section>
          <h2>React: Komponenten als ES6 Klassen</h2>
        </section>

        <section>
          <h3>React: Rendering</h3>
          <span class="fragment">
            <p>
              <em>Jede React Komponenten-Klasse braucht eine <code>render</code>-Methode:</em>
            </p>

            <ul>
              <li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
              <li>analog zur Komponente als Funktion</li>
            </ul>
          </span>
        </section>

        <section>
          <h3>Properties einer Komponente</h3>
          <ul class="fragment">
            <li>Properties werden über den Konstruktor in die Komponente hineingereicht</li>
            <li>
              Zugriff über
              <code>this.props</code>
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              class Header extends React.Component {
                constructor(props) {
                  super(props);
                }
  
                render() {
                  return (
                    &lt;h1 style={{color: this.props.titleColor}}>{this.props.title}&lt;/h1>
                  );
                }
              }
              </code></pre>

          <ul class="fragment">
            <li>Zum Vergleich: Komponente als Funktion</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                    function Header(props) {
                        return (
                          &lt;h1 style={{color: props.titleColor}}>{props.title}&lt;/h1>
                        )
                    }
                    </code></pre>
        </section>

        <section>
          <h3>Zustand einer Komponente</h3>
          <ul>
            <li class="fragment">
              <b>Initialisieren</b> im Konstruktor mit <code>this.state={}</code>
            </li>
            <li class="fragment">Zustand <b>lesen</b> über <code>this.state</code></li>
            <li class="fragment">
              Zustand <b>setzen</b> über
              <code>this.setState()</code>
              <ul class="fragment">
                <li><b>Achtung:</b> kein "reiner" Setter</li>
                <li class="fragment">Führt alten und neuen Zustand zusammen</li>
                <li class="fragment">Wird asynchron ausgeführt!</li>
                <li class="fragment">
                  <b>Löst erneutes rendern der <i>gesamten</i> Komponente aus</b>
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Beispiel: State in Komponente als Klasse</h3>

          <pre><code data-trim contenteditable>
      import React from "react";
      
      export default class PostEditor extends React.Component {
      
        constructor(props) {
          super(props);
      
          this.state = {
            title: props.initialTitle,
            body: props.initialBody
          };
        }
      
        render() {
          return (
            &lt;div>
              &lt;input 
                value={this.state.title} 
                onChange=
                  {event => this.setState({title: event.target.value})}
              />
              &lt;input 
                    value={this.state.body} 
                    onChange=
                      {event => this.setState({body: event.target.value})}
              />
            &lt;/div>
          );
        }
      }</code></pre>
        </section>

        <section id="t-server">
          <h1>Teil IV</h1>
          <h2>Server Zugriffe</h2>
          <em>Lesen und Schreiben von Daten von einem Backend (REST/HTTP)</em>
          <p><code>blog-example/steps/4-remote</code></p>
        </section>

        <section>
          <h3>Herausforderungen</h3>
          <ol>
            <li>Wie machen wir das Laden und Speichern technisch?</li>
            <li>
              Wo steht der Code zum initialen Laden der Blog Posts? (beim Start der Anwendung)
            </li>
            <li>Wo speichern wir?</li>
            <li>Wie funktioniert asynchrone Verarbeitung in React?</li>
          </ol>
        </section>

        <section>
          <h3>Server-Calls</h3>
          <ul>
            <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
            <li class="fragment">
              Häufig in React verwendet: <b>fetch</b> API
              <ul>
                <li>Browser-API zum Ausführen von HTTP Requests</li>
                <li>
                  <a href="http://caniuse.com/#search=fetch" target="_blank">hohe Verbreitung</a>
                </li>
                <li>
                  Spezifikation:
                  <a href="https://fetch.spec.whatwg.org/" target="_blank"
                    >https://fetch.spec.whatwg.org/</a
                  >
                </li>
                <li>
                  Polyfill:
                  <a href="https://github.com/github/fetch" target="_blank"
                    >https://github.com/github/fetch</a
                  >
                </li>
              </ul>
            </li>
            <li class="fragment">
              Alternative:
              <a href="https://github.com/tannerlinsley/react-query" target="_blank">
                React Query</a
              >
              oder <a href="https://swr.vercel.app/" target="_blank"> SWR</a>
              (Ausgereifte Hook APIs zum Arbeiten mit Server Requests)
            </li>
            <li class="fragment">
              Alternative: <a href="https://github.com/axios/axios">axios</a>, High-Level-API
              basiert auf XMLHttpRequest
            </li>
            <li class="fragment">
              Alternative: <a href="https://github.com/developit/redaxios">redaxios</a>, wie axios,
              aber auf fetch-basierend
            </li>
          </ul>
        </section>

        <section>
          <h3>Beispiel: fetch</h3>
          <p>Lesen von Daten (mit HTTP GET)</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// JavaScript Promise API:

fetch('http://localhost:7000/posts')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));
</code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>Hintergrund: Promises</h3>

          <pre><code class="javascript" contenteditable>
// Ein ausgedachtes Promise, dass "irgendwann" den String "Klaus" zurückgibt
const promise = ...;
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>// 'then' gibt IMMER ein Promise zurück
const promise2 = promise.then(name => `Hello, ${name}`);</code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise2.then(greeting => console.log(greeting));
// Ausgabe "irgendwann": "Hello, Klaus"
  </code></pre>
        </section>
        <section data-state="es6-exkurs">
          <h3>Fehler unterbrechen die Promise-Kette</h3>
          <h4>Mit <code>catch()</code> kann man den Fehler fangen und darauf reagieren</h4>
        </section>

        <section data-state="es6-exkurs">
          <h3>Catch im Fehlerfall</h3>
          <pre><code class="javascript" contenteditable>
  const promise = new Promise( /* wie gesehen */ )
    .then(name => {throw new Error("Unexpected Error") })
    .then(greeting => console.log(greeting));
    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Output: Greeting failed: Unexpected error
    </code></pre>
        </section>
        <section>
          <h3>Beispiel: fetch</h3>
          <p>Lesen von Daten (mit HTTP GET)</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// async/await API, identisch mit Beispiel zuvor
try {
  const response = await fetch('http://localhost:7000/posts')
  const json = await response.json();
  // ...
} (catch ex) {
  console.error('request failed', ex)
}
          </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h2>async / await</h2>
          <p>"Wrapper" um Promises</p>
          <p>Erlaubt es, asynchronen Code "linear" hinzuschreiben</p>
          <ul class="fragment">
            <li>Seit ECMASCript 2017 Standard</li>
          </ul>
        </section>
        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p><code>await</code> wartet bis ein Promise aufgelöst wird</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p><code>async</code> machen eine Funktion zu einer "async function"</p>
          <p class="fragment">
            Eine <code>async</code> Funktion gibt &nbsp; <b>immer</b> ein Promise zurück
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> Funktion als Fat Arrow Funktionen:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p>
            Anstadt <code>then</code> oder <code>catch</code>-Ketten kannst Du einfach mehrere
            <code>await</code> Statements verwenden und try/catch für die Fehlerbehandlung:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>
        <section>
          <h3>Beispiel #2: fetch</h3>
          <p>Schreiben von Daten mit HTTP POST</p>
          <div class="fragment">
            <p><code>fetch</code> erwartet als 2. Parameter ein Konfigurationsobjekt:</p>

            <ul>
              <li>
                <code>method</code>: HTTP Methode (<code>PUT</code>, <code>POST</code>,
                <code>DELETE</code>, ...)
              </li>
              <li><code>headers</code>: HTTP Header für den Request (z.B. Authorization)</li>
              <li><code>body</code>: Der Payload (als String!)</li>
            </ul>
            <p>Der Returnwert ist derselbe wie bei GET</p>
          </div>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
const response = await fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(payload)
})
// ... 
    </code></pre>
        </section>

        <section>
          <h3>fetch: Zusammenfassung</h3>

          <pre><code class="javascript" contenteditable data-trim>
  try {
    // 1. fetch returns a Promise, that will be resolved with a
    // Response object when the answer from the server comes in
    const response = await fetch('http://localhost:7000/posts');
  
    // 2. the Response object contains "meta data" about the Response
    // (for ex. http status code) and functions the read the payload,
    // for example from JSON:
    const posts = await response.json();
  
    // btw: What do we do with the answer here in our React application?
    // ???
  } catch (err) {
    // 4. In case something goes wrong, log error
    console.error('request failed', err);
  }
  
  </code></pre>
          <p>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
          </p>
        </section>

        <section>
          <h3>Wann laden wir die initialen Daten für unsere Anwendung (Blog Posts)?</h3>
        </section>

        <section>
          <h3>Laden (und speichern) von Daten</h3>
          <p>👉Schritt-für-Schritt</p>
          <p style="font-size: small;"><code>steps/3-hierarchy</code></p>
        </section>

        <section>
          <h3>Fetch-on-Render</h3>
          <p>Wir können den Server-Aufruf beim Rendern der Komponente triggern</p>
          <p>
            Bis die Daten verfügbar sind (während des laufenden Server Requests) zeigen wir einen
            Loading Indicator
          </p>
        </section>

        <section>
          <h3>Seiteneffekte</h3>
          <p>
            Server-Aufrufe sind <b>Seiteneffekte</b> (andere Beispiele: DOM manipulieren, WebSocket
            öffnen)
          </p>
          <p>Seiteneffekte sind in der <b>Renderphase</b> einer Komponente verboten!</p>
        </section>

        <section>
          <h3>useEffekt-Hook</h3>
          <p>
            <em
              >Mit useEffekt kann eine Funktion registriert werden, die nach dem Rendern der
              Komponente ausgeführt wird</em
            >
          </p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function App(props) {
              React.useEffect( 
                () => console.log("I will run after EACH render")
              );
            }
          </code></pre>

          <div class="fragment">
            2. Parameter (array) gibt an, wenn die Funktion ausgeführt werden soll ("dependencies")

            <pre class="fragment"><code class="javascript" contenteditable data-trim>
              function App(props) {
                React.useEffect( 
                  () => console.log("I will run only once after 1st rendering"),
                  []
                );
              }
            </code></pre>
          </div>

          <div class="fragment">
            Nur nach dem 1. Rendern und immer wenn sich die postId ändert:

            <pre class="fragment"><code class="javascript" contenteditable data-trim>
                function App(props) {
                  React.useEffect(
                    () => console.log("..."), 
                    [props.postId]) 
                  );
                }
              </code></pre>
          </div>
        </section>

        <section>
          <h3>useEffect Hook</h3>

          <p>Zwei Parameter:</p>
          <ul>
            <li class="fragment">
              Callback-Funktion, die aufgerufen wenn entsprechendes Ereignis eintritt (z.B.
              initiales Rendern abgeschlossen)
            </li>
            <li class="fragment">
              Ein Array mit Abhängigkeiten:
              <ul>
                <li class="fragment">
                  Wenn kein Array angegeben wird, wird der Effekt nach jedem Rendern ausgeführt
                  (achtung! Endlosschleife möglich)
                </li>
                <li class="fragment">
                  Wenn ein leeres Array angegeben wird, wird der Effekt nur nach dem 1. Rendern
                  ausgeführt
                </li>
                <li class="fragment">
                  Wenn Werte angegeben werden, wird der Effekt ausgeführt, wenn sich mind 1 Wert
                  verändert hat
                </li>
              </ul>
            </li>
          </ul>

          <p class="fragment">
            Um auf das Entfernen der Komponente aus dem DOM zu reagieren (z.B Resourcen freigeben),
            kann die Callback-Funktion eine weitere Funktion zurückliefern, die dann ausgeführt
            wird:
          </p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                  function GreetingController(props) {
                    React.useEffect(
                      () => {
                        console.log("greetingId hat sich geändert"); 
                        return () => console.log("Ich bin entfernt worden") 
                      },
                      [props.greetingId])
                    );
                  }
                </code></pre>
        </section>

        <section>
          <h3>Beispiel: initiales Laden von Daten</h3>

          <div>
            <p>
              <code>useEffect</code> und (<code>useState</code>) werden verwendet um die initialen
              Daten zu laden
            </p>
            <pre><code class="javascript" contenteditable data-trim>
                function App() {
                  const [posts, setPosts] = React.useState([]);
                
                  React.useEffect(() => {
                    fetch("http://localhost:7000/posts")
                      .then(response => response.json())
                      .then(json => setPosts(json));
                  }, []);

                  return {posts.map(p => (
                    &lt;Post key={p.id} post={p} />
                  ))}
                }
                
                </code></pre>
          </div>
        </section>

        <section>
          <h3>Speichern von Daten</h3>
          <p>Als Folge einer Benutzerinteraktion:</p>
          <p class="fragment">In einem Event-Handler können Seiteneffekte verwendet werden!</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function App(props) {
  // load, as seen
  React.useEffect( ... );

  function addPost(post) {
    fetch("http://localhost:7000/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(post)
    })
      .then(response => response.json())
      .then(newPost => setPosts([newPost, ...posts]));
  }


  return
    ...
      &lt;AddPost onAdd={newPost => addPost(newPost)} />
    ...
}
                </code></pre>
        </section>

        <section>
          <h2>Übung: Laden und Speichern von Daten auf einem Server</h2>
          <p>
            <em
              >Implementiere die nächste Version der <code>App</code>-Komponente, die in der Lage
              ist, die Blog Posts mit <code>fetch</code> zu laden und zu speichern.</em
            >
          </p>
          <p>
            Das backend ist bereits fertig. Ihr könnt es starten mit:
          </p>
          <pre><code>
                  cd react-training/blog-example/backend-rest
                  npm start
                </code></pre>
          <p>Der Server läuft auf Port 7000</p>
          <p>
            Ihr könnt das Backend mit folgender ULR testen (Browser, wget, curl, ...):
            <a href="http://localhost:7000/posts">http://localhost:7000/posts</a>
          </p>
        </section>

        <section>
          <h3>Schritte</h3>
          <ol class="x-list">
            <li class="fragment">
              Kopiere <code>blog-example/material/4-remote/App.js</code> in deinen src-Folder und
              füge dort den Code zum Laden und Speichern hinzu.
            </li>

            <li class="fragment">In <code>App.js</code> sind TODOs enthalten.</li>
            <li class="fragment">
              Füge einen Loading Indicator hinzu
              <ul>
                <li>
                  Wenn Du <code>?slow</code> an die URLs im <code>fetch</code>-Aufruf hängst, wird
                  der Server-Call künstlich verlangsamt
                </li>
                <li>
                  Füge einen neuen Zustand in der App-Komponente hinzu, der festhält, ob ein
                  Server-Call gerade läuft
                </li>
                <li>
                  Gib während des laufenden Server-Calls eine Meldung aus ("Bitte warten Sie")
                </li>
              </ul>
            </li>
            <li class="fragment" style="margin-top: 2rem;">
              Mögliche <b>Lösungen</b> für diese Aufgabe findest Du in
              <code>blog-example/steps/4-remote</code> und
              <code>blog-example/step/4-remote-with-loading</code>
            </li>
          </ol>
        </section>

        <!-- ============================================================================= -->

        <section>
          <h3>Komplexer Zustand</h3>
          <p>
            Wenn eine Komponente mehrere Zustände hält, die nicht unabhängig sind, kannst Du auch
            ein Objekt als Zustand verwende:
          </p>

          <pre class="fragment"><code class="javascript">
function App() {
  const [fetchState, setFetchState] = React.useState({
    loading: false,
    posts: []
  });

  ...;
}              
            </code></pre>
          <p class="fragment">
            Wenn Du den Zustand änderst, musst Du ein <b>neues Objekt</b> erzeugen! Das bestehende
            Objekt darf nicht verändert werden
          </p>

          <pre class="fragment"><code class="javascript">
    function App() {
      const [fetchState, setFetchState] ...;

      // OK:
      setFetchState({
        loading: true
      })

      // FALSCH:
      fetchState.loading = true;
      setFechtState(fetchState)
    }              
        
  </code></pre>
        </section>

        <section>
          <h3>Custom Hooks</h3>

          <em>Eigene Hooks können für wiederkehrende Aufgaben genutzt werden</em>

          <p class="fragment">
            Beispiele: Laden von Daten, Arbeiten mit spezialisiertem State, ...
          </p>
        </section>

        <section>
          <h3>Custom Hooks</h3>

          <ul class="x-list">
            <li class="fragment">
              ...müssen mit <code>use</code>beginnen
              <ul>
                <li>(ansonsten kann der Linter nicht auf mögliche Fehler prüfen!)</li>
              </ul>
            </li>
            <li class="fragment">
              ...dürfen nur aus anderen (Custom) Hooks und Komponenten aufgerufen werden
            </li>
            <li class="fragment">
              ...erwarten "normale" Funktionsparameter (nicht zwingend ein Objekt wie bei
              Komponenten)
            </li>
            <li class="fragment">...dürfen andere (Custom) Hooks verwenden</li>
            <li class="fragment">
              ...beliebiger Rückgabewert möglich (alle Typen erlaubt, auch JSX!)
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Ein Custom Hook zum Laden von Daten</h3>

          <pre><code class="javascript">
import React from "react";

export default function useApi(url, initialValue) {
  const [isLoading, setLoading] = React.useState(false);
  const [data, setData] = React.useState(initialValue);

  React.useEffect(
    () => {
      async function loadData() {
        try {
          setLoading(true);
          setData(initialValue);
          const response = await fetch(url);
          const json = await response.json();
          setData(json);
        } catch (err) {
          console.error("LOADING DATA FAILED:", err);
          setData(initialValue);
        } finally {
          setLoading(false);
        }
      }
      loadData();
    },
    // Make sure, this Hook only runs (after initial) when URL changes
    [url]
  );

  return [data, setData, isLoading];
}
</code></pre>
        </section>

        <section id="t-typescript">
          <h1>Teil V</h1>
          <h2>React Anwendungen mit TypeScript</h2>
          <p>Example: code/blog-example/steps/5-typescript</p>
        </section>

        <section id="t-typescript-react">
          <h2>React Anwendungen mit TypeScript</h2>
          <em
            >State und Properties einer Komponente können mit TypeScript Typen beschrieben weden</em
          >
          <p class="fragment">
            Achtung! TypeScript-Dateien, die JSX-Code enthalten, <b>müssen</b> mit
            <code>.tsx</code> enden!
          </p>
          <p class="fragment">
            Empfehlung: bei typecasts "as" Notation verwenden (<code>x as string</code> vs.
            <code>&lt;string&gt;x</code>), gibt sonst manchmal Probleme mit den spitzen Klammern.
          </p>

          <p class="fragment">
            👉 Lasst uns ausprobieren, wie das funktioniert! (<code>workspace-typescript</code>)
          </p>
        </section>
        <section>
          <h2>Typsicherheit in Funktionskomponenten</h2>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type PostListProps = {
  posts: BlogPost[];
  onAddPost(): void;
};
            </code></pre>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
    function BlogList(props: PostListProps) {
      props.posts.length // OK
      
      props.post // compile ERROR: Property 'post' does not exist on type 'PostListProps'.
      props.onAddPost("huhu"); // compile ERROR: Expected 0 arguments, but got 1.
    }
    
            </code></pre>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
    // Mit Destructuring
    function BlogList({posts, onAddPost}: GreetingMasterProps) => {
      // ...
    }
    
            </code></pre>
        </section>

        <section>
          <h3>Typ-sichere Verwendung von Komponenten</h3>

          <div class="fragment">
            <p>Code Completion</p>
            <img style="height: 200px;" src="slides/images/screenshot-ts-code_completion.png" />
          </div>

          <div class="fragment">
            <p>Unbekanntes Property</p>
            <img style="height: 200px;" src="slides/images/screenshot-ts-error-01.png" />
          </div>

          <div class="fragment">
            <p>Fehlerhafte Verwendung eines Properties</p>
            <img style="height: 200px;" src="slides/images/screenshot-ts-error-02.png" />
          </div>
        </section>

        <section>
          <h3>Typ-sicherheit in useState</h3>
          <p>Der Typ von useState kann grundsätzlich von TypeScript hergeleitet werden</p>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type PostEditorProps = {  onSavePost(post: NewBlogPost): void; };
function PostEdior(props: PostEditorProps) {
  const [title, setTitle] = React.useState("");

  // greeting is string, because initial value is a string
  setGreeting("huhu"); // OK
  setGreeting(666); // ERROR (wrong Type)
  setGreeting(null); // ERROR (wrong Type)
}
            </code></pre>
          <div class="fragment">
            <p>Du kannst alternativ den Typen auch explizit setzen</p>
            <p class="fragment">
              Zum Beispiel notwendig, wenn der State mehr als einen Typen aufnehmen kann
            </p>
            <pre
              class="fragment"
            ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type VIEW = "LIST" | "ADD";

function App() {
  const [view, setView] = React.useState&lt;VIEW>("LIST");

  // Mode ist either string "MODE_MASTER" or "MODE_DETAIL"
  // setMode only accepts the string "MODE_MASTER" and "MODE_DETAIL" 

  setMode("NOT_FOUND"); // compile error
  setMode(null); // compile error
}
                            </code></pre>
          </div>
        </section>

        <section>
          <h2>React Events in TypeScript</h2>
          <p class="fragment">
            In TypeScript gibt es für die konkreten Events eigene Typen (z.B. ChangeEvent,
            MouseEvent)
          </p>
          <p class="fragment">
            Die Event-Typen erwarten einen Typ-Parameter, der auf den Typ des HTML Elements gesetzt
            werden muss, das das Event auslöst
          </p>
          <p class="fragment">
            TypeScript kennt dann die Eigenschaften des Events bei der Verarbeitung
          </p>
          <span class="fragment">
            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
function PostEditor(props) {
  const [title, setTitle] = React.useState("");

  function handleChange(e: React.ChangeEvent&lt;HTMLInputElement>) {
    setTitle(e.currentTaget.value);
  }

  return &lt;input onChange={handleChange} value={title} />
}              
          </code></pre>
            <a
              href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682"
              target="_blank"
            >
              <code>target</code> vs
              <code>currentTarget</code>
            </a>
          </span>
        </section>

        <section>
          <h2>Übung: Typ-sichere React Komponenten</h2>
          <h3>
            <em>Füge die fehlenden Typ-Informationen zu der App-Anwendung hinzu</em>
          </h3>
          <div style="font-size: 80%;">
            <div class="fragment">
              <p>
                <b>WORKSPACE:</b>
              </p>
              <p>
                Bitte benutze den Workspace <code><b>blog-example/workspace-typescript</b></code
                >. <br />Dieser enthält die letzte Version unserer Anwendung, ist aber mit
                TypeScript konfiguriert.
              </p>
            </div>
            <div class="fragment">
              <p>
                <b>VORBEREITUNG:</b>
              </p>
              <ol class="x-list">
                <li>Stop deinen laufenden "npm run"-Frontend-Prozess (ctrl+c)</li>
                <li>
                  Führe <code><b>npm install</b></code> in
                  <code>blog-example/workspace-typescript</code> aus
                </li>
                <li>
                  Führe <code><b>npm start</b></code> in
                  <code>blog-example/workspace-typescript</code> aus
                </li>
              </ol>
            </div>
          </div>
        </section>
        <section>
          <h3>Übung: Typ Informationen hinzufügen</h3>
          <p>
            Füge die fehlenden Typ-Informationen in <code>PostList.js</code> und
            <code>PostEditor.js</code> hinzu
          </p>
          <ol style="font-size: 80%;" class="x-list">
            <li class="fragment">
              Benenne <code><b>PostList.js</b></code> in <code>PostList.tsx</code> um und starte
              <code>npm start</code> neu
            </li>
            <li class="fragment">Stelle <code>PostList.tsx</code> auf TypeScript um</li>
            <li class="fragment">
              Benenne <code><b>PostEditor.js</b></code> in <code>PostEditor.tsx</code> um und starte
              <code>npm start</code> neu
            </li>
            <li class="fragment">Stelle <code>PostEditor.tsx</code> auf TypeScript um</li>
            <li class="fragment">Weitere Informationen kannst Du in den Dateien finden.</li>
            <li class="fragment" style="margin-top: 2rem;">
              Eine mögliche <b>Lösung</b> für diese Aufgabe findest Du in
              <code>blog-example/steps/5-typescript</code>
            </li>
          </ol>
        </section>

        <section id="t-test">
          <h1>Part VI</h1>
          <h2>Testing React Applications</h2>
        </section>

        <section>
          <h2>Exkurs: Material UI</h2>

          <p>Beispiel: <code>steps/6-tests-with-material-ui</code></p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Material UI</h3>
          <p><a href="https://material-ui.com/">https://material-ui.com/</a></p>
          <ul>
            <li class="fragment">
              React-Komponenten, mit denen Googles Material Design realisiert werden kann
            </li>
            <li class="fragment">
              Viele Basis-Komponenten wie Button, Text-Felder, Typographie etc
            </li>
            <li class="fragment">
              Die Komponenten kümmern sich um das korrekte CSS samt Fonts und Icons, so wie es das
              Material Design vorsieht
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function PostList(props) {
  return &lt;>
      &lt;Fab color="primary" aria-label="Add Post" onClick={props.onAddPost}>
        &lt;AddIcon />
      &lt;/Fab>
      {posts.map(p => (
        &lt;Card key={p.id}>
            &lt;Typography variant="overline">
              {formattedDate(p.date)}
            &lt;/Typography>
            &lt;Typography variant="h2">
              {p.title}
            &lt;/Typography>
            &lt;Typography variant="body1">
              {p.body}
            &lt;/Typography>
        &lt;/Card>
      ))}
    &lt;/>
}

          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Styling</h3>
          <ul>
            <li class="fragment">
              Grundsätzlich sind die Material UI Komponenten "fertig" gestyled
            </li>
            <li class="fragment">
              Man kann das CSS aber überschreiben, in dem man das <b>class</b>-Property angibt und
              einen CSS-Klassennamen übergibt
            </li>
            <li class="fragment">
              Um gezielter einzelne Teile einer Komponente zu verändern, kann man eine Reihe von
              Komponente-spezifischen CSS-Klassen mit dem <code>classes</code>-Property angeben:
              <pre class="fragment"><code class="javascript">
&lt;Input classes={{
  focused: "my-focus-class",
  disabled: "my-disabled-class"
}} ... />                
              </code></pre>
            </li>

            <li class="fragment">
              In diesem Fall müsst ihr dafür sorgen, dass <code>my-focus-class</code> und
              <code>my-disabled-class</code> in Eurem Code irgendwo definiert sind, z.B. in einem
              externen CSS-Stylesheet
            </li>
            <li class="fragment">
              Wichtig! Die Keys im classes-Objekt sind nicht die tatsächlichen CSS-Klassen, die
              Material-UI verwenden, sondern logische Namen. Diese sind jeweils in der Komponenten
              API beschrieben
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Styling #2: CSS-in-JS</h3>
          <ul>
            <li class="fragment">
              Für Material UI spielt es grundsätzlich keine Rolle, wo Euer eigenes CSS herkommt; ihr
              müsst die Klassennamen nur mit <code>className</code> oder
              <code>classes</code> angeben.
            </li>
            <li class="fragment">
              Eine Idee für CSS mit React wird <b>CSS-in-JS</b> genannt. Dabei schreibt ihr den
              CSS-Code direkt in Eurer JavaScript-Anwendung
            </li>
            <li class="fragment">
              Das ist nicht Material UI-spezifisch, wird aber von Material UI untersützt
            </li>
            <li class="fragment">
              Material UI verwendet dazu eine eigene Implementierung, bekannt für diesen Ansatz ist
              auch <a href="https://styled-components.com/">Styled Components</a>
            </li>
            <li class="fragment">
              Aus Euren in JavaScript geschrieben Styles erzeugt die Bibliothek
              <code>style</code>-Elemente. Die Styles werden also nicht "inline" auf die Elemente
              angewandt
            </li>
          </ul>
        </section>
        <section>
          <h3>Styling #3: makeStyles und useStyles-Hook</h3>
          <ul>
            <li class="fragment">
              In Material UI könnt ihr Euch eine Hook-Funktion erzeugen lassen, die in Eurer
              Komponente Referenzen auf den CSS-Code hält
            </li>
            <li class="fragment">
              Diese Hook-Funktion wird mit der Funktion <code>makeStyles</code> erzeugt.
              <code>makeStyles</code> übergebt ihr ein Objekt mit CSS-Klassen und deren
              Eigenschaften
            </li>
            <li class="fragment">
              Das Besondere daran ist, dass ihr in den CSS-Eigenschaften JavaScript-Code verwenden
              könnt (z.B. für Variablen oder Berechnungen)
            </li>
          </ul>
          <pre class="fragment"><code class="javascript">
// Eine neue Klasse "MessageBox" definieren
const useStyles = makeStyles({
  MessageBox: { 
    // "reguläre" CSS-Eigenschaft
    marginBottom: "2rem",

    // Wert für CSS basierend auf Komponeten-Properties,
    backgroundColor => props.warning ? "orange" : "gren"
  }
});
</code></pre>
          <pre class="fragment"><code class="javascript">

function MessageBox(props) {
  const styles = useStyles(props); // Referenz auf die Styles

  // Klasse verwenden (muss keine Material UI-Komponente sein!)
  return &lt;div className={styles.MessageBox}>...f&lt;/div>
}
                  </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Styling #4: Styled Components-Stil</h3>

          <ul>
            <li class="fragment">
              Durch die Bibliothek <b>Styled Components</b> ist ein etwas anderer CSS-in-JS-Stil
              bekannt geworden
            </li>
            <li class="fragment">
              Eine ähnliche API bietet auch Material UI als Alternative zur Hook API an.
            </li>
            <li class="fragment">
              Bei dieser Variante erzeugt man eine neue, gestylte, Komponente aus einer bestehenden.
            </li>
            <li class="fragment">
              Das eigenet sich besonders für wiederverwendbare Basis-Komponenten
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
export const LargeInput = styled(Input)({
  fontSize: props => props.xxl ? "2rem" : "1rem"
})
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Verwendung wie eine "normale" Komponente
&lt;LargeInput xxl="true" />            
                      </code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Styling: Zusammenfassung</h3>
          <ul>
            <li class="fragment">Material UI ist "fertig" gestyled</li>
            <li class="fragment">
              Ihr könnt das Aussehen jeder Komponente mit spezifischen CSS-Klassen verändern
            </li>
            <li class="fragment">
              Wo das CSS herkommt bleibt Euch überlassen: "klassisches" externes CSS (ggf. mit
              SASS/LESS) oder CSS-in-JS
            </li>
            <li class="fragment">für CSS-in-JS bringt Material UI eine eigene Bibliothek mit</li>
            <li class="fragment">
              (Diese Bibliothek könnt ihr auch ohne MAterial UI verwenden, falls das relevant ist)
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Theming</h3>
          <ul>
            <li class="fragment">
              Mit CSS könnt ihr das Aussehen einzelner Material UI Komponenten beeinflussen
            </li>
            <li class="fragment">
              Mit <b>Theming</b> könnt ihr das "generelle" Design anpassen (Schriftarten, Farben,
              Abstände etc)
            </li>
            <li class="fragment">
              Um ein Theme zu erstellen, wird die <code>createMuiTheme</code>-Funktion verwendet
            </li>
            <li class="fragment">
              Diese Funktion erlaubt es, beliebige Werte aus dem Default-Theme zu überschreiben und
              anzupassen
            </li>
            <li class="fragment">
              Das erzeugte Theme wird dann mittels eines ThemeProviders in die Anwendung gereicht:

              <pre class="fragment"><code class="javascript">
const blogTheme = createMuiTheme({ ... });

return &lt;App>
  &lt;ThemeProvider theme={blogTheme}>
    ...alle Komponenten hierunter verwenden automatisch das eingestellte Theme...
  &lt;/ThemeProvider>
&lt;/App>;  
}  
</code></pre>
            </li>
            <li class="fragment">
              Die Material UI Komponenten verwenden das eingestellt Theme automatisch
            </li>
            <li class="fragment">
              Eigene Komponenten können mit dem <code>useTheme</code> darauf zugreifen und die
              Informationen auswerten:

              <pre class="fragment"><code class="javascript">
function BlogList() {
   const theme = useTheme();

   return &lt;article>&lt;h1 styles={{font: theme.typography.fontWeightBold}}>...&lt;/h1>&lt;/article>; 
}  
</code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Fragen?</h3>
          <p>
            Habt ihr noch Fragen, zur Material UI Bibliothek, die wir gemeinsam besprechen sollen?
          </p>
        </section>

        <section>
          <h2>Testen</h2>
        </section>

        <section data-transition="slide none">
          <h2>What do we test?</h2>
          <ul>
            <li class="fragment">
              <b>UI-independent logic</b> (for example services, backend calls)
            </li>
            <li class="fragment">
              <b>Rendering</b> (is the list of blog post correctly rendered? is the markup as we
              want it?)
            </li>
            <li class="fragment">
              <b>Interactions</b> (are my event handlers working and correctly set?)
            </li>
            <li class="fragment">
              <b>Behaviour in the browser</b> (z.B. correct rendering, Browser-spezific JavaScript,
              Working with browser artefacts, such as history, Title, Scrollbars etc)
            </li>
          </ul>
        </section>
        <section data-transition="slide none">
          <h2>What do we test?</h2>
          <ul>
            <li style="color: lightgrey;">
              <b>UI-independent logic</b> (for example services, backend calls)
            </li>
            <li>
              <b>Rendering</b> (is the list of blog post correctly rendered? is the markup as we
              want it?)
            </li>
            <li><b>Interactions</b> (are my event handlers working and correctly set?)</li>
            <li style="color: lightgrey;">
              <b>Behaviour in the browser</b> (z.B. correct rendering, Browser-spezific JavaScript,
              Working with browser artefacts, such as history, Title, Scrollbars etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a>)</em
            >
          </p>
          <p class="fragment">
            Complete Test solution for React (and others):
          </p>
          <ul class="fragment">
            <li>Test Runner</li>
            <li>Specs, Assertions, Mocks</li>
            <li>Code Coverage</li>
            <li>"Snapshot testing"</li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Example: A simple testcase</h3>
          <pre><code class="javascript" contenteditable data-trim>// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> or
            <code>it</code>
          </p>
          <pre><code data-trim contenteditable>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code data-trim contenteditable>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Expectations and Matchers</h2>
          <div class="fragment">
            <p>
              <code>expect()</code> returns an <em>Expectation</em> obects, that contains several
              <em>Matcher</em> functions:
            </p>
            <pre><code data-trim contenteditable>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div class="fragment">
            <p>Some Matchers</p>

            <pre><code data-trim contenteditable>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p class="fragment">
            <a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a>
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Functions</h2>
          <ul>
            <li class="fragment">
              <code>jest.fn()</code> creates a mock function
              <pre><code data-trim contenteditable>// Returns undefined when executed
const aMockFn = jest.fn();

aMockFn("huhu"); // => undefined

expect(aMockFn).toHaveBeenCalled());
expect(aMockFn.toHaveBeenCalledWith("huhu"));
                      </code></pre>
            </li>

            <li class="fragment">
              Implementation of the mock function can be passed as parameter:
              <pre><code data-trim contenteditable>
        const aMockFn = jest.fn( param => `Hello, ${param}` );
        
        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Testing React Components</h3>
          <h2>Rendering-only</h2>
        </section>

        <section>
          <h3>React Test Renderer</h3>
          <p>
            <a href="https://www.npmjs.com/package/react-test-renderer"
              >https://www.npmjs.com/package/react-test-renderer</a
            >
          </p>
          <p>Renders React Components into JSON Objects (without DOM):</p>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';

const component = renderer.create(
  &lt;PostList posts={somePosts} />
);

console.log(component.toJSON());
            </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
        { type: 'div',
          props: {},
          children:  [
            { type: 'button', props: {}, children: [Object] },
            { type: 'article', props: [Object], children: [Object] },
            { type: 'article', props: [Object], children: [Object] }
          ]
        }
            </code></pre>
        </section>
        <section>
          <h3>"Snapshot Testing" with Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> compares a JSON-Object with a stored object
            in a file:
          </p>
          <ul>
            <li class="fragment">
              At <b>first</b> execution: Snapshot-File will be created (
              <a href="slides/images/jest-snapshot-file.png" target="_blank">Example</a>)
              <ul>
                <li class="fragment">Snapshot files will be stored in Git</li>
              </ul>
            </li>
            <li class="fragment">
              In all <b>following</b> test executions: new snapshot will be created and compared
              against saved snapshot.
            </li>
            <li class="fragment">
              When Snapshots differ:
              <ul>
                <li>
                  Error including diff (
                  <a href="slides/images/jest-snapshot-diff.png" target="_blank">Example</a>)
                </li>
                <li>
                  In "watch mode" the snapshot can be updated
                  <img src="slides/images/jest-snapshot-update.png" />
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Snapshot Testing with Jest and React</h3>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
        
test('it should render correctly', () => {

  const somePosts = [ . . . ];

  const component = renderer.create(
    &lt;PostList posts={somePosts} />
  );

  expect(component.toJSON()).toMatchSnapshot();
});
            </code></pre>
        </section>

        <section>
          <h3>Testing React Components #2</h3>
          <h2>Interactions</h2>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage good testing
              practices."
            </em>
          </p>

          <p>
            <a href="https://github.com/testing-library/react-testing-library" target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophy: tests are written from a user perspective. To find your elements you want to
            test, you use properties the user also sees (like labels, aria roles, etc)
          </p>
          <p>
            Should make your app better (enforce accessibility) and your tests more stable (don't
            rely on internal DOM structure etc)
          </p>
          <p>
            The same tests can be executed against the "plain CSS version" and "Material UI version"
            of the Blog Example App!
          </p>
          <p class="fragment">👉 <code>workspace-typescript</code></p>
        </section>
        <section>
          <h3>react-testing-library</h3>
          <p>Example</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            import { render, screen } from "@testing-library/react";
            import userEvent from "@testing-library/user-event";

            it("invokes callback on button click", () => {
              const onAddPostFn = jest.fn();
            
              // Render
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            
              // search the button
              const buttonElement = screen.getByRole("button", { name: "Add Post" });

              // "click" the button
              userEvent.click(buttonElement);
            
              // make sure it has been invoked
              expect(onAddPostFn).toHaveBeenCalled();
            });


            </code></pre>
        </section>

        <section>
          <h3>render-Function</h3>
          <p>
            You can use the render-Function from testing-library/react to render your component in
            your test (no browser needed)
          </p>
          <p>
            Just as in real world you can specify properties etc (might be testdata and/or mocks)
          </p>
          <p>
            The render function returns a set of query-functions that can be used to search for
            elements within the rendered components (deprecated!, see next slide)
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            import { render } from "@testing-library/react";

              // Render a single component
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
          </code></pre>
          <p class="fragment">Remember when using Components, that needs a "Context"!</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>

              // Render with surrounding Redux Provider (or Router, your own Context etc.)
              render(
                &lt;Provider>
                  &lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />
                &lt;/Provider>
              );
            </code></pre>
        </section>
        <section>
          <h3>query Functions</h3>
          <p>
            To verify and interact with the elements from your component you need to find them 🤓
          </p>
          <p>
            On the global <b>screen</b> object there are many functions defined, that allows you
            searching for an element
          </p>
          <p>
            The query functions have different <b>suffixes</b>, that describe what they're searching
            for (a label, a aria-role, ...)
          </p>
          <p>
            The query functions have different <b>prefixes</b> (getBy, queryBy etc) that describes
            their outcome (i.e. wether they fail if they don't find the object or if they just
            return nothing)
          </p>
          <p>
            More on this:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre class="fragment"><code class="javascript">
  // EXAMPLES: 

  // search the button (assume there is exactly one, fail otherwise)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // search the button (return null or ONE button, throws Exception otherwise)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // search the button (return all buttons or an empty array)  
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>Verify you components</h3>
          <p>
            After quering a component you can verify their attributes etc to make sure they're
            correct
          </p>
          <p>
            The library
            <a href="https://github.com/testing-library/jest-dom" target="_blank">jest-dom</a> adds
            DOM-specific matchers for jest.
          </p>

          <pre class="fragment"><code class="javascript">
  import { screen } from "@testing-library/react";

  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // assert presence of the element (getBy query would maybe make more sense)
  expect(buttonElement).toBeInTheDocument();

  // assert value of input field
  expect(titleInput).toHaveValue("Moin moin");

  // assert enablement of a button
  expect(okButton).toBeDisabled();
</code></pre>
          <p class="fragment">All matchers are described on the GitHub page (Link see above)</p>
        </section>
        <section>
          <h3>Interaction</h3>
          <p>
            You can interact with the elements from a component by sending events, as the browser
            would do
          </p>
          <p>
            There's a special library
            <a href="https://github.com/testing-library/user-event" target="_blank"> user-event</a>,
            that helps you constructing this events.
          </p>
          <p>(In the next release of react-testing-library it will be included)</p>

          <pre class="fragment"><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // type somthing into an input field
            // (with another parameter you can configure how fast typing speed should be etc)
            userEvent.type(titleInput, "New Title");

            // click a button
            userEvent.click(clearButton);
          </code></pre>
          <p class="fragment">All events can be found on the GitHub page (Link see above)</p>

          <p class="fragment">
            Note that you don't have to test if an element exists before sending an event; the test
            will fail with a readable error message, if the element is not available
          </p>
        </section>
        <section>
          <h3>Testing with fetch</h3>
          <p>Challenges:</p>
          <ul>
            <li>Asynchronous code (not limited to fetch)</li>
            <li>Server mocking</li>
          </ul>
        </section>
        <section>
          <h3>Dealing with asynchronous code</h3>
        </section>

        <section>
          <h3>Testing async code</h3>
          <p>
            Example: The <b>App</b> components loads data, than it displays the post list. Loading
            of the data is async code
          </p>

          <pre class="fragment"><code class="javascript">
            it("should render posts read from backend", () => {
              render(&lt;App />);
            
              // imagine there is an article with title "One"
              const articleOne = screen.findByRole("heading", { name: "One" });

              expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
            });
          </code></pre>
          <p class="fragment">
            Good news: we can write an async test and waitfor the element until it's loaded
          </p>
          <pre class="fragment"><code class="javascript">
            // not the async function here:
            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // note the await statement here:
              const articleOne = await screen.findByRole("heading", { name: "One" });

              expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
            });
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testing fetch</h3>
          <p>As seen, we're able to test async code</p>
          <p class="fragment">Do we want to have fetch calls in our code?</p>
          <p class="fragment">
            Propably not, because we don't want to depend on a running (and working) server in test
          </p>
          <p class="fragment">We want to "mock out" fetch</p>
        </section>

        <section>
          <h3>Mocking fetch #1</h3>
          <p>We can mock whole modules in jest</p>
          <p class="fragment">We could move our fetch code to an own module an mock that</p>

          <pre class="fragment"><code class="javascript">
            // api.ts (simplified!)
            export function readPosts() {
              return fetch("http://localhost:7000/posts").then(response => response.json());
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // App.tsx:

            import { readPosts } from "./api";
            function App() {
              // ...
              React.useEffect(() => {
                // use readPosts here:
                readPosts()
                  .then(json => {
                    setLoading(false);
                    setPosts(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            }
          </code></pre>
        </section>
        <section>
          <h3>Mocking a Module</h3>
          <p>Several ways, this is the simplest one(?)</p>

          <pre class="fragment"><code class="javascript">
            // App.test.tsx

            const mockPosts = [
              { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
              { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
            ];

            jest.mock("../api", () => ({
              readPosts: () => Promise.resolve(mockPosts)
            }));

            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // we still need to await, but we don't care about
              // running server anymore
              const articleOne = await screen.findByRole("heading", { name: "One" });
              expect(articleOne).toBeInTheDocument();

              expect(screen.getByText("Second Post")).toBeInTheDocument();
            });
          </code></pre>
          <p class="fragment">
            Example:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_module_mock.test.tsx</code
            >
          </p>
        </section>
        <section>
          <h3>Option #2: Mocking fetch</h3>
          <p>There are several libs that allows you to mock fetch</p>
          <p>
            For me
            <a href="https://www.npmjs.com/package/jest-fetch-mock" target="_blank"
              >jest-fetch-mock</a
            >
            works best
          </p>

          <pre class="fragment"><code class="javascript">
            // App.test.tsx
            it("should render posts read from backend", async () => {
              // set the expected response (there are more ways to customize the fetch mock behaviour)
              fetchMock.mockResponse(JSON.stringify(mockPosts));

              render(&lt;App />);
            
              // we're still async, but no "real" fetch anymore
              const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

              expect(articleOne).toBeInTheDocument();
            });

          </code></pre>
          <p class="fragment">
            Example:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_jest_mock.test.tsx</code
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Option #3: Mock Service Worker (MSW)</h3>

          <p><a href="https://github.com/mswjs/msw" target="_blank">MSW</a></p>
          <p>Mocks real backend calls using a Service Worker</p>
          <p>fetch-Calls are executed but responded by the service worker mock</p>

          <pre class="fragment"><code class="javascript">
            // PostList.test.js
            import { rest } from 'msw'
            import { setupServer } from 'msw/node'
            
            const server = setupServer(
              rest.get('/posts', (req, res, ctx) => {
                return res(ctx.json( mockPosts ))
              }),
            )

            test("it should render blog list", async () => {
              render(&lt;PostList />);
              // ...
            })
          </code></pre>
        </section>

        <section>
          <h2>Übung: Ein Test für den PostEditor</h2>
          <p>Schritte:</p>
          <ol>
            <li class="fragment">Arbeite in <code>blog-example/workspace-typescript</code></li>
            <li class="fragment">
              Starte in einem neuen Terminal <code>npm test</code> (der Prozess läuft "ewig")
            </li>
            <li class="fragment">
              Es sollte einen fehlerhaften Test geben:
              <b><code>PostEditor.test.tsx</code></b
              >.
            </li>
            <li class="fragment">Warum? Weil der noch leer ist 😬!</li>
            <li class="fragment">
              Implementiere den fehlenden Test. In der Datei<b><code>PostEditor.test.tsx</code></b>
              stehen TODOs dafür
            </li>
          </ol>
          <p class="fragment">
            Hinweis: wenn Du die Datei speicherst, werden die Tests automatisch neu ausgeführt
            (solange Du
            <code>npm test</code> noch laufen hast), ansonsten kannst Du "a" auf der Kommandozeile
            drücken, zum erneuten Ausführen der Tests.
          </p>
          <ul>
            <li class="fragment" style="margin-top: 2rem;">
              Eine mögliche <b>Lösung</b> für diese Aufgabe findest Du in
              <code>blog-example/steps/6-tests</code>
            </li>
          </ul>
        </section>

        <section>
          <h2>Browser Tests</h2>
          <p>Often used:</p>
          <ul>
            <li class="fragment">
              <a href="https://www.selenium.dev/">Selenium - The "classic"</a>
            </li>
            <li class="fragment">
              <a href="https://devexpress.github.io/testcafe/" target="_blank">TestCafe</a>
            </li>
            <li class="fragment"><a href="https://www.cypress.io/" target="_blank">Cypress</a></li>
          </ul>
        </section>

        <section>
          <h3>Testcafe</h3>

          <ul>
            <li class="fragment">Tests werden in JavaScript bzw. TypeScript geschrieben</li>
            <li class="fragment">Out-of-the-box-Support für TypeScript</li>
            <li class="fragment">
              <b>Eigene Test API</b> (baut <b>nicht</b> auf bekannten APIs wie Jest auf 😢)
            </li>
            <li class="fragment">
              Es gibt eine
              <a href="https://testing-library.com/docs/testcafe-testing-library/intro/#usage"
                >testing-library API</a
              >
              für Testcafe
            </li>
            <li class="fragment">
              Support für diverse Browser, einschliesslich
              <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>
            </li>
            <li class="fragment">
              Tests lassen sich auf Remote-Browsern ausführen, zum Beispiel auf dem Smartphone
            </li>
            <li class="fragment">
              Tests lassen sich "headless" im CI-Build (Jenkins, Docker etc) ausführen
            </li>
            <li class="fragment">
              Ausführen:
              <code>testcafe firefox,chrome,safari test-cafe-tests/*.ts</code>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Code Beispiel</h3>
          <p>👉 Beispiel: steps/5-tests-with-material-ui/testcafe/app-test.ts</p>

          <pre class="fragment"><code class="javascript">
            import { Selector } from "testcafe";

            fixture`App Browser Test`.page`http://localhost:3000`;
            
            test("Entering new Blog Post", async t => {
              const titleField = Selector("#titleField");
              const bodyField = Selector("#bodyField");
              const saveButton = Selector("#saveButton");
            
              await t.typeText(titleField, "Learning React");
              await t.expect(titleField.value).eql("Learning React");

              await t.click(saveButton);
            });
                        
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Test Cafe tests</h3>

          <ul>
            <li>
              Mit der <code>test</code>-Funktion werden Tests geschrieben (nicht verwechseln mit
              Jest...)
            </li>
            <li>
              Eine Test-Funktion muss eine async-Funktion sein, denn alle Interaktionen mit dem
              Browser erfolgen asynchron
            </li>
            <li>Der Test-Funktion wird ein Controller-Objekt übergeben...</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Controller-Objekt</h3>
          <ul>
            <li>
              Das Test-Controller-Objekt ist die zentrale API von TestCafe, um mit dem Browser zu
              interagieren
            </li>
            <li>Tests bekommen das Objekt automatisch als Parameter übergeben</li>
            <li>
              Außerhalb einer Test-Funktion kann das Objekt aus dem testcafe-Modul importiert
              werden: <code>import { t } from "testcafe"</code>
            </li>
            <li>
              Das Controller-Objekt kann den Browser steuern (z.B. <code>click</code>) oder auch
              Assertions ausführen (<code>expect</code>)
            </li>
            <li>
              Über das Controller-Objekt gibt es auch Zugriff auf native Browser-Elemente wie die
              Browser Console
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Selektoren</h3>

          <ul>
            <li class="fragment">
              Um mit einem Element auf einer Seite zu interagieren, muss ein Selektor geschrieben
              werden
            </li>
            <li class="fragment">
              Es gibt mehrere Arten von Selektoren, der klassische ist ein CSS-Selektor
            </li>
            <li class="fragment">
              In vielen Stellen der API kann entweder direkt ein Selektor als String geschrieben
              werden, oder es wird eine <code>Selector</code>-Instanz erzeugt:

              <pre><code class="javascript">
    const titleField = Selector("#titleField");
    const thirdArticle = Selector("article").nth(2);    
    const thirdArticle = Selector(".btn").withText("Save");    
  </code></pre>
            </li>
            <li class="fragment">
              Für React-Anwendung gibt es spezialisierte
              <a href="https://github.com/DevExpress/testcafe-react-selectors">React Selektoren</a>,
              die es erlauben, nach Komponenten zu suchen:
              <pre><code class="javascript">
                import { ReactSelector } from 'testcafe-react-selectors';
                            
                const buttons = ReactSelector('PostEditor Button');
                              </code></pre>
            </li>

            <li class="fragment">
              Damit kann dann auf Komponenten-Informationen zugegriffen werden, z.B. auf Properties
              und State einer Komponente
            </li>
            <li class="fragment">"Gefahr": testet man noch Black-Box? 🤔</li>
          </ul>
        </section>

        <section>
          <h3>Tests</h3>

          <ul>
            <li class="fragment">
              Auf dem Test-Controller ist die <code>expect</code>-Funktion definiert, die einen Wert
              nimmt und ein <code>Assertion</code>-Objekt zurückliefert
            </li>
            <li class="fragment">
              Auf dem <code>Assertion</code>-Objekt sind Prüf-Funktionen definiert, z.B.
              <code>eql</code>, <code>notEql</code>
              <pre class="fragment"><code class="javascript">
await t.expect(titleField.exists).ok();
await t.expect(titleField.value).eql("Hello World");
await t.expect("article".count).gt(3);              
            </code></pre>
            </li>
            <li class="fragment">
              Achtung! Die Selektoren werden erst ausgewertet, wenn sie verwendet werden, nicht bei
              ihrer Deklaration!

              <pre class="fragment"><code class="javascript">
// Hier wird der Selektor nur deklariert
const inputField = Selector("input").nth(2);

// Hier wird nun der Selektor ausgeführt
await t.expect(inputField.getAttribute("disabled")).notOk();
              </code></pre>
            </li>
            <li class="fragment">
              Aus diesem Grund muss auf die <code>expect</code>-Aufrufe mit
              <code>await</code> gewartet werden
            </li>
            <li class="fragment">
              Bei der Suche nach Elementen verwendet TestCafe "intelligente" Timeouts, um z.B. mit
              Asynchronität (Blog-Posts laden!) umzugehen
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Interaktion</h3>
          <ul>
            <li class="fragment">
              Auf dem Test-Controller sind Funktionen zur Interaktion mit Elementen definiert
            </li>
            <li class="fragment">
              Auch diese Funktionen erwarten einen Selektor, um ein Element eindeutig auszuwählen
            </li>
            <li class="fragment">
              Beispiel:

              <pre class="fragment"><code class="javascript">
                await t.typeText(titleField, "Learning Testcafe");
                await t.click(saveButton);
              </code></pre>
            </li>
            <li class="fragment">
              Diese Aufrufe können auch verkettet werden:

              <pre class="fragment"><code class="javascript">
    await t.typeText(titleField, "Learning Testcafe")
          .expect(saveButton.getAttribute("disabled").notOk()
          .click(saveButton);
</code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Selektoren mit testcafe-testing-library</h3>
          <p>Beispiel: steps/6-tests-with-material-ui/testcafe/app-test-rtl.ts</p>

          <ul>
            <li class="fragment">
              Die Query-Funktionen aus der dom-testing-library lassen sich mit dem Modul
              <a href="https://testing-library.com/docs/testcafe-testing-library/intro"
                >testcafe-testing-library</a
              >
              auch mit Testcafe nutzen!
            </li>
            <li class="fragment">
              Es werden nicht alle Query-Funktionen unterstützt, bzw. sie unterscheiden sich
              semantisch etwas vom Testen in JSDom (siehe Doku)
            </li>
            <li class="fragment">
              Damit kann man auch mit dem Material-UI-DOM gut z.B. über aria-Attribute suchen

              <pre class="fragment"><code class="javascript">
// Exakt derselbe Code wie beim Test mit react-testing-library!
const clearButton = screen.getByRole("button", { name: "Clear" });
const saveButton = screen.getByRole("button", { name: "Save Post" });

const titleField = screen.getByLabelText("Title");
const bodyField = screen.getByLabelText("Body");                


// Exakt derselbe Code aus dem Test-Cafe Beispiel (nur andere Selektoren...)
await t.typeText("#bodyField", "Lorem ipsum tralala");
await t.typeText(titleField, "Learning Testcafe");
await t.typeText(bodyField,  "Testcafe - Browser testing tool");

await t.expect(clearButton.hasAttribute("disabled")).notOk();
await t.expect(saveButton.hasAttribute("disabled")).notOk();
await t.click(saveButton);
              </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit TestCafe</h3>
          <p>
            Um die Entwicklung von Tests zu vereinfachen und Fehler zu finden, gibt es unter anderem
            folgende Features:
          </p>
          <ul>
            <li class="fragment">
              Bei einem fehlgeschlagenden Test kann TestCafe automatisch einen Screenshot erzeugen
              oder per API einen Screenshot erzeugen:

              <pre class="fragment"><code class="javascript">
  await t.typeText(titleField, "Hello")
    .screenshot()
    .click(saveButton);
</code></pre>
            </li>
            <li class="fragment">
              Man kann grundsätzlich Testcafe im Debug-Modus starten, oder per API an einer
              beliebigen Stelle den Debugger starten:

              <pre class="fragment"><code class="javascript">
await t.debug();                
              </code></pre>
            </li>
            <li class="fragment">
              Im Live-Modus bleibt der Test-Browser durchgehend gestartet, Tests werden automatisch
              bei Datei-Änderungen ausgeführt
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section id="t-state">
          <h1>Teil VIII</h1>
          <h2>Zustands-Management mit Context API, Redux und MobX</h2>
        </section>

        <section>
          <h2>Eine typische React-Anwendung in Komponenten</h2>
          <h3>Frage an Euch: was könnte es für Probleme geben?</h3>
          <img
            src="slides/images/typische-react-komponenten-hierarchie.png"
            style="height: 650px;"
          />
        </section>

        <section>
          <h3>Problem 1: Über Komponenten verteilter Zustand</h3>
          <img src="slides/images/verteilter-zustand.png" style="height: 650px;" />
          <p>Wo muss ich nach Fehlern suchen? Wo ist die Logik?</p>
        </section>

        <section>
          <h3>Problem 2: Getrennte Komponentenhierarchien</h3>
          <img src="slides/images/zwei-komponenten-hierarchien.png" style="height: 650px;" />
          <p>Geht entweder nicht oder "Gott-Komponente" entsteht</p>
        </section>

        <section>
          <h3>Problem 3: Gemeinsamer ("globaler") Zustand</h3>
          <img src="slides/images/gemeinsam-genutzter-state.png" style="height: 650px;" />
          <p>Wie kommt Zustand von ganz oben nach ganz unten?</p>
        </section>

        <section>
          <h3>Problem 4: UI und Logik vermischt</h3>
          <img src="slides/images/ui-und-logic-vermischt.png" style="height: 650px;" />
          <p>Wiederverwendung? React-unabhängigkeit? Testbarkeit?</p>
        </section>

        <section id="t-context">
          <h2>Context API</h2>
          <p>Beispiele:</p>
          <ul class="x-list">
            <li>Blog App mit Hooks: <code>blog-example/steps/30-complete-app-with-hooks</code></li>
            <li>
              Context API "Hello World" (Counter Example):
              <code>advanced/steps/4a-context-hello-world</code>
            </li>
          </ul>
        </section>

        <section>
          <h3>Context Api Live Introduction</h3>
          <p>(advanced/exercise/4_context)</p>
        </section>

        <section>
          <h2>Context...</h2>
          <p>
            <em
              >erlaubt das Durchreichen von Informationen ohne explizites angeben als Properties</em
            >
          </p>

          <ul>
            <li class="fragment">funktioniert nur innerhalb einer Hierarchie-Ebene</li>
            <li class="fragment">es können beliebg viele (fachliche) Context definiert werden</li>
            <li class="fragment">besteht aus <code>Provider</code> und <code>Consumer</code></li>
            <li class="fragment">
              <a href="https://reactjs.org/docs/context.html" target="_blank">Doku</a>
            </li>
          </ul>
        </section>

        <section>
          <h2>Context Factory</h2>
          <p>
            <em>erzeugt ein Objekt, mit <b>zwei Komponenten</b></em>
          </p>
          <ul>
            <li class="fragment">
              <code>Provider</code>, stellt Objekt mit Key-Value-Paaren zur Verfügung (der
              Context-"Value")
            </li>
            <li class="fragment">
              <code>Consumer</code> wird in eigener Komponente verwendet, um auf einen Context
              zuzugreifen ("versteckt" durch useContext Hook)
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      import react from "React";

                      const AuthContext = React.createContext();

                      // erzeugt:
                      // AuthContext.Provider 
                      // AuthContext.Consumer
                              </code></pre>
        </section>

        <section>
          <h2>Context Provider</h2>
          <p><em>Eine React-Komponente, die einen Context zur Verfüng stellt</em></p>
          <ul>
            <li class="fragment">
              wird innerhalb einer eigenen Komponente in <code>render</code> eingebunden
            </li>
            <li class="fragment">Nimmt ein Objekt ("Context") mit beliebigen Werten entgegen</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      const AuthContext = React.createContext();

                      function AuthProvider() {
                          const [ currentUser, setCurrentUser ] = React.useState(null);
                          const contextValue = {
                            // the current theme
                            currentUser,
                      
                            // function to set new theme
                            login: name => setCurrentUser(name),
                            logout: () => setCurrentUser(null)
                          };
                      
                          return &lt;AuthContext.Provider value={contextValue}>
                            {props.children}
                          &lt;/AuthContext.Provider>;
                        }
                      }                    
</code></pre>
        </section>

        <section>
          <h2>useContext-Hook</h2>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <p>
            In allen Komponenten unterhalb der Provider Komponente, kann mit useContext auf den
            Kontext zugegriffen werden
          </p>

          <pre class="fragment"><code class="javascript">
function UserBadge() {
  const { currentUser } = React.useContext(AuthContext);

  return currentUser  ? &lt;h1>Welcome, {currentUser}&lt;h1> : null;
}            
          </code></pre>

          <p class="fragment">Aufrufen einer Funktion aus dem Context</p>
          <p class="fragment">Ändert im Context den Zustand der Provider-Komponente</p>
          <p class="fragment">Alle Konsumer werden neu gerendert</p>
          <pre class="fragment"><code class="javascript">
function UserBadge() {
  const { currentUser, logout } = React.useContext(AuthContext);

  return currentUser  ? 
    &lt;>&lt;h1>Welcome, {currentUser}&lt;h1>&lt;button onClick={logut}>Logout&lt;/button>&lt;/> 
    : null;
}                
          </code></pre>
        </section>

        <section id="t-redux">
          <h2>Redux</h2>
          <h3>External Statemanagement</h3>
        </section>

        <section>
          <h3>Wiederholung</h3>
          <h2>Render Cycle in Pure React</h2>
          <img src="slides/images/redux-01-react-cycle-no-redux.png" style="height: 650px;" />
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px;" />
        </section>
        <section>
          <h2>Demo: Redux & Redux Devtools</h2>
          <a href="http://localhost:8080/" target="_blank">Ziel-Anwendung</a>
          <p>(npm start in code/schritte/redux/7-redux-complete-app)</p>
        </section>

        <section>
          <h2>Redux im Code</h2>
          <p>Hello World-Redux (PostEditor mit Redux)</p>
          <ul class="x-list">
            <li>Live Coding/Übung: <code>advanced/workspace-redux</code></li>
            <li>Lösung: <code>advanced/steps/5a-redux-hello-world</code></li>
          </ul>
        </section>

        <section>
          <h2>Strukturierter Überblick über alle Redux Teile</h2>
        </section>

        <section>
          <h3>Event-Handlers werden Action-Creators</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export function setFilter(filter) {
  return {
    type: SET_FILTER,
    filter
  };
}
</code></pre>
          <ul>
            <li class="fragment">Action-Creators erzeugen Action-Objekte</li>
            <li class="fragment">
              Actions sind Kommando-artige Strukturen von Dingen, die die Applikation tun soll
            </li>
            <li class="fragment">
              Über die dispatch-Methode des Stores werden sie an <em>alle</em> Reducer weiter
              gegeben
            </li>
            <li class="fragment">
              Actions bestehen aus einem Typen und einer beliebigen Nutzlast (payload)
            </li>
          </ul>
        </section>

        <section>
          <h3>Action-Creators machen Server-Calls</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const loadPost = postId => dispatch => {
fetch(BACKEND_URL+'/'+postId)
    .then(response => response.json())
    .then(post => dispatch({
        type: ADD_POST,
        post
    });
};
</code></pre>
          <ul>
            <li class="fragment">
              Die Action wird nicht direkt zurück geliefert, sondern erst später dispatched
            </li>
            <li class="fragment">
              wir bekommen die dispatch Methode als Parameter, mit der wir später die Action
              dispatchen
            </li>
          </ul>
          <p class="fragment">
            <strong
              >Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone
              Operationen ausführen dürfen</strong
            >
          </p>
        </section>

        <section>
          <h3>Ein <em>einziger</em> Store hält den <em>kompletten</em> Zustand</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import { rootReducer } from './reducers';

// http://redux.js.org/docs/api/createStore.html
const store = createStore(
rootReducer // reducer
);
ReactDOM.render(
&lt;Provider store={store}>
    &lt;App />
&lt;/Provider>,
mountNode
);
    </code></pre>
          <ul>
            <li class="fragment">Zentraler Teil der Anwendung</li>
            <li class="fragment">Liefert die bereits bekannte dispatch-Methode</li>
            <li class="fragment">
              Der Store wird allen Componenten über die Wrapper-Komponenten <em>Provider</em>
              zur Verfügung gestellt
            </li>
          </ul>
        </section>

        <section>
          <h3>Middleware zwischen Dispatch und Store</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
  rootReducer, // reducer
  applyMiddleware(thunk) // middleware as enhancer
);
    </code></pre>
          <ul>
            <li class="fragment">Die Thunk Middleware dient als de-facto-Standard</li>
            <li class="fragment">
              Gibt die dispatch-Methode and (asynchrone) Action Creators weiter
            </li>
            <li class="fragment">
              <a href="https://github.com/gaearon/redux-thunk#whats-a-thunk" target="_blank">
                'A thunk is a function that wraps an expression to delay its evaluation'
              </a>
            </li>
            <li class="fragment">
              Middleware ist ein fortgeschrittenes Feature und meistens genügt die Thunk Middleware
            </li>
          </ul>
        </section>

        <section>
          <h3>Reducers enthalten die Kern-(Business)-Logik</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import {combineReducers} from 'redux';

// http://redux.js.org/docs/api/combineReducers.html
export const rootReducer = combineReducers({
posts, // Blog Posts
auth   // Aktueller Benutzer
});
    </code></pre>
          <ul>
            <li class="fragment">
              Reducer sind pure Funktionen, die den alten Zustand und eine Action bekommen und einen
              neuen Zustand erzeugen
            </li>
            <li class="fragment">Oft bearbeitet ein Reducer nur einen Teil des Zustands</li>
          </ul>
        </section>

        <section>
          <h3>Teil-Reducer</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
const auth = (state = {}, action) => {
switch (action.type) {
    case "LOGIN":
        return { currentUser: action.username };
    case "LOGOUT":
        return {};
    default:
        return state;
  }
};
    </code></pre>
          <ul>
            <li class="fragment">
              Initialisiert seinen Teilzustand (oft mit einem Default-Parameter)
            </li>
            <li class="fragment">Ändert niemals zustand direkt</li>
            <li class="fragment">
              Sondern liefert einen neuen Zustand (manchmal teilweise als Kopie)
            </li>
          </ul>
        </section>

        <section>
          <h3>useSelector: Auf den globalen Zustand zugreifen</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { useSelector } from 'react-redux';

function App() {
  const currentUser = useSelector(state => state.auth.currentUser);
  ...
}
</code></pre>
        </section>
        <section>
          <h3>useDispatch: Actions auslösen</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
      import { useDispatch } from 'react-redux';
      
      import * as actions from './actions';
      
      function App() {
        const dispatch = useDispatch();

        async function login(newUser) {
          await dispatch(actions.login(newUser));
        }
        ...
      }
    </code></pre>
        </section>

        <section>
          <h2>Zusammenfassung Redux-Architektur</h2>
          <img
            src="slides/images/redux-03-resulting-redux-architecture.png"
            style="max-height: 650px;"
          />
        </section>
        <section>
          <h3>Redux Toolkit</h3>
          <em
            >"The official, opinionated, batteries-included toolset for efficient Redux
            development"</em
          >
          <ul>
            <li><a href="https://redux-toolkit.js">https://redux-toolkit.js.org/</a></li>
            <li>Pre-configured (including thunk and immer)</li>
            <li>Simplifies implementing action creators and reducers</li>
          </ul>
        </section>

        <section>
          <h3>Local state is still "allowed"!</h3>
          <p>There are a lot of places where you can hold state</p>
          <ul>
            <li class="fragment">Server and client</li>
            <li class="fragment">Component State</li>
            <li class="fragment">Redux</li>
            <li class="fragment">URL, Session or Local Storage</li>
          </ul>

          <img
            class="fragment"
            src="slides/images/three-kinds-of-state.png"
            style="max-height: 650px;"
          />
        </section>

        <section>
          <h3>Redux vs Context</h3>
          <p class="fragment">
            Redux hat Dev Tools, Time Travelling, Middlewares, globale Actions und Reducers/State
          </p>
          <p class="fragment">Redux ist sehr optimiert für Performance (häufige Updates)</p>
          <p class="fragment">Context von der API her einfacher (aber auch nicht so mächtig)</p>
          <p class="fragment">
            Redux lässt feingranularere Auswahl aus dem globalen Zustand zu (verhindert unnötige
            Renderings)
          </p>
        </section>

        <section>
          <h3>Redux vs Context</h3>
          <h3><em>Wie entscheiden wir uns?</em></h3>
          <p class="fragment">
            Entscheidung 1: Mischform: Redux <b>und</b> Context? Oder: Redux <b>oder</b> Context
          </p>
          <p class="fragment">Entscheidung 2: Was kommt wohin?</p>
          <p class="fragment">Auth-State (eingeloggter Benutzer)</p>
          <p class="fragment">Api-State: Netzwerk Request(s) laufen gerade</p>
          <p class="fragment">Draft-Post: editierters, neues, Post</p>
        </section>

        <section id="t-mobx">
          <h2>MobX</h2>
          <h3>External Statemanagement</h3>
        </section>

        <section>
          <h3>MobX</h3>
          <ul>
            <li class="fragment">
              <a href="https://mobx.js.org/README.html">https://mobx.js.org/README.html</a>
            </li>
            <li class="fragment">Claim: <b>Simple, scalable state management.</b></li>
            <li class="fragment">
              Aktuelle Version und Library für React:
              <a href="https://mobx.js.org/react-integration.html">mobx-react-lite</a>
            </li>
            <li class="fragment">
              Achtung #1: mobx-react braucht ihr nicht (wenn ihr Hooks API verwendet)
            </li>
            <li class="fragment">
              Achtung #2: Doku teilweise veraltet, die nicht direkt auf mobx.js.org liegt!
            </li>
            <li class="fragment">
              Basiert auf der Idee von "observable State", der von Euren Komponenten "observiert"
              wird
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>MobX Schritt-für-Schritt</h3>

          <p>Hands-On 👉 <code>advanced/exercices/7a-mobx</code></p>
          <p>Fertig 👉 <code>advanced/steps/7a-mobx</code></p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>MobX, Beispiel #1</h3>
          <ul>
            <li class="fragment">
              Der Zustand in MobX wird entweder in JavaScript-Objekten oder ES6-Klassen gehalten
            </li>
            <li class="fragment">
              Ihr könnt beides verwenden, ES6-Klassen weiter verbreitet und in der Doku auch
              empfohlen
            </li>
            <li class="fragment">Eine Klasse müsst ihr zum "Observer" machen</li>
          </ul>

          <pre class="fragment"><code class="javascript">
class BlogAppState = {
  blogPosts:Array&lt;BlogPost> = [];

  constructor() {
    // Diese Instanz "observieren", MobX verfolgt jetzt alle Änderungen
    makeAutoObservable(this);
  }
}        

// Unser globaler Zustand
const blogAppState = new blogAppState();  
        </code></pre>

          <ul>
            <li class="fragment">
              Eine Komponente kann zum Observer werden, und rendert sich dann bei allen Änderungen
              an der beobachteten Klasse:
            </li>
          </ul>
          <pre class="fragment"><code class="javascript">
const PostList = observer(function PostList() {
  return &lt;div>
    {blogAppState.blogPosts.map( p => /* wie gewohnt */ )}
  &lt;/div>  
})
        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>MobX: Actions</h3>
          <ul>
            <li class="fragment">
              Der Zustand in MobX wird über Actions verändert. Dabei handelt es sich um Methoden an
              einer Klasse.
            </li>
            <li class="fragment">
              Wenn der Zustand außerhalb einer Action verändert wird, gibt es einen Fehler. Auf
              diese Weise erzwingt MobX eine gewisse Architektur
            </li>
            <li class="fragment">
              Die Action-Methoden werden per Konvention von <code>makeAutoObservable</code> erkannt,
              oder ihr gebt sie explizit an
            </li>
            <li class="fragment">Das Laden von Daten könnte z.B. eine Action sein:</li>
          </ul>

          <pre class="fragment"><code class="javascript">
class BlogAppState = {
  blogPosts:Array&lt;BlogPost> = [];
            
  constructor() { makeAutoObservable(this); }

  async loadPosts() {
    const await response = fetch("...");
    const posts = await response.json();
    this.blogPosts = posts;
  }
}
          </code></pre>

          <pre class="fragment"><code class="javascript">
// Auslösen:
function App() {
  React.useEffect(  () => { blogState.loadPosts() }, []);

  // ...
}            
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Berechnete Werte: Computed Properties</h3>
          <ul>
            <li>
              MobX kann berechnete Werte cachen. Berechnete Werte basieren auf observierten Daten.
            </li>
            <li>
              Beispiel: Auf Basis der Blog-Post-Liste (beobachtet) und eines Sortierkriteriums
              (beobachtet) wird eine sortierte Blog-Post-Liste erzeugt. Die sortierte Liste ist ein
              "berechneter" Wert.
            </li>
            <li>
              Der Wert wird dann nur neuberechnet, wenn sich einer der darin verwendeten Werte
              ändert (Liste oder Kriterium).
            </li>
            <li>Ein Computed Property ist in der Regel eine getter-Methode an einer Klasse</li>
          </ul>
        </section>
        <section>
          <h3>Berechnete Werte #2</h3>
          <p>Beispiel</p>

          <pre class="fragment"><code class="javascript">
class BlogAppState = {
  blogPosts:Array&lt;BlogPost> = [];
  orderBy:string = "";
  currentUser: string = "";
            
  constructor() { makeAutoObservable(this); }

  get orderedPosts loadPosts() {
    const posts = [...blogPosts];
    posts.sort(orderBy); // vereinfacht

    return posts;
  }
}              
            </code></pre>

          <pre class="fragment"><code class="javascript">
blogAppState.orderedPosts; // Liste wird initial berechnet
blogAppState.orderedPosts; // Liste wird NICHT neu berechnet (Cache!)

blogAppState.orderBy = "date";              
blogAppState.orderedPosts; // Liste wird neu berechnet

blogAppState.currentUser = "Klaus";
blogAppState.orderedPosts; // Liste wird NICHT berechnet
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Observed Components</h3>

          <ul>
            <li class="fragment">
              Eine Komponente, die mit dem State arbeitet, muss ein Observer werden
            </li>
            <li class="fragment">
              Dazu wird sie der <code>observe</code>-Funktion übergeben, die eine eine observed
              Komponente zurückliefert
            </li>
            <li class="fragment">Das ist für den Aufrufer vollständig transparent</li>
            <li class="fragment">
              Die observed Komponente wird immer dann neu gerendert, wenn sich einer der Werte
              verändert, auf die sie zugreift
            </li>
            <li class="fragment">
              Die observed Komponente rendert sich daher auch nicht neu, wenn ihre Parent-Komponente
              sich neu rendert
            </li>
            <li class="fragment">Ausnahme: die Parent-Kompoenten übergibt veränderte Properties</li>
          </ul>
          <pre class="fragment"><code class="javascript">
            const PostList = observer(function PostList() {
              return &lt;div>
                {blogAppState.blogPosts.map( p => /* wie gewohnt */ )}
              &lt;/div>  
            })  
          </code></pre>
        </section>

        <section>
          <h3>Bereitstellen des Zustands</h3>

          <ul>
            <li>MobX ist es egal, wo der Zustand herkommt; es ist ein beliebiges Observable</li>
            <li>
              Typischerweise wird der Zustand in React-Anwendungen über genau einen Context in die
              Anwendung gereicht
            </li>
            <li>
              Das Context-Objekt wird sich nie ändern, da sich nur die Werte in der Klasse
              verändern.
            </li>
            <li>
              Deswegen wird eine konsumierende Komponente auch nie neu gerendert, weil sich der
              Context nicht ändert
            </li>
            <li>
              Deswegen muss die Komponente ein Observer sein; wenn sich ein Wert aus dem Context
              ändert, rendert MobX neu
            </li>
          </ul>
        </section>
        <section>
          <h3>Bereitstellen des Zustands - Beispiel</h3>

          <pre class="fragment"><code class="javascript">
const context = {
  blog: new BlogAppState(),
  auth: new AuthenticationState()
}
function StoreProvider({ children }) {
  return (
    &lt;StoreContext.Provider value={context}>
      {children}
    &lt;/StoreContext.Provider>
  );
}

export function useStore() {
  return React.useContext(StoreContext);
}
          </code></pre>

          <pre class="fragment"><code class="javascript">
const PostList = observe(function PostList() {
  const { blog } = useStore();

  // PostList wird nur neu gerendert, wenn sich BlogPost-Liste ändert
  return blog.posts.map(&lt;BlogPost id={...});
})           
          </code></pre>
        </section>

        <section>
          <h3>MobX vs. Redux</h3>

          <ul>
            <li class="fragment">Redux eher funktionale Programmierung, MobX eher OO</li>
            <li class="fragment">Viel Freiheiten mit MobX...</li>
            <li class="fragment">...aber auch viel "Magie"</li>
            <li class="fragment">
              In großen Modellen manchmal schwer zu verstehen, was eigentlich wo und wie "observed"
              wird
            </li>
            <li class="fragment">Observer-Komponenten eher untypisch für React (noch)</li>
            <li class="fragment">Developer Tooling nicht so gut wie Redux</li>
            <li class="fragment">Doku, StackOverflow etc. deutlich weniger umfänglich als Redux</li>
            <li class="fragment">👉 Beide Bibliotheken gute Wahl und können verwendet werden</li>
            <li class="fragment">👉 "Für Redux ist noch niemand entlassen worden"</li>
          </ul>
        </section>

        <section>
          <h2>Geschafft! 😊</h2>
          <h3>Vielen Dank für Eure Teilnahme!</h3>
          <h3>Viel Spaß und Erfolg mit React!</h3>
          <p>
            Wenn ihr noch Fragen habt, könnt ihr mich erreichen:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
  </body>
</html>
