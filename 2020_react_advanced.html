<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>Advanced React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem;">
            <b>Advanced React Training</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem;"></p>

          <p>
            <span class="transparent-bg">Slides: react-training/2020_react_advanced.html </span>
          </p>
          <p>or</p>
          <p>
            <span class="transparent-bg">
              <a href="https://nilshartmann.github.io/react-training/2020_react_advanced.html"
                >https://nilshartmann.github.io/react-training/2020_react_advanced.html</a
              ></span
            >
          </p>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freelance software developer, trainer and coach from Hamburg </em></p>

          <div style="display: flex; justify-content: center;">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
            </div>
          </div>
        </section>

        <section>
          <h2>Agenda</h2>
          <ul style="font-size: 85%;">
            <li>
              <a href="#/t1">Intro: React Basics</a> and <a href="#/t-typescript">TypeScript</a>
            </li>

            <li style="margin-top: 30px;">
              <a href="#/t-test">Part I: Testing React Applications</a>
            </li>

            <li>
              <a href="#/t-pattern"
                >Part II: Pattern (HOCs, Render Properties, Custom Hooks, Dumb and Presentation
                Components)</a
              >
            </li>

            <li>
              <a href="#/t-router">Part III: Client-side Routing with React Router (Overview)</a>
            </li>

            <li>
              <a href="#/t-state">Teil IV: Statemanagement:</a> React
              <a href="#/t-context">Context</a> and <a href="#/t-redux">Redux</a>
            </li>

            <li style="margin-top: 30px;">
              <a href="#/t-graphql">Teil V: GraphQL</a>
            </li>

            <li style="margin-top: 30px;">
              <a href="#/t-memo">Teil VI: Memoization, Performance</a>
            </li>
          </ul>
          <div style="font-size: 80%;">
            <p><b>Every time:</b> Questions and discussions!</p>
          </div>
        </section>

        <section id="t1">
          <h1>Intro: React Basics</h1>
        </section>

        <section>
          <h2>React</h2>
          <ul>
            <li class="fragment">Minimal API</li>
            <li class="fragment">
              Minimal feature set
              <ul>
                <li>You can/have to make many decisions yourself</li>
              </ul>
            </li>

            <li class="fragment">Violates many Best-Practices</li>
          </ul>
        </section>

        <section>
          <h3>Components in React</h3>
          <p>
            <em>Main concept of React: <b>Components</b></em>
          </p>
          <img style="height: 800px;" class="fragment" src="slides/images/soc_en.png" />
        </section>

        <section>
          <h3>Components in React</h3>
          <p>What do we have for components in our Blog Application?</p>
          <img src="blog-example/blog-example.png" style="height: 650px;" />
        </section>

        <section>
          <h3>React Components</h3>
          <img src="slides/images/komponente.png" style="height: 400px;" />
          <ul>
            <li class="fragment">contain <b>State, Logic und UI</b></li>
            <li class="fragment">
              <b>no template language</b>
            </li>
            <li class="fragment">written in a <b>declarative</b> way</li>
            <li class="fragment">
              will always be <b>completely re-rendered</b> on data change (no 2-way-data-binding)
            </li>
            <li class="fragment">getting aggregated to <b>complete applications</b></li>
          </ul>
        </section>

        <section>
          <h3>React Components</h3>
          <ul>
            <li class="fragment">
              Components are written either as <b>JS functions with "Hooks"</b> or as
              <b>ES6 classes</b>
              <ul>
                <li>
                  Hooks is newer React API (since Version 16.8, February 2019) an "future of React"
                </li>
                <li>Classes still widespread in existing code, documentation, tutorials etc</li>
              </ul>
            </li>

            <li class="fragment">
              No Template Language
              <ul>
                <li>We write our UI completely in JavaScript</li>
                <li>
                  React provides a language add-on for JavaScript allowing you to write HTML-like in
                  JS (called JSX)
                </li>
                <li>(Isn't that a template language?)</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>Our first component: Hello, World!</h3>
          <ul>
            <li>Example Step-by-Step (<code>blog-example/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>PostEditor.js</code>
          <pre><code data-trim contenteditable>
  import React from "react";

  export default function PostEditor(props) {
    const [title, setTitle] = React.useState("");

    return (
      &lt;div>
        &lt;label>
          Title
          &lt;input onChange={event => setTitle(event.target.value)} value={title} />
        &lt;/label>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Embedding your Application</h3>
          <div class="fragment">
            <p>
              <code>index.html</code>
            </p>
            <pre><code data-trim contenteditable>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div class="fragment">
            <p>
              <code>index.js</code>
            </p>
            <pre><code data-trim contenteditable class="javascript">
  import React from 'react';
  import ReactDOM from 'react-dom';

  import PostEditor from './PostEditor';

  ReactDOM.render(&lt;PostEditor />,
    document.getElementById('root')
  );
  </code></pre>
          </div>
        </section>

        <section data-state="js-exkurs">
          <h2>React Devtools</h2>
          <em>React Developer Tools for Chrome and Firefox</em>
          <p>Inspect your React Application at Runtime</p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>

        <section data-state="js-exkurs">
          <h3>create-react-app</h3>
          <a
            href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents"
            target="_blank"
            >User Guide</a
          >
          <p>Can be used to create new React projects</p>
          <p>
            Contains complete configuration of all needed tools like Webpack, Babel, TypeScript, ...
          </p>
          <p>Re-builds the applications when code changes and updates the browser</p>
          <p>Example: npx create-react-app NAME_OF_YOUR_PROJECT --template typescript</p>
        </section>

        <section data-state="js-exkurs">
          <h2>Webpack and Babel</h2>
          <img src="slides/images/webpack-und-babel.png" style="height: 600px;" />
        </section>

        <section data-state="js-exkurs">
          <h2>Some hints for VS code</h2>
          <ul>
            <li>Don't set your font size too small (use Ctrl-+ and Ctrl-- to ajdust).</li>
            <li>
              Don't rely to much on code completion as we're writing JavaScript code.<br />
              VS Code tries to help you sometimes the hints are more confusing than helpful.<br />
              When we switch to TypeScript it will become better
            </li>
          </ul>
        </section>

        <section>
          <h3>The Example Project</h3>
          <p>Workspace</p>
          <ul class="x-list">
            <li style="margin-bottom: 40px;">
              <code>2020_react_advanced.html</code>: This slides (root folder)
            </li>
            <li class="fragment" style="margin-bottom: 40px;">
              All Code we need is inside the <code><b>blog-example</b></code> subfolder
            </li>

            <li class="fragment" style="margin-bottom: 40px;">
              <code>blog-example/<b>workspace</b></code
              >: Folder for your exercises <br />👉&nbsp;<b>Recommandation</b>: only open this file
              in VS Code (or your IDE)
            </li>
            <li class="fragment">
              <code>blog-example/<b>material</b></code
              >: Code for some of the exercises
            </li>
            <li class="fragment">
              <code>blog-example/<b>steps</b></code
              >: Final source code after each excersise
            </li>
          </ul>
        </section>
        <section>
          <h2>Exercise #1: Hello-World</h2>
          <h3>
            <em>Get familiar with the tools and write your first React component</em>
          </h3>
        </section>
        <section>
          <h3>Step #1: Start the tool chain (if not already running)</h3>

          <ol class="fragment" style="font-size: 85%;">
            <li>
              <code>cd blog-example/workspace</code>
            </li>
            <li class="fragment">
              <code>npm install</code>
            </li>

            <li class="fragment">
              <code>npm start</code>
            </li>

            <li class="fragment">
              Your browser should be opened automatically at
              <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>
            </li>

            <li class="fragment">If you see "Hello, World", everything is fine!</li>
          </ol>
        </section>
        <section>
          <h3>Step #2: Your first React component</h3>
          <em>Build the first mini step of your PostEditor component</em>
          <ul>
            <li class="fragment">
              Replace the "static" component in <code>PostEditor.js</code> with the React Code from
              the previous slides.
            </li>
            <li class="fragment">The Component should be called <b>PostEditor</b></li>
            <li class="fragment">
              It should have a state (<code>title</code>) and an input field for that state
            </li>
            <li class="fragment">
              The state should be initialized with a value from the components
              <em>properties</em> (<code>initialTitle</code>)
            </li>
            <li class="fragment">
              <em>Optional: do some experiments with the component, change things like:</em>
              <ul>
                <li>
                  What do you do if the <code>initialTitle</code> property has not been set by the
                  caller of the component?
                </li>
                <li>The text entered should be displayed in uppercase only</li>
                <li>If the text field is empty a message should be displayed</li>
              </ul>
            </li>
          </ul>
        </section>

        <section id="t2">
          <h1>React Components</h1>
        </section>

        <section>
          <h2>React Documentation</h2>
          <p>
            <a href="https://reactjs.org/docs/hello-world.html">
              https://reactjs.org/docs/hello-world.html
            </a>
          </p>
        </section>

        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%;" class="fragment">
              Written like HTML code, incl. attributes:
              <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              Attention! <code>class</code>-attribute is called <code>className</code>:
              <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              Attributes, that are not string, have to be surrounded by {}:
              <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              You can use pure javascript expressions in {}:
              <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
            </li>

            <li style="font-size: 80%;" class="fragment">
              CSS styles are specified using an object (with keys in Camel-Case-Notation):
              <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%;" class="fragment">
              Fragments (A Fragment does not render something, only it's children):
              <pre><code class="xml" contenteditable data-trim>
function Choice() {
  return &lt;&gt;
    &lt;li>Yes&lt;/li>
    &lt;li>No&lt;/li>
  &lt;/>
}
                    </code></pre>
            </li>
            <li style="font-size: 80%;" class="fragment">
              Use null, false or any boolean, to not render anything:
              <pre><code class="xml" contenteditable data-trim>
function ErrorMessage(props) {
  if (!props.msg) {
    return null; // or false or true
  }

  return <h1>Error: {props.msg}</h1>;
}
                    </code></pre>
            </li>

            <li style="font-size: 80%;" class="fragment">
              Comments in JSX
              <pre><code class="xml" contenteditable data-trim>
  function MyComponent() {
    return <div>
      { /* this ist javascript, and block comments are allowed here */ }
    </div>;
  }
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>React: Components</h3>
          <em>Your own components have with a capital letter!</em>
          <ul>
            <li>Component name is the name of the component function</li>
            <li>
              native HTML Components (button, div, input, ...) always start with a lowercase letter
            </li>
          </ul>
        </section>

        <section>
          <h3>Components as functions</h3>
          <ul>
            <li class="fragment">Name of the function is the name of the component</li>
            <li class="fragment">Properties are passed as first parameter (as object)</li>
            <li class="fragment">
              The function must return <b>one</b> root element, null, false/true, string or array
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties and State</h3>
          <ul class="fragment">
            <li>
              <b>Properties</b> are passed into the components from the <b>outside</b>, from the
              caller of the component. Properties <b>must not be changed</b> by the component.
            </li>
            <li class="fragment">
              <b>State</b> is an <b>internal</b> property of a component. State
              <b>might be changed</b> only by the component iself.
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") of a component</h3>

          <ul>
            <li class="fragment">
              ...are JavaScript objects (key-value-pairs)
            </li>
            <li class="fragment">
              ...are the first argument of a component function
            </li>
            <li class="fragment">must not be changed by the receiving component</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function Header(props) {
                return (
                  &lt;h1 style={{color: props.titleColor}}>{props.title}&lt;/h1>
                );
              }
            }
            </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// You can use destructuring for better (?) readabilty:
function Header({titleColor, title}) {
    return (
      &lt;h1 style={{color: titleColor}}>{title}&lt;/h1>
    );
  }
}
                </code></pre>
        </section>

        <section>
          <h3>State of a component: useState-Hook</h3>
          <ul>
            <li>
              Example: Contents of a text field, data from server, is a menu expanded or collapsed
            </li>
            <li class="fragment">
              <b>Values</b> normally immutable. (in many cases we have primitive data types as
              values, so state is automatically immutable)
            </li>
            <li class="fragment">Working with state using the <b>useState</b>-Hook</li>
            <li class="fragment">
              useState returns an array with two entries: 1. the state's current value, 2. a
              setter-function used to change the state
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function HelloWorld(props) {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
          <ul>
            <li class="fragment">
              Calling the setter function <b>forces re-rendering the <i>whole</i> component</b> (and
              all children!)
            </li>
            <li class="fragment">
              You can use multiple independent states, by calling using multiple useState calls
            </li>
            <li class="fragment">
              <b>State</b>, its behaviour and organization is one of the <b>fundamental</b> concepts
              of React
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em
            >Hooks are JS functions that let you "hook into" the lifecycle of a React component
          </em>
          <ul>
            <li class="fragment">
              Hooks are "normal" JS functions, but must start with <code>use</code> (useState,
              useEffect, ...)
            </li>
            <li class="fragment">
              Example: Importing and using Hooks

              <pre><code class="javascript" contenteditable data-trim>
// default import only
import React from "react";
function HelloWorld(props) {
  const [title, setTitle] = React.useState("");
  // ...
}
                                  </code></pre>
              <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Default and named import
import React, { useState } from "react";

function HelloWorld(props) {
  const [title, setTitle] = useState("");
  // ...
}
                                                        </code></pre>

              <ul>
                <li class="fragment">
                  (Note! <code>React</code> has to be always <b>imported</b> when you use JSX in
                  your source code!)
                </li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>You have to follow some rules when using Hooks 👆</em>
          <p style="font-size: 75%; margin-top: 0;">
            <a href="https://reactjs.org/docs/hooks-rules.html"
              >(https://reactjs.org/docs/hooks-rules.html)</a
            >
          </p>
          <div class="fragment">
            <p>Restrictions:</p>
            <ul>
              <li class="fragment">
                Hooks can only be used in functional components and other Hook functions. They
                cannot be used in React Class Components.
              </li>
              <li class="fragment">
                Inside a component, Hooks must be used always in the same order across render cycles
                and only on top-level (examples following soon).
                <ul>
                  <li>Hooks are not allowed in loops, if-statements or other functions/closures</li>
                </ul>
              </li>
              <li class="fragment">
                There is a
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                that ensures correct usage of hooks (automatically configured in create-react-app
                projects)
              </li>
            </ul>
          </div>
          <p class="fragment">
            <em
              >Internally React remembers the <b>order</b> of the invoked hook functions of a
              component to assign their correct values on later re-renderings!</em
            >
            >
          </p>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Examples of correct and incorrect usage</em>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// ALLOWED:
function HelloWorld(props) {
  const [greeting, setGreeting] = React.useState("");
  const [name, setName] = React.useState("");
  // ...
}
                                </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// ALLOWED:
function HelloWorld(props) {
  const [greeting, setGreeting] = React.useState(props.initialGreeting);
  const uppercaseGreeting = greeting.toUpperCase();
  const [name, setName] = React.useState(props.initialName);
  // ...
}
                                                      </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// FORBIDDEN:
function HelloWorld(props) {
  const [greeting, setGreeting] = React.useState("");
  if (greeting !== null) {
    const [name, setName] = React.useState("");
  }
  // ...
}
                                                      </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// FORBIDDEN:
function HelloWorld(props) {
  if (props.currentUser === null) {
    return &lt;h1>Please login first&lt/h1>
  }
  const [greeting, setGreeting] = React.useState(props.initialGreeting);
  return &lt;input value={greeting} ... />
}
                                            </code></pre>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Examples of correct and incorrect usage</em>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              // FORBIDDEN
              function HelloWorld(props) {
                function initState() {
                  return React.useState(props.initialGreeting);
                }
                const [greeting, setGreeting] = initState();
              }
            </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                // FORBIDDEN (initState is a 'normal' function,
                //  should be useInitState instead)
                function initState() {
                  return React.useState(props.initialGreeting);
                }

                function HelloWorld(props) {
                  const [greeting, setGreeting] = initState();
                }
              </code></pre>
        </section>

        <section>
          <h3>useState: Details</h3>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                  function PostEditor(props) {

                    // ASSUMPTION: This component will be rendered two times
                    // (because setTitle has been called)
                    //
                    // QUESTION: - how many times will useState be called?
                    //           - what happens with 'initialValue' ("My Post")
                    const [title, setTitle] = React.useState("My Post");
                  }
                </code></pre>
        </section>

        <section>
          <h3>useState: Details II</h3>

          <ul>
            <li>
              <code>initialValue</code> can be initialized lazy using a function instead of a
              constant:
              <pre class="fragment"><code class="javascript" contenteditable data-trim>
                        function PostEditor(props) {
                          const [title, setTitle] = React.useState(() => determineInitialTitle());
                        }
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Render Cycle</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section>

        <section>
          <h3>Virtual DOM</h3>
          <p>"Rendering" has two meanings!</p>
          <img src="slides/images/vdom.png" style="height: 650px;" />
        </section>
        <section>
          <h3>References to native DOM</h3>
          <p>
            If we only use <em>virtual</em> dom in our components, how can we interact with the
            <em>native</em> dom?
          </p>
          <p>Example: calling <code>focus()</code> on an element?</p>

          <p>👉 Let's look into our code (Live Coding)</p>
        </section>
        <section>
          <h3>References to native DOM</h3>

          <p><em>useRef-Hook</em></p>
          <ul>
            <li class="fragment">
              <code>React.useRef() </code> creates a generic "reference object"
            </li>
            <li class="fragment">
              The object returned lives across all rendere cycles
            </li>
            <li class="fragment">
              This references can be attached to a React Element. React will then set the reference
              to the native HTML element into the reference object.
            </li>
            <li class="fragment">
              Using the <code>current</code>-Property on the reference object you get access to the
              native element after it has been rendered
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function PostEditor(props) {
  const [title, setTitle] = React.useState("");
  const [body, setBody] = React.useState("");

  const titleInputRef = React.useRef();

  function clear() {
    setTitle("");
    setBody("")
    titleInputRef.current.focus();
  }

  return &lt;>
    &lt;input ref={titleInputRef} value="..." onChange="..." />
    &lt;button onClick={clear}>Clear&lt;button/>
  &lt;/>
}
</code></pre>
        </section>

        <section>
          <h2>Excercise 2: Post-Editor for our Application</h2>
          <em><b>Enhance your component with new features</b></em>
        </section>
        <section>
          <h3>Steps</h3>
          <h4>Enhance your existing component from the last exercise</h4>
          <ol class="x-list">
            <li>In addition to "title", you need another input field, called <code>body</code>.</li>
            <li>
              Add a "clear"-Button, that clears both input fields. The property for the event on the
              button is called <code>onClick</code>.
              <ul>
                <li>
                  The "clear"-Button should be disabled as long as one of the input fields is empty.
                  To disable a button element, you can set it's <code>disabled</code> property to
                  <code>true</code>.
                </li>
                <li>
                  After the button has been pressed and the input has been cleared, transfer the
                  focus to the first input field (<code>title</code>)
                </li>
              </ul>
            </li>
          </ol>
        </section>

        <section id="t3">
          <h1>Part III</h1>
          <h2>React: Hierarchies and Applications</h2>
          <code>blog-example/steps/3-hierarchy</code>
        </section>

        <section>
          <h3>Lists</h3>
          <p>JSX has no explicit support for lists</p>
          <p>
            In most cases,
            <code>Array.map()</code> is used to map a list of objects to a list of JSX elements
          </p>
          <p>Each element in a list needs a <em>list-wide unique key</em></p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
const posts = [
  { id: 0, title: 'Hello World', body: 'Lorem ipsum' },
  { id: 1, title: 'React in a Nutshell', body: 'Lets get started with React' }
];

function PostList(props) {
  return {props.posts.map(post => (
    &lt;div key={post.id}>
        &lt;h1>{post.title}&lt;/h1>
        &lt;p>{post.body}&lt;/p>
    &lt;/div>
  )}
}
</code></pre>
        </section>

        <section>
          <h2>Component hierarchies</h2>
        </section>

        <section>
          <h3>👉 Let's enhance our application with a new view: Blog-List</h3>
        </section>

        <section>
          <h3>How does our application communicate?</h3>
          <p>Our application has two views: Blog-List and Editor.</p>
          <p>Which one should be visible?</p>
          <p>How does data flow from the one view to the other?</p>
        </section>

        <section>
          <h3>Data flow in React application</h3>
          <ol>
            <li>
              In React applications, components are composed in hierarchies to become applications
              (an application is just a bunch of components)
            </li>
            <li class="fragment">
              Inside the hierarchy communication is always in one direction only:
              <b>Parent</b> components pass down <b>properties</b> to their <b>children</b>
            </li>
            <li class="fragment">
              Using the properties data (blog post, currently logged in user, ...) can be passed
              from "top" to "bottom". This can be done across more than one level in the hierarchy.
              <p>
                (A component can pass all or parts of the properties it receives itself to its
                children)
              </p>
            </li>
            <li class="fragment">
              Using properties, <b>callback functions</b> can also be passed down
            </li>
            <li class="fragment">
              A child component can invoke this function to send and event (with or without) data to
              their parent component <br />We have seen this already with the onChange property on
              the input-field)
            </li>
          </ol>
        </section>

        <section>
          <h3>Smart and Dumb-Components #1</h3>

          <p>
            Reminder: in React we build components. Components consist of logic, state and UI
            (HTML-Elements and Styling)
          </p>
          <p class="fragment">
            In a well-known pattern components are spilt into "smart" (or "controller") and "dumb"
            (or "presentation") components.
          </p>
          <p class="fragment">
            Technically both components are identical, both are regular React components
          </p>
          <p class="fragment">
            Only their <b>intended purpose</b> or role is defined differently...
          </p>
        </section>

        <section>
          <h3>Smart and Dumb components #2</h3>
          <p><b>Smart components</b> contain logic and state, but (almost) no UI</p>
          <p><b>Dumb components</b> only present/render the data</p>
          <ol>
            <li class="fragment">
              Smart components <b>manage the state</b> and pass it into Dumb components. Dump
              components <b>render the state</b>.
            </li>
            <li class="fragment">
              Smart components pass callback functions as Event-Handler into the dumb components.
            </li>
            <li class="fragment">
              When an event occures inside a dumb component, (for ex. button click or text input)
              the dumb components invokes the callback function.
            </li>
            <li class="fragment">
              The callback function is executed inside the context of the smart component (normal
              closure behaviour) and thus can acess state etc from the smart component.
            </li>
            <li class="fragment">
              Inside the event handler, state of the smart component can be changed. Chaning the
              state leads to re-rendering of the smart component and all of its children (dumb)
              components.
              <br /><b>The app state remains consistent across all components in the hierarchy</b>
            </li>
          </ol>
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application

    <img src='slides/images/smart-dumb-1.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application

    <img src='slides/images/smart-dumb-2.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application

    <img src='slides/images/smart-dumb-3.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application

    <img src='slides/images/datenfluss-4.png' height="550">

    Strict data- and control flow
                      </textarea
          >
        </section>

        <section>
          <h3>Example</h3>

          <p>
            Our <b>smart component</b> holds a list of Blog Posts and deceides, which view is active
            (Editor or List) ist
          </p>
          <p>
            The smart components passes the list of blog posts to the BlogList component for
            rendering
          </p>
          <p>
            The smart components passed a callback function to BlogList and AddForm to get informed
            about events/data changes
          </p>

          <pre><code>
function App() {
  const [posts, setPosts] = React.useState([]);
  const [view, setView] = React.useState("list");

  function addPost(newPost) {
    // Add the new post to the state
    setPosts([...posts, newPost]);

    // switch back to list view
    setView("list");
  }

  if (view === "list") {
    return &lt;BlogList posts={posts} onAdd={() => setView("addForm")} />
  }

  return &lt;AddForm onAdd={addPost} />

}
</code></pre>
        </section>

        <section>
          <h3>Example #2</h3>

          <p>
            The BlogList is responsible for rendering the list of posts only. If the add button gets
            pressed, the component invokes the callback function (received from the App component).
          </p>
          <p>The callback function changes the App state to make the Post Editor visible</p>

          <pre><code>
  function BlogList(props) {

    return &lt;div>
      // ... render the blog post list ...
      &lt;button onClick={props.onAdd}>Add Blog Post&lt;/button>
    &lt;/div>;
  }
  </code></pre>
        </section>

        <section>
          <h3>Example #3</h3>

          <p>
            The AddForm component passes the new blog post (its internal state) to the callback
            function, that it has received from the App component.
          </p>
          <pre><code>
  function AddForm(props) {
    const [title, setTitle] = React.useState("");
    const [body, setBody] = React.useState("");

    function addPost() {
      const newPost = {
        title, body
      }

      // Inform the App component about the new blog post
      props.onAdd(newPost);
    }

    return &lt;div>
      // ... Render form ...
      &lt;button onClick={addPost}>Save Post&lt;/button>
    &lt;/div>;
  }
  </code></pre>
        </section>

        <section>
          <h2>Excercise #3: Build a complete "application"</h2>
          <p>
            <em>
              Integrate your existing <code>PostEditor</code> and a new
              <code>PostList</code> component with the <code>App</code> component</em
            >
          </p>
        </section>
        <section>
          <h3>Steps</h3>
          <ol>
            <li>
              copy the material from <code>blog-example/material/3-hierarchy/src</code> in your src
              folder
              <span style="font-size: 85%;"
                >(you can use your own <code>PostEditor</code> or use the one from
                material/3-hierarchy)</span
              >
            </li>

            <li>
              Enhance the <code>App</code> component, so that is displays the
              <code>PostEditor</code> if the user klicks the <code>Add</code> Button.
              <p>- In <code>App.js</code> there is a TODO comment with further information</p>
            </li>
            <li>
              In your <code>PostEditor</code> you need a Save button, that inkoves the callback
              function, that <code>App</code> passed to it via properties (<code>onSave</code>).
              <br />See todo in
              <code>blog-example/material/3-hierarchy/src/PostEditor.js</code>
            </li>
            <li style="font-size: 75%;">
              <b>Optional:</b> Add a <b>new</b> Button "Cancel" to your PostEditor, that only opens
              again the PostList (but does not save the values in PostEditor)
            </li>
          </ol>
        </section>

        <!-- ANFANG KLASSEN -->
        <section>
          <h2>React: Componets as ES6 classes</h2>
          <ul>
            <li class="fragment">
              Example without Error Boundary: <code>?with-error-handler</code>:
              blog-example/steps/3a-hierarchy-errorhandler
            </li>
            <li class="fragment">
              Example with Error Boundary (development):
              blog-example/steps/3a-hierarchy-errorhandler
            </li>
            <li class="fragment">
              Example with Error Boundary (prod):
              blog-example/steps/3a-hierarchy-errorhandler/build/
            </li>
          </ul>
        </section>

        <section>
          <h3>Error Boundaries</h3>
          <em
            >When React renders a component and during rendering an error occures, the
            <b>whole applications</b> is removed from the DOM by React</em
          >
          <p class="fragment">Error Boundaries are like <b>try-catch</b> but for components</p>
          <ul>
            <li class="fragment">
              ...add them somewhere in your hierarchy, all errors underneath in your hierarchy are
              caught
            </li>
            <li class="fragment">...in case of an error you can show a message to your users</li>
            <li class="fragment">...are regular React components, but</li>
            <li class="fragment">...have to be implementes as ES6 class components</li>
          </ul>
        </section>

        <section>
          <h3>Components as classes</h3>

          <p>Instead of <b>useState</b>: use this.state and this.setState()</p>
          <p>Properties are available as instance variable <code>this.props</code></p>

          <pre><code data-trim contenteditable>
      import React from "react";

      export default class PostEditor extends React.Component {

        constructor(props) {
          super(props);

          this.state = {
            title: props.initialTitle,
            body: props.initialBody
          };
        }

        render() {
          return (
            &lt;div>
              &lt;input
                value={this.state.title}
                onChange=
                  {event => this.setState({title: event.target.value})}
              />
              &lt;input
                    value={this.state.body}
                    onChange=
                      {event => this.setState({body: event.target.value})}
              />
            &lt;/div>
          );
        }
      }</code></pre>
        </section>

        <section>
          <h3>React: Rendering</h3>
          <span class="fragment">
            <p>
              <em>Every React component class needs a <code>render</code>-method:</em>
            </p>

            <ul>
              <li>is run on first rendering and after each state change</li>
            </ul>
          </span>
        </section>

        <section>
          <h3>Properties of a component</h3>
          <ul class="fragment">
            <li>Properties are passed via the constructor</li>
            <li>
              Access properties with
              <code>this.props</code>
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              class Header extends React.Component {
                constructor(props) {
                  super(props);
                }

                render() {
                  return (
                    &lt;h1 style={{color: this.props.titleColor}}>{this.props.title}&lt;/h1>
                  );
                }
              }
              </code></pre>

          <ul class="fragment">
            <li>Remember: component as function</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                    function Header(props) {
                        return (
                          &lt;h1 style={{color: this.props.titleColor}}>{this.props.title}&lt;/h1>
                        )
                    }
                    </code></pre>
        </section>

        <section>
          <h3>State of a class component</h3>
          <ul>
            <li class="fragment">
              <b>Initialize</b> in constructor using <code>this.state={}</code>
            </li>
            <li class="fragment"><b>Read</b> state with <code>this.state</code></li>
            <li class="fragment">
              <b>Set</b> state using
              <code>this.setState()</code>
              <ul class="fragment">
                <li><b>Attention:</b> no "real" setter</li>
                <li class="fragment">Merges old and new state (differs from useState)</li>
                <li class="fragment">Runs asynchron</li>
                <li class="fragment">
                  <b>Leads to re-rending of the <i>whole</i> component (as with useState)</b>
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Example: Error Boundary</h3>
          <p class="fragment">
            <b>getDerivedStateFromError</b> and <b>componentDidCatch</b> are invoked by React in
            case of an error
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              class ErrorHandler extends React.Component {
                constructor(props) {
                  super(props);
                  this.state = { error: null };
                }

                static getDerivedStateFromError(error) {
                  return { error: error.toString() };
                }

                componentDidCatch(error, info) {
                  console.error("uups... we caught an error", error, info);
                }

                render() {
                  if (this.state.error) {
                    return (
                      &lt;div>
                        &lt;h1>An error occured!&lt;/h1>
                        &lt;pre>{this.state.error}&lt;/pre>
                        &lt;button onClick={() => this.setState({ error: null })}>Try again&lt;/button>
                      &lt;/div>
                    );
                  }
                  return this.props.children;
                }
              }
            </code></pre>
        </section>

        <section>
          <h3>Example: Error Boundary</h3>
          <h4>Lifecycle</h4>

          <div style="display: flex;">
            <pre><code class="javascript" contenteditable data-trim>
                  class ErrorHandler extends React.Component {
                    constructor(props) {
                      super(props);
                      this.state = { error: null };
                    }

                    static getDerivedStateFromError(error) {
                      return { error: error.toString() };
                    }

                    componentDidCatch(error, info) {
                      console.error("uups... we caught an error", error, info);
                    }

                    render() {
                      if (this.state.error) {
                        return (
                      &lt;div>
                         &lt;h1>An error occured!&lt;/h1>
                        &lt;pre>{this.state.error}&lt;/pre>
                        &lt;button onClick={() => this.setState({ error: null })}>Try again&lt;/button>
                      &lt;/div>
                        );
                      }
                      return this.props.children;
                    }
                  }
                </code></pre>

            <ol>
              <li class="fragment">
                Component gets instantiated, constructor is called, state initialized (error = null)
              </li>
              <li class="fragment">
                Component will be rendered. As <code>this.state.error</code> is not set, the
                children will be rendered
              </li>
              <li class="fragment">An error occures somewhere in your tree</li>
              <li class="fragment">
                <code>componentDidCatch</code> is invoked (you can use it to log the error for
                example)
              </li>
              <li class="fragment">
                <code>getDerivedStateFromError</code> ist called and returns a new (partial) state
                <br />(Other parts of the state are untouched)
              </li>
              <li class="fragment">
                Component will be rendered again. As <code>this.state.error</code> is set now, the
                error message is shown including the button
              </li>
              <li class="fragment">
                After clicking the button, <code>this.state.error</code> will be set to null again
              </li>
              <li class="fragment">
                Component will be rendered again (<code>setState</code>). As
                <code>this.state.error</code> is null again, the children will be rendered again.
              </li>
            </ol>
          </div>
        </section>

        <section>
          <h3>Example: Error Boundary</h3>
          <p>Usage</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                import React from "react";
                import ReactDOM from "react-dom";

                import ErrorHandler from "./ErrorHandler";
                import App from "./GreAppetingController";

                ReactDOM.render(
                  &lt;ErrorHandler>
                    &lt;App />
                  &lt;/ErrorHandler>,
                  document.getElementyById("root")
                );
              </code></pre>

          <p class="fragment">
            You can use as many error handlers as you want in your application
          </p>
          <p class="fragment">
            Recommandation: use at least one on top level
          </p>
        </section>

        <section id="server">
          <h1>Server Access</h1>
          <em>Reading and writing data from a backend (REST/HTTP)</em>
          <p><code>blog-example/steps/4-remote</code></p>
        </section>

        <!-- <section>
          <h3>The blog Backend</h3>
          <p>
            The backend is already implemented. You can started it:
          </p>
          <pre><code>
                  cd react-training/blog-example/backend-rest
                  npm start
                </code></pre>
          <p>The server runs on port 7000</p>
          <p>
            You can test it in your browser (or wget, curl) with this URL:
            <a href="http://localhost:7000/posts">http://localhost:7000/posts</a>
          </p>
        </section> -->
        <!--
        <section>
          <h3>Background: API of the Blog Backend Server</h3>
          <p>
            HTTP Endpoints:
          </p>
          <p><b>GET /posts</b> Return all blog posts</p>
          <p><b>GET /posts/:id</b> Read a single blog post</p>
          <p>
            <b>POST /posts</b> Create a new blog post. Payload must be an object with
            <code>title</code> and <code>string</code> properties. As result you receive the
            complete new blog post (including it's unique id and the date)
          </p>
          <p><b>DELETE /posts/:id</b> Remove a blog post</p>
          <p>
            You can add the query parameter <b>?slow</b> to all backend URLs to simulate a long
            running server operation (for example if you want to see loading states in your
            application)
          </p>
        </section>
-->
        <section>
          <h3>Challanges</h3>
          <ol>
            <li>How do we access a remote API?</li>
            <li>How do we deal with asynchronous code in React?</li>
          </ol>
        </section>

        <section>
          <h3>Server-Calls</h3>
          <ul>
            <li>React is not opinonated about how to do server calls</li>
            <li class="fragment">
              Often used in React applications: <b>fetch</b> API
              <ul>
                <li>Standard browser API for executing HTTP requests</li>
                <li>
                  <a href="http://caniuse.com/#search=fetch" target="_blank">wide support</a>
                </li>
                <li>
                  Specification:
                  <a href="https://fetch.spec.whatwg.org/" target="_blank"
                    >https://fetch.spec.whatwg.org/</a
                  >
                </li>
                <li>
                  Polyfill for older browsers:
                  <a href="https://github.com/github/fetch" target="_blank"
                    >https://github.com/github/fetch</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Example: fetch</h3>
          <p>Read data with HTTP GET using async/await</p>
          <pre><code class="javascript" contenteditable data-trim>
          // For GET simply specify the URL:
          try {
            const response = await fetch('http://localhost:7000/posts')
            const json = await response.json();
            // ...
          } (catch ex) {
            console.error('request failed', ex)
          }
          </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// or use JavaScript Promise API:

fetch('http://localhost:7000/posts')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));
</code></pre>
        </section>
        <section>
          <h3>Example #2: fetch</h3>
          <p>Read data with HTTP POST</p>
          <div class="fragment">
            <p>
              <code>fetch</code> expects a second parameter containing an object with configuration:
            </p>

            <ul>
              <li>
                <code>method</code>: specifies the HTTP method to use (<code>PUT</code>,
                <code>POST</code>, <code>DELETE</code>, ...)
              </li>
              <li>
                <code>headers</code>: HTTP headers for the request (for example Authorization)
              </li>
              <li><code>body</code>: The request payload (as string)</li>
            </ul>
            <p>The return value is the same as we've seen with GET</p>
          </div>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
const response = await fetch(url, {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(payload)
})
// ...
    </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h2>Background: Promises and async/await</h2>
        </section>

        <section data-state="es6-exkurs">
          <h3>Promises</h3>
          <p>
            A <b>promise</b> object represents the eventual result of an asynchronous operation (or
            its failure)
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              // A Promise that prints 'Klaus' after one second:
              new Promise(
                resolve => setTimeout( () => resolve("Klaus"), 1000)
              ).then(name => console.log(name))
                </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>Chained execution</h3>

          <pre><code class="javascript" contenteditable>
// A Promise that resolves the string 'Klaus' after one second:
const promise = new Promise(
  resolve => setTimeout( () => resolve("Klaus"), 1000)
)
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>// 'then' always returns another Promise!
const promise2 = promise.then(name => `Hello, ${name}`);</code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise2.then(greeting => console.log(greeting));
// Output after one second: "Hello, Klaus"
  </code></pre>
        </section>
        <section data-state="es6-exkurs">
          <h3>Errors will interrrupt the promise chain</h3>
          <h4>But you <b>must</b> do something to get informed: catch()</h4>
        </section>

        <section data-state="es6-exkurs">
          <h3>Catch in cases of an error</h3>
          <pre><code class="javascript" contenteditable>
  const promise = new Promise( /* as seen above */ )
    .then(name => {throw new Error("Unexpected Error") })
    .then(greeting => console.log(greeting));
    .catch(error => console.error(`Greeting failed: ${error}`))

    // Output: Greeting failed: Unexpected error
    </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>More on Promises</h3>
          <h4 class="fragment">Create a promise</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
const p = new Promise(resolve => { ... }, error => { ... });
  </code></pre>
          <h4 class="fragment">Creation II</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
// Will be resolved immediatley
const p = Promise.resolve("Klaus");
</code></pre>
          <h4 class="fragment">Awaiting multiple Promises</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
Promise.all( [p1, p2] )
  .then( (result1, result2) => {
    console.log(`All promises resolved: ${result1} ${result2}`);
  });
</code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>Promises: asynchronous control flow</h3>
          <pre><code class="javascript" contenteditable>
console.log("1");

const p = new Promise.resolve("Klaus")
    .then(name => `Hello, ${name}`)
    .then(greeting => console.log(greeting));

console.log("2");
    </code></pre>
          <p>Question to you: how does the console output looks like? 🤔</p>
        </section>

        <section data-state="es6-exkurs">
          <h2>async / await</h2>
          <p>"wrapper" around promises</p>
          <p>Allows you to write asynchronous code in a "linear" style</p>
          <ul class="fragment">
            <li>Since ECMASCript 2017 Standard</li>
          </ul>
        </section>
        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p><code>await</code> waits until a Promise gets resolved</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }

    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);

      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p><code>async</code> declares a function as an "async function"</p>
          <p class="fragment">
            An <code>async</code> functions &nbsp; <b>always</b> returns a Promise
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }

  const greeting = greet('Klaus');

  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> function as fat arrow function:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;

  const greeting = greet('Klaus');

  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p>
            Instead of <code>then</code> or <code>catch</code> you can simply chain multiple
            <code>await</code> statements and use try/catch for exception handling:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};

  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>

        <section>
          <h3>fetch: Details</h3>

          <pre><code class="javascript" contenteditable data-trim>
  try {
    // 1. fetch returns a Promise, that will be resolved with a
    // Response object when the answer from the server comes in
    const response = await fetch('http://localhost:7000/posts');

    // 2. the Response object contains "meta data" about the Response
    // (for ex. http status code) and functions the read the payload,
    // for example from JSON:
    const posts = await response.json();

    // btw: What do we do with the answer here in our React application?
    // ???
  } catch (err) {
    // 4. In case something goes wrong, log error
    console.error('request failed', err);
  }

  </code></pre>
          <p>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
          </p>
        </section>

        <section>
          <h3>When will we load the data (blog posts) for our application?</h3>
        </section>

        <section>
          <h3>Loading (and saving) data</h3>
          <p>👉Step-by-Step</p>
          <p style="font-size: small;"><code>steps/3-hierarchy</code></p>
        </section>

        <section>
          <h3>Fetch-on-Render</h3>
          <p>We can trigger the server call when rendering our component</p>
          <p>
            Until the data is available (during the server call) we show a loading indicator to the
            user
          </p>
        </section>

        <section>
          <h3>Side-effects</h3>
          <p>
            Server calls are <b>side-effects</b> (other examples: manipulating the DOM, opening a
            WebSocket)
          </p>
          <p>Side-effeects are forbidden during the render phase of a component!</p>
        </section>

        <section>
          <h3>useEffekt-Hook</h3>
          <p>
            <em
              >With useEffect you can register an effect (function) that is run after rendering</em
            >
          </p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function App(props) {
              React.useEffect(
                () => console.log("I will run after EACH render")
              );
            }
          </code></pre>

          <div class="fragment">
            2. Parameter (array) determines, when the Hooks will run ("dependencies")

            <pre class="fragment"><code class="javascript" contenteditable data-trim>
              function App(props) {
                React.useEffect(
                  () => console.log("I will run only once after 1st rendering"),
                  []
                );
              }
            </code></pre>
          </div>

          <div class="fragment">
            Only run after 1st rendering an when postId changes:

            <pre class="fragment"><code class="javascript" contenteditable data-trim>
                function App(props) {
                  React.useEffect(
                    () => console.log("..."),
                    [props.postId])
                  );
                }
              </code></pre>
          </div>
        </section>

        <section>
          <h3>useEffect Hook</h3>

          <p>Two parameters:</p>
          <ol>
            <li class="fragment">
              A callback function, that is called after the rendering
            </li>
            <li class="fragment">
              An Array with <b>dependencies</b>:
              <ul>
                <li class="fragment">
                  If you skip this argument, your function will executed after
                  <b>each rendering</b>. Be careful about endless recursions
                </li>
                <li class="fragment">
                  If the dependencies array is empty, the effect will run only once, after the first
                  rendering of your component
                </li>
                <li class="fragment">
                  If there are values in the array the effect will run after the 1st rendering and
                  after any rendering when one of the values have been changed in between
                </li>
              </ul>
            </li>
          </ol>
        </section>

        <section>
          <h3>Example: Initial loading of data</h3>

          <div>
            <p>
              <code>useEffect</code> und (<code>useState</code>) will be used to load data after 1.
              rendering
            </p>
            <pre><code class="javascript" contenteditable data-trim>
                function App() {
                  const [posts, setPosts] = React.useState([]);

                  React.useEffect(() => {
                    fetch("http://localhost:7000/posts")
                      .then(response => response.json())
                      .then(json => setPosts(json));
                  }, []);

                  return {posts.map(p => (
                    &lt;Post key={p.id} post={p} />
                  ))}
                }

                </code></pre>
          </div>
        </section>

        <section>
          <h3>Example: Initial loading of data #2</h3>

          <p>Lifecycle of this example (App component):</p>
          <ol>
            <li class="fragment">
              Component function App is executed (Component will be "rendered")
            </li>
            <li class="fragment">State is initialized with an empty array</li>
            <li class="fragment">The effect (loading the data) is registered</li>
            <li class="fragment">
              UI-Code is returned by the function (in this case an empty lists, as no posts have
              been loaded yet)
            </li>
            <li class="fragment">React creates the native DOM for the UI</li>
            <li class="fragment">React runs the registered Effect, the Server-Call starts</li>
            <li class="fragment">
              Somewhen later: the server call returns, the received data are set into the state
            </li>
            <li class="fragment">
              Updating the state leads to re-rendering of the App component. React invokes the
              function again.
            </li>
            <li class="fragment">The App's state is now the array with the received data</li>
            <li class="fragment">The effect won't run again (empty array as 2. parameter)</li>
            <li class="fragment">
              The component returns the UI for the populated list with blog posts
            </li>
          </ol>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>What is the problem with this code?</h3>

          <pre><code class="javascript">
function BlogList() {
  const [posts, setPosts] = React.useState([]);

  React.useEffect(
    async () => {
      const response = await fetch("...");
      const loadedPosts = response.json();
      setPosts(loadedPosts);
    }, []
  );

  return ...;
}
</code></pre>
          <p>
            The callback function returns a promise (of undefined). That's not allowed, as React
            expectes a function to be return (or undefined).
          </p>
        </section>

        <section>
          <h3>Saving of data</h3>
          <p>For example after a user interaction:</p>
          <p class="fragment">Inside an Event Handler it is allowed to use side effects!</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function App(props) {
  // load, as seen
  React.useEffect( ... );

  function addPost(post) {
    fetch("http://localhost:7000/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(post)
    })
      .then(response => response.json())
      .then(newPost => setPosts([newPost, ...posts]));
  }


  return
    ...
      &lt;AddPost onAdd={newPost => addPost(newPost)} />
    ...
}
                </code></pre>
        </section>

        <section>
          <h3>Managing state with data from server</h3>

          <p>👉Let's look at an example. What happens here?</p>
          <p>Enter <code>slow</code> as a new Blog title</p>
        </section>

        <section>
          <h3>Stale data</h3>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function App(props) {
  const [posts, setPosts] = React.useState([]);

  React.useEffect( /* load ... */ );

  function addPost(post) {
    fetch("http://localhost:7000/posts", { /* ... */ }
      .then(response => response.json())
      .then(newPost => setPosts([newPost, ...posts]));
  }

  return
    ...
      &lt;AddPost onAdd={newPost => addPost(newPost)} />
    ...
}
                </code></pre>
          <p class="fragment">setPost can have stale data!</p>

          <p class="fragment">
            You can use a callback-function in the setter-function to always receive the newest
            state
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function App(props) {
  const [posts, setPosts] = React.useState([]]);
  function addPost(post) {
    fetch("http://localhost:7000/posts", { /* ... */ })
      .then(response => response.json())
      .then(newPost => setPosts(allPosts => ([newPost, ...allPosts])));
  }
}
                          </code></pre>
        </section>

        <section>
          <h2>Exercise: Loading and Saving data on a server</h2>
          <p>
            <em
              >Implement an enhanced version of the <code>App</code> component that is able to load
              and store data using <code>fetch</code>.</em
            >
          </p>
          <p>
            The backend is already implemented. You can started it:
          </p>
          <pre><code>
                  cd react-training/blog-example/backend-rest
                  npm start
                </code></pre>
          <p>The server runs on port 7000</p>
          <p>
            You can test it in your browser (or wget, curl) with this URL:
            <a href="http://localhost:7000/posts">http://localhost:7000/posts</a>
          </p>
        </section>
        <section>
          <h3>Steps</h3>
          <ol class="x-list">
            <li class="fragment">
              Use your own <code>App.js</code> file and add code for loading and saving data or copy
              <code>blog-example/material/4-remote/App.js</code> in your own src-folder
            </li>

            <li class="fragment">
              There are TODOs with further informations (that might help you also when using your
              own <code>App</code> file)
            </li>
            <li class="fragment">
              Optional: add a new state, that tracks wether the server request is running or not. If
              it's running show a "Please wait" message for the user. (Add <code>?slow</code> to the
              endpoint URL to simulate slow server responses)
            </li>
          </ol>
        </section>

        <section>
          <h3>Custom Hooks</h3>

          <em>You can write own ("custom") hooks for common tasks</em>

          <p class="fragment">
            Examples: Loading data, dealing with native dom (setting title of your browser for
            example)
          </p>
        </section>

        <section>
          <h3>Custom Hooks</h3>

          <ul class="x-list">
            <li class="fragment">
              ...their names have to start with <code>use</code>
              <ul>
                <li>(otherwise the linter cannot check them, because it doesn't recognize them</li>
              </ul>
            </li>
            <li class="fragment">
              ...can be used in functional components and other hooks
            </li>
            <li class="fragment">
              ...expected "normal" function arguments (not necessary an object as in function
              component signatures)
            </li>
            <li class="fragment">...can invoke other (custom) hooks</li>
            <li class="fragment">
              ...you can freely choose any return type (no restrictions)
            </li>
          </ul>
        </section>

        <section>
          <h3>Example: A custom hook for loading data</h3>
          <p>
            <em
              >Question: how does a custom hook for loading of blog posts (but generalized) could
              look like? 🤔
            </em>
          </p>

          <ul class="fragment">
            <li>How would the API of the hook look like? What parameters do we need?</li>
            <li>What will the hook return?</li>
          </ul>

          <ul class="fragment">
            <li>
              Optional: can we add the information, that the server request ist running? So the
              caller of our hook can display a loading indicator?
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Example: A Custom Hook for loading data</h3>

          <pre><code class="javascript">
import React from "react";

export default function useApi(url, initialValue) {
  const [isLoading, setLoading] = React.useState(false);
  const [data, setData] = React.useState(initialValue);

  React.useEffect(
    () => {
      async function loadData() {
        try {
          setLoading(true);
          setData(initialValue);
          const response = await fetch(url);
          const json = await response.json();
          setData(json);
        } catch (err) {
          console.error("LOADING DATA FAILED:", err);
          setData(initialValue);
        } finally {
          setLoading(false);
        }
      }
      loadData();
    },
    // Make sure, this Hook only runs (after initial) when URL changes
    [url]
  );

  return [data, setData, isLoading];
}
</code></pre>
        </section>
        <section id="t-typescript">
          <h2>React applications with TypeScript</h2>
          <p>Example: code/blog-example/steps/6-typescript</p>
          <ol>
            <li>
              <a href="#/t-typescript-grundlagen">TypeScript Basics</a>
            </li>
            <li>
              <a href="#/t-typescript-react">React applications with TypeScript</a>
            </li>
          </ol>
        </section>

        <section id="t-typescript-grundlagen">
          <h2>Background: TypeScript</h2>
          <p>
            <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
            <a href="http://www.typescriptlang.org/" target="_blank"
              >http://www.typescriptlang.org/</a
            >)
          </p>
          <ul>
            <li>Extends JavaScript by a type system</li>
            <li>Every valid JavaScript code is also valid TypeScript code</li>
            <li>TS compiler translates to JavaScript</li>
          </ul>
        </section>

        <section>
          <h3>👉TypeScript hands-on</h3>
        </section>
        <section>
          <h3>TypeScript Basics</h3>
          <p>Type declarations are written after the identifier</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Variables can get type informations
  let foo: string;
  foo = 'yo';
  // Error: number: This type is incompatible with string
  foo = 10;
                 </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Functions
  function sayIt(what: string): string {
    return `Saying: ${what}`;
  }

  sayIt('Klaus'); // ok
  sayIt(10); // error
  </code></pre>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Arrow functions
  const sayIt = (what: string): string => `Saying: ${what}`;

  sayIt('Moin');
  sayIt(123); // Error: Argument of type '123' is not assignable
              // to parameter of type 'string'.
  </code></pre>
        </section>

        <section>
          <h2>Built-in types</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // string
  let city: string = 'Hamburg';

  // boolean
  let isDone: boolean = false;

  // number
  let theAnswer: number = 42;

  // array (note the [])
  let cities: string[] = ['Hamburg', 'Barcelona'];
  // alternative:
  let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

  // any
  let theUnknown: any = 'Who cares';
  theUnknown = 666; // ok
  theUnknown = true; // ok
  let a: number = theUnknown; // ok

  // void
  function log(s: string): void { /* ... */ }
              </code></pre>
        </section>
        <section>
          <h2>Types can be inferred by TypeScript</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  let city = 'Hamburg'; // city is a string

  city = 42;
  // Fehler: [ts] Type '42' is not assignable to type 'string'.
  </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  // Function arguments must be specified explicitly
  // (return type can be inferred)

  function sayIt(what: string) {
    return `Saying: ${what}`;
  }

  const said: string = sayIt('Hello TypeScript'); // ok
  const saidItWrong: number = sayIt('Hello TypeScript'); // error!


  </code></pre>
        </section>

        <section>
          <h2>Turn off type checking</h2>
          <p>
            With <code>@ts-ignore</code> (as comment) the type checking in the next line will be
            turned off:
          </p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = "Hamburg";

  city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

  // @ts-ignore
  city = 20259; // ok
  </code></pre>
          <p class="fragment">
            Should be used with care! Only in "difficult" scenarios, for example when type
            definitions of an external library are broken.
          </p>
        </section>
        <section>
          <h2>null and undefined</h2>
          <div class="fragment">
            <p>
              <code>null</code> and <code>undefined</code> are own types. Variables are not nullable
              by default!
            </p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
  let city:string = null; //Type 'null' is not assignable to type 'string'.

  let optionalCity:string|null = null; // OK
              </code></pre>
          </div>
          <div class="fragment">
            <pre><code class="typescript line-numbers" contenteditable data-trim>
    let city:string = undefined; //Type 'undefined' is not assignable to type 'string'.

    let optionalCity:string|undefined = undefined; // OK
    let optionalCity:string|undefined|null = null; // OK
                </code></pre>
          </div>
          <div class="fragment">
            <p>
              Optional parameters and properties can be marked as optional with a ?-sign
            </p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
  function greet(name: string, greeting?: string) {
    console.log(`${greeting || 'Hello'}, {name}`);
  }

  greet('Susi', 'Moin')// Moin, Susi

  // 2. Parameter is optional:
  greet('Klaus'); // Hello, Klaus

  greet('Peter', null); // Argument of type 'null' is not assignable
                        // to parameter of type 'string | undefined'.
              </code></pre>
          </div>
        </section>

        <section>
          <h2>Own types</h2>
          <p>
            With <code>type</code> and <code>interface</code> you can describe the shape/structure
            of your own objects. Type and Interface are almost the same.
          </p>

          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
  // Komplexer Typ
  interface Person {
    name: string; // Pflicht
    livesIn?: string; // Optional
  }

  // or
  type Person = { name: string; livesIn?: string; }

  const susi: Person = { // OK
    name: 'Klaus',
    livesIn: 'Hamburg'
  };
  const klaus: Person = { // OK (livesIn is optional)
    name: 'Klaus'
  }

  const helmut: Person = {} // Error: Property 'name' is missing

  const lukas: Person = {
    name: 'Lukas',
    profession: 'Train driver'
  } // Error: 'profession' does not exist in type 'Person'.
                 </code></pre>
        </section>

        <section>
          <h2>Own types II</h2>
          <p>You can also describe functions on your types</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
            // Complex Type
            type Person {
              name: string; // mandatory
              greet(greeting: string): string;
            }

            const p:Person = {
              name: "Klaus",
              greet(greeting: string) {
                return `${greeting}, ${this.name}`
              }
            }
            p.greet("Hello"); // OK
            p.greet(123); // ERR: Argument of type '123' is not
                          // assignable to parameter of type 'string'.

            const wrong:Person = {
              name: "Susi", // OK
              greet(greeting: number) { return "hello" }
                // ERR: Type '(greeting: number) => string' is not assignable to
                //      type '(greeting: string) => string'.
                //      Types of parameters 'greeting' and 'greeting' are incompatible.
                //      Type 'string' is not assignable to type 'number'.
            }
                           </code></pre>
        </section>

        <section>
          <h2>Type compatibility</h2>
          <em
            >In TypeScript two Types are considered equal when they have the <b>same structure</b>
            ("structural typing"). That differs from C#/Java.
          </em>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
  interface Book {
    title: string
  }

  interface Movie {
    title: string
  }

  const book:Book = { title: "React introduction" };
  const movie:Movie = book; // OK, even Book !== Movie
                 </code></pre>
        </section>

        <section>
          <h2>String Literal Types</h2>
          <p>
            Using a String Literal Type, you can specify with exact strings a type can have. That
            allows you to build enum-like constructs.
          </p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>

type VIEW = "LIST" | "DETAIL" | "ERROR";

const m:VIEW = "LIST"; // OK
const n:VIEW = "NOT_FOUND"; // ERR: Type '"NOT_FOUND"'
                         // is not assignable to type 'VIEW'.

function getView(m: VIEW) {
  if (m === "NOT_FOUND") {
     // ERR: This condition will always return 'false' since the
     // types 'VIEW' and '"NOT_FOUND"' have no overlap.
  } else if (m === "DETAIL") {
      // OK
  }
}
            </code></pre>
        </section>
        <section>
          <h2>Mapped Types</h2>
          <p>Using mapped types you can construct new types based on others:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string; lastname: string};

const p:Person = {
    name: "Klaus",
    lastname: "mueller"
}

p.lastname = "Meier"; // OK

// ReadonlyPerson ist ein "mapped type"
type ReadonlyPerson = Readonly&lt;Person>;

const p2:ReadonlyPerson = {
    name: "Klaus",
    lastname: "mueller"
}

p2.name = "Karl"; // Cannot assign to 'name' because it is a read-only property.
</code></pre>
        </section>
        <section id="t-typescript-react">
          <h2>React Applications with TypeScript</h2>
          <em>State and Properties of components can be described using TypeScript</em>
          <p class="fragment">
            Attention! TypeScript-Files, that contain JSX <b>have to</b> end with <code>.tsx</code>!
          </p>

          <p class="fragment">👉 Let's see how this works (<code>workspace-typescript</code>)</p>
        </section>
        <section>
          <h2>Type-safety in function components</h2>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type PostListProps = {
  posts: BlogPost[];
  onAddPost(): void;
};
            </code></pre>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
    function BlogList(props: PostListProps) {
      props.posts.length // OK

      props.post // compile ERROR: Property 'post' does not exist on type 'PostListProps'.
      props.onAddPost("huhu"); // compile ERROR: Expected 0 arguments, but got 1.
    }

            </code></pre>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
    // With Destructuring
    function BlogList({posts, onAddPost}: GreetingMasterProps) => {
      // ...
    }

            </code></pre>
        </section>

        <section>
          <h3>Typ-safe usage of components</h3>

          <div class="fragment">
            <p>Code Completion</p>
            <img style="height: 200px;" src="slides/images/screenshot-ts-code_completion.png" />
          </div>

          <div class="fragment">
            <p>Unknown property</p>
            <img style="height: 200px;" src="slides/images/screenshot-ts-error-01.png" />
          </div>

          <div class="fragment">
            <p>Wrong usage of a property</p>
            <img style="height: 200px;" src="slides/images/screenshot-ts-error-02.png" />
          </div>
        </section>

        <section>
          <h3>Type-safety in useState</h3>
          <p>The type of the state from useState can be inferred by TypeScript</p>
          <pre
            class="fragment"
          ><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type PostEditorProps = {  onSavePost(post: NewBlogPost): void; };
function PostEdior(props: PostEditorProps) {
  const [title, setTitle] = React.useState("");

  // greeting is string, because initial value is a string
  setGreeting("huhu"); // OK
  setGreeting(666); // ERROR (wrong Type)
  setGreeting(null); // ERROR (wrong Type)
}
            </code></pre>
          <div class="fragment">
            <p>You can also specify it explicitly</p>
            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type VIEW = "LIST" | "ADD";

function App() {
  const [view, setView] = React.useState&lt;VIEW>("LIST");

  // Mode ist either string "MODE_MASTER" or "MODE_DETAIL"
  // setMode only accepts the string "MODE_MASTER" and "MODE_DETAIL"

  setMode("NOT_FOUND"); // compile error
  setMode(null); // compile error
}
                            </code></pre>
          </div>
        </section>

        <section>
          <h2>React Events in TypeScript</h2>
          <p>
            Events in React are all instances of <code>React.SyntheticEvent</code> which wrapps the
            native DOM events
          </p>
          <p class="fragment">
            The type for the events expects the type of the html element it is fired from (source of
            the event) as a type argument.
          </p>
          <p class="fragment">TypeScript then knows the properties and functions of the event</p>
          <span class="fragment">
            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
function PostEditor(props) {
  const [title, setTitle] = React.useState("");

  function handleChange(e: React.SyntheticEvent&lt;HTMLInputElement>) {
    setTitle(e.currentTaget.value);
  }

  return &lt;input onChange={handleChange} value={title} />
}
          </code></pre>
            <p>
              <a
                href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682"
                target="_blank"
              >
                <code>target</code> vs
                <code>currentTarget</code>
              </a>
            </p>
          </span>
        </section>
        <section>
          <h2>useRef</h2>
          <p>
            <code>useRef</code> returns a generic container for data of any type. <br />The
            contained type must be specified using a type parameter
          </p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
  function PostEditor(props) {
    const inputRef = React.useRef&lt;HTMLInputElement|null>(null);
    // inputRef.current can either be HTMLInputElement or null

    function reset() {
      inputRef.current.focus(); // ERR: current might be null

      if (inputRef.current) {
        inputRef.current.focus(); // OK
      }
    }
  }
            </code></pre>
        </section>
        <section>
          <h2>Exercise: Type-safe React components</h2>
          <h3>
            <em>Add type informations to existing react components</em>
          </h3>
          <div style="font-size: 80%;">
            <div class="fragment">
              <p>
                <b>WORKSPACE:</b>
              </p>
              <p>
                Please use the workspace <code><b>blog-example/workspace-typescript</b></code
                >. <br />It contains the latest app version, but prepared for TypeScript.
              </p>
            </div>
            <div class="fragment">
              <p>
                <b>PREPARATION:</b>
              </p>
              <ol class="x-list">
                <li>Stop your running "npm run" process (frontend) using ctrl+c</li>
                <li>
                  Run <code><b>npm install</b></code> in
                  <code>blog-example/workspace-typescript</code>
                </li>
                <li>
                  Run <code><b>npm start</b></code> in
                  <code>blog-example/workspace-typescript</code>
                </li>
              </ol>
            </div>
          </div>
        </section>
        <section>
          <h3>Exercise 1: Add type informations</h3>
          <ol style="font-size: 80%;" class="x-list">
            <li class="fragment">
              Add missing type informations in <code>PostList.js</code> and
              <code>PostEditor.js</code>
            </li>
            <li class="fragment">
              Before modifying one of the files, rename it to <code>.tsx</code> and restart "npm
              run"
            </li>
            <li class="fragment">You can find more instructions inside the files</li>
          </ol>

          <h3 class="fragment">Exercise 2: Add new View mode in App</h3>
          <ol style="font-size: 80%;" class="x-list">
            <li class="fragment">
              After saving a new Blog Post, a new view should be presented to the users (showing a
              message like "Your post have been saved")
            </li>
            <li class="fragment">
              In addition to the info message the new view should have an "OK"-Button
            </li>
            <li class="fragment">
              When the user clicks the OK-Button the <code>PostList</code> should be displayed:
              <br /><code class="fragment"
                >LIST --onAdd--> EDIT --onSave--> FEEDBACK --onOk--> LIST</code
              >
            </li>
          </ol>
        </section>

        <section id="t-test">
          <h1>Part I</h1>
          <h2>Testing React Applications</h2>
          <ul style="font-size: 85%;">
            <li>
              Example:
              <a href="blog-example/steps/4-test/coverage/lcov-report/index.html" target="_blank"
                >Coverage Report</a
              >
            </li>
          </ul>
        </section>

        <section data-transition="slide none">
          <h2>What do we test?</h2>
          <ul>
            <li class="fragment">
              <b>UI-independent logic</b> (for example services, backend calls)
            </li>
            <li class="fragment">
              <b>Rendering</b> (is the list of blog post correctly rendered? is the markup as we
              want it?)
            </li>
            <li class="fragment">
              <b>Interactions</b> (are my event handlers working and correctly set?)
            </li>
            <li class="fragment">
              <b>Behaviour in the browser</b> (z.B. correct rendering, Browser-spezific JavaScript,
              Working with browser artefacts, such as history, Title, Scrollbars etc)
            </li>
          </ul>
        </section>
        <section data-transition="slide none">
          <h2>What do we test?</h2>
          <ul>
            <li style="color: lightgrey;">
              <b>UI-independent logic</b> (for example services, backend calls)
            </li>
            <li>
              <b>Rendering</b> (is the list of blog post correctly rendered? is the markup as we
              want it?)
            </li>
            <li><b>Interactions</b> (are my event handlers working and correctly set?)</li>
            <li style="color: lightgrey;">
              <b>Behaviour in the browser</b> (z.B. correct rendering, Browser-spezific JavaScript,
              Working with browser artefacts, such as history, Title, Scrollbars etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a>)</em
            >
          </p>
          <p class="fragment">
            Complete Test solution for React (and others):
          </p>
          <ul class="fragment">
            <li>Test Runner</li>
            <li>Specs, Assertions, Mocks</li>
            <li>Code Coverage</li>
            <li>"Snapshot testing"</li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Example: A simple testcase</h3>
          <pre><code class="javascript" contenteditable data-trim>// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> or
            <code>it</code>
          </p>
          <pre><code data-trim contenteditable>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code data-trim contenteditable>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Expectations and Matchers</h2>
          <div class="fragment">
            <p>
              <code>expect()</code> returns an <em>Expectation</em> obects, that contains several
              <em>Matcher</em> functions:
            </p>
            <pre><code data-trim contenteditable>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div class="fragment">
            <p>Some Matchers</p>

            <pre><code data-trim contenteditable>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p class="fragment">
            <a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a>
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Functions</h2>
          <ul>
            <li class="fragment">
              <code>jest.fn()</code> creates a mock function
              <pre><code data-trim contenteditable>// Returns undefined when executed
const aMockFn = jest.fn();

aMockFn("huhu"); // => undefined

expect(aMockFn).toHaveBeenCalled());
expect(aMockFn.toHaveBeenCalledWith("huhu"));
                      </code></pre>
            </li>

            <li class="fragment">
              Implementation of the mock function can be passed as parameter:
              <pre><code data-trim contenteditable>
        const aMockFn = jest.fn( param => `Hello, ${param}` );
        
        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Testing React Components</h3>
          <h2>Rendering-only</h2>
        </section>

        <section>
          <h3>React Test Renderer</h3>
          <p>
            <a href="https://www.npmjs.com/package/react-test-renderer"
              >https://www.npmjs.com/package/react-test-renderer</a
            >
          </p>
          <p>Renders React Components into JSON Objekts (without DOM):</p>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';

const component = renderer.create(
  &lt;PostList posts={somePosts} />
);

console.log(component.toJSON());
            </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
        { type: 'div',
          props: {},
          children:  [
            { type: 'buton', props: {}, children: [Object] },
            { type: 'article', props: [Object], children: [Object] },
            { type: 'article', props: [Object], children: [Object] }
          ]
        }
            </code></pre>
        </section>
        <section>
          <h3>"Snapshot Testing" with Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> compares a JSON-Object with a stored object
            in a file:
          </p>
          <ul>
            <li class="fragment">
              At <b>first</b> execution: Snapshot-File will be created (
              <a href="slides/images/jest-snapshot-file.png" target="_blank">Example</a>)
              <ul>
                <li class="fragment">Snapshot files will be stored in Git</li>
              </ul>
            </li>
            <li class="fragment">
              In all <b>following</b> test executions: new snapshot will be created and compared
              against saved snapshot.
            </li>
            <li class="fragment">
              When Snapshots differ:
              <ul>
                <li>
                  Error including diff (
                  <a href="slides/images/jest-snapshot-diff.png" target="_blank">Example</a>)
                </li>
                <li>
                  In "watch mode" the snapshot can be updated
                  <img src="slides/images/jest-snapshot-update.png" />
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Snapshot Testing with Jest and React</h3>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
        
test('it should render correctly', () => {

  const somePosts = [ . . . ];

  const component = renderer.create(
    &lt;PostList posts={somePosts} />
  );

  expect(component.toJSON()).toMatchSnapshot();
});
            </code></pre>
        </section>

        <section>
          <h3>Testing React Components #2</h3>
          <h2>Interactions</h2>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage good testing
              practices."
            </em>
          </p>

          <p>
            <a href="https://github.com/testing-library/react-testing-library" target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophy: tests are written from a user perspective. To find your elements you want to
            test, you use properties the user also sees (like labels, aria roles, etc)
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            import { render, screen } from "@testing-library/react";
            import userEvent from "@testing-library/user-event";

            it("invokes callback on button click", () => {
              const onAddPostFn = jest.fn();
            
              // Render
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            
              // search the button
              const buttonElement = screen.getByRole("button", { name: "Add Post" });

              // "click" the button
              userEvent.click(buttonElement);
            
              // make sure it has been invoked
              expect(onAddPostFn).toHaveBeenCalled();
            });


            </code></pre>
        </section>

        <section>
          <h3>render-Function</h3>
          <p>
            You can use the render-Function from testing-library/react to render your component in
            your test (no browser needed)
          </p>
          <p>
            Just as in real world you can specify properties etc (might be testdata and/or mocks)
          </p>
          <p>
            The render function returns a set of query-functions that can be used to search for
            elements within the rendered components (deprecated!, see next slide)
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            import { render } from "@testing-library/react";

              // Render a single component
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
          </code></pre>
          <p class="fragment">Remember when using Components, that needs a "Context"!</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>

              // Render with surrounding Redux Provider (or Router, your own Context etc.)
              render(
                &lt;Provider>
                  &lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />
                &lt;/Provider>
              );
            </code></pre>
        </section>
        <section>
          <h3>query Functions</h3>
          <p>
            To verify and interact with the elements from your component you need to find them 🤓
          </p>
          <p>
            On the global <b>screen</b> object there are many functions defined, that allows you
            searching for an element
          </p>
          <p>
            The query functions have different <b>suffixes</b>, that describe what they're searching
            for (a label, a aria-role, ...)
          </p>
          <p>
            The query functions have different <b>prefixes</b> (getBy, queryBy etc) that describes
            their outcome (i.e. wether they fail if they don't find the object or if they just
            return nothing)
          </p>
          <p>
            More on this:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre class="fragment"><code class="javascript">
  // EXAMPLES: 

  // search the button (assume there is exactly one, fail otherwise)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // search the button (return null or ONE button, throws Exception otherwise)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // search the button (return all buttons or an empty array)  
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>Verify you components</h3>
          <p>
            After quering a component you can verify their attributes etc to make sure they're
            correct
          </p>
          <p>
            The library
            <a href="https://github.com/testing-library/jest-dom" target="_blank">jest-dom</a> adds
            DOM-specific matchers for jest.
          </p>

          <pre class="fragment"><code class="javascript">
  import { screen } from "@testing-library/react";

  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // assert presence of the element (getBy query would maybe make more sense)
  expect(buttonElement).toBeInTheDocument();

  // assert value of input field
  expect(titleInput).toHaveValue("Moin moin");

  // assert enablement of a button
  expect(okButton).toBeDisabled();
</code></pre>
          <p class="fragment">All matchers are described on the GitHub page (Link see above)</p>
        </section>
        <section>
          <h3>Interaction</h3>
          <p>
            You can interact with the elements from a component by sending events, as the browser
            would do
          </p>
          <p>
            There's a special library
            <a href="https://github.com/testing-library/user-event" target="_blank"> user-event</a>,
            that helps you constructing this events.
          </p>
          <p>(In the next release of react-testing-library it will be included)</p>

          <pre class="fragment"><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // type somthing into an input field
            // (with another parameter you can configure how fast typing speed should be etc)
            userEvent.type(titleInput, "New Title");

            // click a button
            userEvent.click(clearButton);
          </code></pre>
          <p class="fragment">All events can be found on the GitHub page (Link see above)</p>

          <p class="fragment">
            Note that you don't have to test if an element exists before sending an event; the test
            will fail with a readable error message, if the element is not available
          </p>
        </section>
        <section>
          <h3>Testing with fetch</h3>
          <p>Challenges:</p>
          <ul>
            <li>Asynchronous code (not limited to fetch)</li>
            <li>Server mocking</li>
          </ul>
        </section>
        <section>
          <h3>Dealing with asynchronous code</h3>
        </section>

        <section>
          <h3>Testing async code</h3>
          <p>
            Example: The <b>App</b> components loads data, than it displays the post list. Loading
            of the data is async code
          </p>

          <pre class="fragment"><code class="javascript">
            it("should render posts read from backend", () => {
              render(&lt;App />);
            
              // imagine there is an article with title "One"
              const articleOne = screen.findByRole("heading", { name: "One" });

              expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
            });
          </code></pre>
          <p class="fragment">
            Good news: we can write an async test and waitfor the element until it's loaded
          </p>
          <pre class="fragment"><code class="javascript">
            // not the async function here:
            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // note the await statement here:
              const articleOne = await screen.findByRole("heading", { name: "One" });

              expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
            });
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testing fetch</h3>
          <p>As seen, we're able to test async code</p>
          <p class="fragment">Do we want to have fetch calls in our code?</p>
          <p class="fragment">
            Propably not, because we don't want to depend on a running (and working) server in test
          </p>
          <p class="fragment">We want to "mock out" fetch</p>
        </section>

        <section>
          <h3>Mocking fetch #1</h3>
          <p>We can mock whole modules in jest</p>
          <p class="fragment">We could move our fetch code to an own module an mock that</p>

          <pre class="fragment"><code class="javascript">
            // api.ts (simplified!)
            export function readPosts() {
              return fetch("http://localhost:7000/posts").then(response => response.json());
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // App.tsx:

            import { readPosts } from "./api";
            function App() {
              // ...
              React.useEffect(() => {
                // use readPosts here:
                readPosts()
                  .then(json => {
                    setLoading(false);
                    setPosts(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            }
          </code></pre>
        </section>
        <section>
          <h3>Mocking a Module</h3>
          <p>Several ways, this is the simplest one(?)</p>

          <pre class="fragment"><code class="javascript">
            // App.test.tsx

            const mockPosts = [
              { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
              { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
            ];

            jest.mock("../api", () => ({
              readPosts: () => Promise.resolve(mockPosts)
            }));

            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // we still need to await, but we don't care about
              // running server anymore
              const articleOne = await screen.findByRole("heading", { name: "One" });
              expect(articleOne).toBeInTheDocument();

              expect(screen.getByText("Second Post")).toBeInTheDocument();
            });
          </code></pre>
        </section>
        <section>
          <h3>Option #2: Mocking fetch</h3>
          <p>There are several libs that allows you to mock fetch</p>
          <p>
            For me
            <a href="https://www.npmjs.com/package/jest-fetch-mock" target="_blank"
              >jest-fetch-mock</a
            >
            works best
          </p>

          <pre class="fragment"><code class="javascript">
            // App.test.tsx
            it("should render posts read from backend", async () => {
              // set the expected response (there are more ways to customize the fetch mock behaviour)
              fetchMock.mockResponse(JSON.stringify(mockPosts));

              render(&lt;App />);
            
              // we're still async, but no "real" fetch anymore
              const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

              expect(articleOne).toBeInTheDocument();
            });

          </code></pre>
        </section>

        <section>
          <h2>Exercise: write a test for the PostEditor</h2>
          <p>Steps:</p>
          <ol>
            <li class="fragment">
              Work inside <code>advanced/exercies/1_testing</code>
              <p>Hint: only open this folder in your IDE</p>
            </li>
            <li class="fragment">Run <code>npm install</code> there</li>
            <li class="fragment">Run <code>npm test</code> there (this process does not stop)</li>
            <li class="fragment">
              There is one failing test: the <code>PostEditor.test.tsx</code>.
            </li>
            <li class="fragment">Why? Because it's empty! It's up to you to implement the test</li>
            <li class="fragment">Look inside the file to find more informations</li>
            <li class="fragment">
              Note: saving your test file should automatically re-run the tests, other press 'a' on
              the command line
            </li>
            <li class="fragment">
              In case you need help: ask your co-workers, ask me or find the solution at
              <code>steps/1_testing</code>
            </li>
          </ol>
        </section>

        <section id="t-pattern">
          <h1>Part II</h1>
          <h2>
            Pattern
          </h2>
          <h3>Technique: Higher-Order-Components, Render Properties, Custom Hooks</h3>
          <h3>Architecture: Dumb and Presentation Components</h3>
        </section>

        <section>
          <h3>Example: Loading Data in React</h3>
          <p>Naive and "specialized" implementation, no reuse, just for loading a Blog Post...</p>

          <pre class="fragment"><code class="javascript">
            export function BlogLoader() {
              const [post, setPost] = React.useState&lt;BlogPost | null>(null);
              const [loading, setLoading] = React.useState(false);
            
              React.useEffect(() => {

                setLoading(true);

                fetch("http://localhost:7000/posts/P7")
                  .then(response => response.json())
                  .then(json => {
                    setLoading(false);
                    setPost(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            
              if (loading || !post) {
                return &lt;LoadingIndicator>Post is loading. Please wait.&lt;/LoadingIndicator>;
              }
            
              return &lt;SinglePost title="Blog Post (Hook Example)" post={post} />;
            }            
          </code></pre>
        </section>

        <section>
          <h3>Example: Loading Data in React</h3>
          <p>Requirements for a "generic" DataLoader component</p>
          <ul>
            <li class="fragment">We fetch data from a specified URL</li>
            <li class="fragment">While data is loading, a Loading Indicator should be shown</li>
            <li class="fragment">
              When the data has been loaded it should be rendered by a specified component
            </li>
            <li class="fragment">Should be typesafe (TypeScript)</li>
            <li class="fragment">
              Code should be reusable and work from and with different components
            </li>
            <li class="fragment">The target component can receive additional props</li>
          </ul>
        </section>

        <section>
          <h3>Approach #1: Higher-Order-Components</h3>
          <p>
            <em
              >A higher-order component is a function that takes a component and returns a new
              component.</em
            >(<a href="https://reactjs.org/docs/higher-order-components.html">Docs</a>)
          </p>
          <p>Made popular by Redux (?)</p>
          <p>Typically used with class components (?)</p>
        </section>

        <section>
          <h3>Higher-Order Components (HOC)</h3>
          <p class="fragment">
            The Higher-Order-Component is responsible for the <b>rendering</b> of a wrapped
            component
          </p>
          <ul class="fragment">
            <li>The HOC can delay (or skip at all) rendering of the wrapped component</li>
            <li>The HOC can access all props</li>
            <li>
              The HOC can add properties for the wrapped component or can remove some
            </li>
          </ul>
        </section>
        <section>
          <h3>Example: Higher-Order Components (HOC)</h3>
          <p>
            We have a Component (SinglePost) that displays a Post. The component has no idea where
            the data comes from
          </p>
          <p>There is a HOC'd version of the component that is responsible for loading the data</p>
          <p>As a user of the HOC'd version it is transparent that dataloading is done</p>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      
    // SinglePost (displays a single blog post):
    function SinglePost({title, post}: { title: string, post: BlogPost}) {
      return &lt;article>...render post...&lt;/article>;
    }
      
    // wrap with our dataloader HOC
    export default withDataLoader("post", SinglePost);
    </code></pre>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    // Usage (Note: SinglePost is the HOC'd component)

    import SinglePost from "./SinglePost";
    // we have an additional property (url) here that is NOT defined on SinglePost,
    // on the other hand we have no post-Property here, that is required on the original SinglePost 
    // component... 

    &lt;SinglePost title="Single Post HOC" url="http://..." />
                                      </code></pre>
        </section>
        <section>
          <h3>Example: Higher-Order Components (HOC)</h3>
          <p>Step 1: A simple HOC...</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      
      // Step 1: simply wrap a component (no extra functionality, demo only).
      function withDataLoader(RawComponent) {
        return function DataLoader(props) {
            // Use {...this.props} to forward all properties that the HOC received
            // to the target (raw) component
            return &lt;RawComponent {...this.props} />
          }
        }
                                      </code></pre>

          <pre class="fragment"><code class="javascript">
function MyComponent() { ... }          
// same as MyComponent, only with a wrapper around it
const WrappedComponent = withDataLoader(MyComponent);
        </code></pre>
        </section>

        <section>
          <h3>Example: Higher-Order Components (HOC)</h3>
          <p>Step 2: Implement the HOC</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    function withDataLoader(RawComponent) {
      return function DataLoader(props) {
        const [data, setData] = React.useState&lt;T | null>(null);
        const [loading, setLoading] = React.useState(false);

        React.useEffect( () => fetch(props.url).then(...data logic as seen... ));

        if (loading) { return &lt;LoadingIndicator /> }

        // invoke target component
        return &lt;RawComponent {...props} data={data} />
      }
    }
      
                                          </code></pre>
        </section>
        <section>
          <h3>Example: Higher-Order Components (HOC)</h3>
          <p>Step 3: Using the HOC</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    import withDataLoader from ". . .";
    
    // SinglePost does not know anything about a url, only the post and the title
    function SinglePost({post, title}) { . . .};
    
    export default withDataLoader(SinglePost);
                                            </code></pre>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    import SinglePost from ". . .";
    
    // When using the HOC'd SinglePost we pass in the URL but NOT the post!
    // 
    &lt;SinglePost url="..." title="A single post" />
                                            </code></pre>
        </section>

        <section>
          <h2>Problems with HOCs</h2>
          <ul>
            <li>Hard to understand and to write</li>
            <li>"magically" added properties</li>
            <li>wrapper components</li>
            <li>
              colliding property names (our component takes a 'post' and 'user' property, but the
              HOC passes a 'data' property 😢)
            </li>
            <p>
              Hard to type when adding properties (TypeScript), esp. when adding and removing
              properties
            </p>
          </ul>
        </section>

        <section>
          <h3>Approach #2: Render Properties</h3>
          <p>Made popular by React Router (?)</p>
          <p>Used both in class and function components</p>
        </section>

        <section>
          <h3>Example: Data Loader</h3>
          <p>Step 1: The Loading Indicator</p>
          <p>Remember: you can pass React components as properties to other components</p>

          <pre class="fragment"><code class="javascript">
            function DataLoader({ loadingComponent }) {
              const [data, setData] = React.useState&lt;T | null>(null);
              const [loading, setLoading] = React.useState(false);
      
              React.useEffect( () => fetch(props.url).then(...data logic as seen... ));
      
              if (loading) { 
                return loadingComponent;
              }
              ...
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Usage
            function App() {
              return &lt;DataLoader loadingComponent={&lt;LoadingIndicator/>} />
            }
          </code></pre>
        </section>

        <section>
          <h3>Example: Data Loader</h3>
          <p>Step 2: The Data</p>
          <p class="fragment">How about this?</p>
          <pre class="fragment"><code class="javascript">
          // Usage
          function App() {
            return &lt;DataLoader loadingComponent={&lt;LoadingIndicator/>} 
            dataComponent={&lt;SinglePost />}
            />
          }
        </code></pre>
          <p class="fragment">
            How does <b>DataLoader</b> pass the loaded Post to <b>SinglePost</b>?
          </p>
        </section>

        <section>
          <h3>Example: Data Loader</h3>
          <p>Step 2: The Data</p>
          <p>How about this?</p>
          <pre><code class="javascript">
          // Usage
          function App() {

            function renderDataComponent(post) {
              return &lt;SinglePost post={post} />
            }

            return &lt;DataLoader 
               loadingComponent={&lt;LoadingIndicator/>} 
               renderDataComponent={renderDataComponent}
            />
          }
        </code></pre>
          <p class="fragment">
            What if we pass a callback function to <b>DataLoader</b> that gets the loaded data and
            returns the <b>SinglePost</b> for it?
          </p>
        </section>
        <section>
          <h3>Example: Data Loader</h3>
          <p>Step 2: The Data</p>
          <pre><code class="javascript">
            function DataLoader({ loadingComponent, renderDataComponent }) {
              const [data, setData] = React.useState&lt;T | null>(null);
              const [loading, setLoading] = React.useState(false);
      
              React.useEffect( () => fetch(props.url).then(...data logic as seen... ));
      
              if (loading) { 
                return loadingComponent;
              }

              return renderDataComponent(data);
            }        </code></pre>
          <p>
            Now <b>DataLoader</b> can load the data, pass it to the callback function
            (<b>renderDataComponent</b>) and render the returned component!
          </p>
          <p class="fragment">
            Property 'renderDataComponent' is called a <b>render property</b> (because it renders a
            component)
          </p>
        </section>

        <section>
          <h3>Example: Data Loader</h3>
          <p>Step 2: Variation: Function as Children</p>
          <p>What about this one?</p>
          <pre><code class="javascript">
            // Usage
          function App() {
            return &lt;DataLoader loadingComponent={&lt;LoadingIndicator/>}> 
                 { post => &lt;SinglePost post={post} /> }
                &lt;DataLoader/>
            }
          }        </code></pre>
          <p class="fragment">
            <b>children</b> is a regular property and thus can be used as a render property too!
          </p>
        </section>

        <section>
          <h3>Example: Data Loader</h3>
          <pre><code class="javascript">
            function DataLoader({ loadingComponent, children }) {
              const [data, setData] = React.useState&lt;T | null>(null);
              const [loading, setLoading] = React.useState(false);
      
              React.useEffect( () => fetch(props.url).then(...data logic as seen... ));
      
              if (loading) { 
                return loadingComponent;
              }

              // children is a function!
              return children(data);
            }        </code></pre>
          <p class="fragment">
            You can use a named property, the children or both - depending on your needs.
          </p>
        </section>

        <section>
          <h3>Custom Hooks</h3>

          <em>You can write own ("custom") hooks for common tasks</em>

          <p class="fragment">
            Examples: Loading data, dealing with native dom (setting title of your browser for
            example)
          </p>
        </section>
        <section>
          <h3>Custom Hooks</h3>
          <p>Live: <code>exercises/2_pattern</code></p>
        </section>

        <section>
          <h3>Custom Hooks</h3>

          <ul class="x-list">
            <li class="fragment">
              ...their names have to start with <code>use</code>
              <ul>
                <li>(otherwise the linter cannot check them, because it doesn't recognize them</li>
              </ul>
            </li>
            <li class="fragment">
              ...can be used in functional components and other hooks
            </li>
            <li class="fragment">
              ...expected "normal" function arguments (not necessary an object as in function
              component signatures)
            </li>
            <li class="fragment">...can invoke other (custom) hooks</li>
            <li class="fragment">
              ...you can freely choose any return type (no restrictions)
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Example: A Custom Hook for loading data</h3>

          <pre><code class="javascript">
            export default function useLoader&lt;T>(url: string) {
              const [data, setData] = React.useState&lt;T | null>(null);
              const [loading, setLoading] = React.useState(false);
            
              React.useEffect(() => {
                setLoading(true);
                fetch(url)
                  .then(response => response.json())
                  .then(json => {
                    setLoading(false);
                    setData(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, [url]);
            
              if (loading || !data) {
                return { loading: true };
              }
            
              return {
                loading: false,
                data
              };
            }
</code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Usage of Custom Hook</h3>

          <pre class="fragment"><code class="javascript">
            function App() {
              const postData = useLoader&lt;BlogPost>("http://localhost:7000/posts/P7");

              if (postData.loading) {
                return &lt;LoadingIndicator>Post Loading...&lt;/LoadingIndicator>;
              }
            
              return &lt;SinglePost title="Blog Post (Custom Hook)" post={postData.data} />;
            }            
          </code></pre>
        </section>

        <section>
          <h2>Exercise!</h2>
          <h3>Build your own custom hook for data fetching</h3>
          <p>Steps (1/2):</p>
          <ol>
            <li class="fragment">
              Work inside <code>advanced/exercies/2_pattern</code>
              <p>Hint: only open this folder in your IDE</p>
            </li>
            <li class="fragment">Run <code>npm install</code> there</li>
            <li class="fragment">Run <code>npm start</code> there (this process does not stop)</li>
            <li class="fragment">
              In <code>App.tsx</code> there are three components: <b>BlogLoader</b>,
              <b>UserLoader</b> and <b>App</b>
            </li>
            <li class="fragment">
              Both <b>BlogLoader</b>, <b>UserLoader</b> fetch data and displays loader indicator
            </li>
            <li class="fragment">
              Build a Custom Hook (<b>useDataLoader</b>) that can load data. While data is loading,
              the <b>LoadingIndicator</b> component should be shown
            </li>
            <li class="fragment">
              You can build the hook inside <code>App.tsx</code> or in an its own file, that should
              not make a difference
            </li>
            <li class="fragment">
              Use your custom hook in both <b>BlogLoader</b> and <b>UserLoader</b> component
            </li>
          </ol>
        </section>
        <section>
          <h2>Exercise!</h2>
          <h3>Build your own custom hook for data fetching</h3>
          <p>Steps (2/2):</p>
          <ol>
            <li class="fragment">
              Note: the <code>demoFetch</code> used in the examples is just a real "fetch" function,
              only that is "slows down" the server responses to make the LoadingIndicator visible
            </li>
            <li class="fragment">
              When your hook works, think about or discuss with your team members: would it be
              possible to use your hook directly in <b>SinglePost</b> or
              <b>SingleUser</b> component? Would that makes sense? What are the pros and cons? What
              would have that for consequences for your application? For usage? For re-using? For
              testing?
            </li>
            <li class="fragment">
              If you need help, ask your colleagues, me, or find the solution on the previous
              slides, in
              <code>advanced/steps/2_pattern/useLoader.tsx</code> (Custom Hook) and
              <code>SpecializedLoader.tsx</code> (usage)
              <p>
                (The exercise does not use the <code>title</code> property, so steps and exercise
                differy very slightly)
              </p>
            </li>
          </ol>
        </section>

        <!-- ######################################## DUMP PRESENTATION COMPS ################################################ -->
        <!-- ######################################## DUMP PRESENTATION COMPS ################################################ -->
        <!-- ######################################## DUMP PRESENTATION COMPS ################################################ -->
        <section>
          <h3>Smart and Dumb-Components #1</h3>

          <p>
            Reminder: in React we build components. Components consist of logic, state and UI
            (HTML-Elements and Styling)
          </p>
          <p class="fragment">
            In a well-known pattern components are spilt into "smart" (or "controller") and "dumb"
            (or "presentation") components.
          </p>
          <p class="fragment">
            Technically both components are identical, both are regular React components
          </p>
          <p class="fragment">
            Only their <b>intended purpose</b> or role is defined differently...
          </p>
        </section>

        <section>
          <h3>Smart and Dumb components #2</h3>
          <p><b>Smart components</b> contain logic and state, but (almost) no UI</p>
          <p><b>Dumb components</b> only present/render the data</p>
          <ol>
            <li class="fragment">
              Smart components <b>manage the state</b> and pass it into Dumb components. Dump
              components <b>render the state</b>.
            </li>
            <li class="fragment">
              Smart components pass callback functions as Event-Handler into the dumb components.
            </li>
            <li class="fragment">
              When an event occures inside a dumb component, (for ex. button click or text input)
              the dumb components invokes the callback function.
            </li>
            <li class="fragment">
              The callback function is executed inside the context of the smart component (normal
              closure behaviour) and thus can acess state etc from the smart component.
            </li>
            <li class="fragment">
              Inside the event handler, state of the smart component can be changed. Chaning the
              state leads to re-rendering of the smart component and all of its children (dumb)
              components.
              <br /><b>The app state remains consistent across all components in the hierarchy</b>
            </li>
          </ol>
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/smart-dumb-1.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/smart-dumb-2.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/smart-dumb-3.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/datenfluss-4.png' height="550">
    
    Strict data- and control flow    
                      </textarea
          >
        </section>

        <section>
          <h3>Example</h3>

          <p>
            Our <b>smart component</b> holds a list of Blog Posts and deceides, which view is active
            (Editor or List) ist
          </p>
          <p>
            The smart components passes the list of blog posts to the BlogList component for
            rendering
          </p>
          <p>
            The smart components passed a callback function to BlogList and AddForm to get informed
            about events/data changes
          </p>

          <pre><code>
function App() {
  const [posts, setPosts] = React.useState([]);
  const [view, setView] = React.useState("list");

  function addPost(newPost) {
    // Add the new post to the state
    setPosts([...posts, newPost]);

    // switch back to list view
    setView("list");
  }

  if (view === "list") {
    return &lt;BlogList posts={posts} onAdd={() => setView("addForm")} />
  }

  return &lt;AddForm onAdd={addPost} />

}            
</code></pre>
        </section>

        <section>
          <h3>Example #2</h3>

          <p>
            The BlogList is responsible for rendering the list of posts only. If the add button gets
            pressed, the component invokes the callback function (received from the App component).
          </p>
          <p>The callback function changes the App state to make the Post Editor visible</p>

          <pre><code>
  function BlogList(props) {

    return &lt;div>
      // ... render the blog post list ...
      &lt;button onClick={props.onAdd}>Add Blog Post&lt;/button>
    &lt;/div>;
  }            
  </code></pre>
        </section>

        <section>
          <h3>Smart- or dumb?</h3>
          <p>Let's have a look at our three Pattern...</p>
          <p>What do you think: How do they fit into this architecture?</p>

          <p class="fragment">HOC</p>
          <p class="fragment">Render Properties</p>
          <p class="fragment">Custom Hooks</p>
          <p></p>
        </section>

        <!-- ######################################## ROUTER ################################################ -->
        <!-- ######################################## ROUTER ################################################ -->
        <!-- ######################################## ROUTER ################################################ -->
        <section id="t-router">
          <h1>Part III</h1>
          <h2>Client-side Routing</h2>
          <h3>Overview of React Router</h3>
        </section>
        <section>
          <h2>Why routing?</h2>
          <span>
            <p>
              Map URLs to Components
              <br />
              <span style="font-size: 80%;"
                >(Navigation through the application without server round-trips!)</span
              >
            </p>
          </span>
          <span>
            <p>
              URLs can contain state of the application
              <br />
              <span style="font-size: 80%;"
                >What "Page" is visible (Blog List, Add Form or Blog Post)?</span
              >
              <br />
              <span style="font-size: 80%;">Which blog post should be rendered (postId)</span>
            </p>
          </span>
        </section>

        <section>
          <h2>React Router</h2>
          <ul>
            <li>
              Current version 5.1:
              <a href="https://reacttraining.com/react-router/" target="_blank">
                https://reacttraining.com/react-router/</a
              >
            </li>
            <li>Not part of React</li>
            <li>but de-facto Standard</li>
            <li>Since Version 5.1 with Hooks API (useParams, useLocation, useHistory)</li>
            <li class="fragment">
              React Router <b>v6</b> changes API slightly, add news features but is not stable yet
            </li>
          </ul>
        </section>
        <section>
          <h3>The Router Object</h3>
          <p class="fragment">
            Top-Level object, that needs to be included at the top of the application's component
            hierarchy
          </p>
          <p class="fragment">
            Mulitple implementations that differ how they interact with URL and browser history:
          </p>
          <ul>
            <li class="fragment">
              <b>HashRouter</b>: adds the path after appended hash (#/post/1) <br />👉Example: check
              network request after changing the URL
            </li>
            <li class="fragment">
              <b>BrowserRouter</b>: puts the path directly in the URL (/post/1) <br />(You need to
              configure your web server accordingly)
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {HashRouter as Router} from "react-router-dom";
      
      const app = &lt;Router>&lt;App/>&lt;/Router>;
      
      ReactDOM.render(app, document.getElementById(...));
              </code></pre>
        </section>

        <section>
          <h3>Which component should be rendered for a path?</h3>
          <p class="fragment">The <code>Route</code> object maps paths to components</p>
          <ul>
            <li class="fragment">
              Can be used whereever you want to select a component based on a path
              <ul>
                <li>
                  comparable with an "intelligent" <code>if</code> or <code>switch</code> statement
                </li>
                <li>can be used everywhere in your components</li>
              </ul>
            </li>
            <li class="fragment">
              Use the <code>path</code> attribute to specify the path that should match when the
              component should be rendered
            </li>
            <li class="fragment">Specify the component as children of the Route component</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {HashRouter as Router, Route} from "react-router-dom";
      
      const app = &lt;Router>
        &lt;Route path="/post/:postId">&lt;BlogPostPage />&lt;/Route>
        &lt;Route path="/add">&lt;AddPostPage onAdd={...} />&lt;/Route>
        &lt;Route path="/" exact>&lt;BlogListPage />&lt;/Route>
      &lt;/Router>;
      
      ReactDOM.render(app, document.getElementById(...));
              </code></pre>
        </section>

        <section>
          <h3>Background: Paths</h3>
          <p>
            In the Route component you specify a <b>path</b>, that is compared against the current
            URL
          </p>

          <ul>
            <li>
              Paths by default are valid for parts of strings, but you can change the behaviour by
              adding <code>exact</code>
            </li>
            <li>A Route without <code>path</code> matches always</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      // matches  / and /post
      &lt;Route path="/">...&lt;/Route>
      
      // matches only /
      &lt;Route path="/" exact>...&lt;/Route>
      
      // matches any URL:
      &lt;Route>...&lt;/Route>
      
              </code></pre>
          <ul>
            <li class="fragment">A Path can contain variable segments:</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      &lt;Route path="/posts/:postId">&lt;BlogPostPage/>&lt;/Route>
           </code> </pre>
          <ul>
            <li class="fragment">
              Values of the variables can be read using the <code>useParams</code> hook in your
              component:
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                import { useParams } from "react-router";

                function BlogPostPage() {
                  const params = useParams();

                  // params.postId contains the id from the URL
                </code></pre>
        </section>
        <section>
          <h3>Switch</h3>
          <ul>
            <li class="fragment">
              If multiple path expression match, multiple components will be rendered (for example
              "/" and "/post")
            </li>
            <li class="fragment">
              <code>Switch</code> ensures that only the für component will be rendered (like regular
              switch with a break after each case)
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {HashRouter as Router, Route, Switch} from "react-router-dom";
      
      const app = (
        &lt;Router>
          &lt;Switch>
            &lt;Route path="/post/:postId">&lt;BlogPostPage />&lt;/Route>
            &lt;Route path="/" exact>&lt;BlogListPage/>&lt;/Route>
      
            // "No match": without path
            &lt;Route>&lt;NotFoundPage/>&lt;/Route>
      
          &lt;/Switch>
        &lt;/Router>
      );
      
      ReactDOM.render(app, document.getElementById(...));
              </code></pre>

          <p class="fragment">
            Note: this will change in v6 Switch will be replaced by <b>Routes</b> component
          </p>
        </section>

        <section>
          <h3>Links</h3>
          <p>
            Using the <code>Link</code> or <code>NavLink</code> component you can create HTML links
          </p>
          <ul>
            <li>Use <code>to</code> to specify the target path</li>
            <li>Link creates an <code>a</code> HTML element</li>
            <li>
              "Local" URLs will be rendered according to the selected Router implementation (with
              hash or without)
            </li>
            <li>
              With <code>activeClassName</code> and <code>activeStyle</code> on
              <code>NavLink</code> you can specify styles and classnames that get applied if the
              current route is the same route as specified in "to" ("active" route)
            </li>
          </ul>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {Link, NavLink} from "react-router-dom";
      
      &lt;Link to='/'>Show all Posts&lt;/Link>
      
      // Generted 'a' element contains 'highlight' CSS class, when it's the active route
      &lt;NavLink to='/add' activeClassName="highlight">Add Post&lt;/NavLink>
      
              </code></pre>
        </section>

        <section>
          <h3>The history-Objekt</h3>
          <p>The <code>history</code> object can be used to interact with the Browser history</p>
          <p>
            You can jump to another location or get the current location from the browser
          </p>
          <p class="fragment">
            The history object is available using the <code>useHistory</code> hook from React Router
          </p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import { useHistory } from "react-router";

      function App() {
        const history = useHistory();

        function onAdd(newBlogPost) {
           ...

           // go to new URL
           history.push("/"); 
        }

        return ...;
      }
              </code></pre>
        </section>

        <!-- ######################################### REDUX STATE CONTEXT ############################################## -->
        <!-- ######################################### REDUX STATE CONTEXT ############################################## -->
        <!-- ######################################### REDUX STATE CONTEXT ############################################## -->
        <section id="t-state">
          <h1>Part IV</h1>
          <h2>Statemanagement with Redux and React Context API</h2>
        </section>

        <section>
          <h2>A typical React application composed of components</h2>
          <h3>
            My Question: what for problems can occur using this approach/architecture in larger)
            applications? 🤔
          </h3>
          <img
            src="slides/images/typische-react-komponenten-hierarchie.png"
            style="height: 650px;"
          />
        </section>

        <section>
          <h3>Problem 1: State spread across multiple components</h3>
          <img src="slides/images/verteilter-zustand.png" style="height: 650px;" />
          <p>
            Even if we separate our components in smart and dumb components we will have a couple of
            components with state and logic
          </p>
        </section>

        <section>
          <h3>Problem 2: Separated component hierarchies</h3>
          <img src="slides/images/zwei-komponenten-hierarchien.png" style="height: 650px;" />
          <p>Does not work or results in a "god-component"</p>
        </section>

        <section>
          <h3>Problem 3: Shared ("globale") State</h3>
          <img src="slides/images/gemeinsam-genutzter-state.png" style="height: 650px;" />
          <p>How does the state reaches the bottom across multiple levels?</p>
        </section>

        <section>
          <h3>Problem 4: UI and logic tied together</h3>
          <img src="slides/images/ui-und-logic-vermischt.png" style="height: 650px;" />
          <p>Reusability? React-independence? Testability?</p>
        </section>

        <section>
          <h3>External Statemanagement</h3>
          <p class="fragment">Idea: Move the state out of your component hierarchy ("external")</p>
          <p class="fragment">Prominent solutions:</p>
          <ul>
            <li class="fragment"><a href="https://redux.js.org/">Redux</a></li>
            <li class="fragment">
              <a href="https://reactjs.org/docs/context.html">React Context API</a> (maybe not
              really external)
            </li>
            <li class="fragment"><a href="https://mobx.js.org/README.html">MobX</a></li>
            <li class="fragment">Apollo GraphQL (not GraphQL itself)</li>
          </ul>
        </section>

        <section id="t-context">
          <h2>Context API</h2>
          <p>Real World Example: <code>4-context</code></p>
        </section>

        <section>
          <h3>Context Api Live Introduction</h3>
          <p>(exercise/4_context)</p>
        </section>

        <section>
          <h2>Context...</h2>
          <p>
            <em
              >allows you to pass informations down in your component hierarchies but without using
              properties
            </em>
          </p>

          <ul>
            <li class="fragment">only works inside a component hierarchy</li>
            <li class="fragment">
              there can be an unlimited amount of contexts in your application
            </li>
            <li class="fragment">consists of <code>Provider</code> and <code>Consumer</code></li>
            <li class="fragment">
              <a href="https://reactjs.org/docs/context.html" target="_blank">Documentation</a>
            </li>
          </ul>
        </section>

        <section>
          <h2>Context Factory</h2>
          <p>
            <em>creates an object with <b>two components</b></em>
          </p>
          <ul>
            <li class="fragment">
              <code>Provider</code>, provides a user-defined object with key-value-pairs in your
              component hierarchy (the actual Context-"Value")
            </li>
            <li class="fragment">
              <code>Consumer</code> is used inside a component to access the context value. Used
              with <code>useContext</code> hook
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      import react from "React";

                      const AuthContext = React.createContext();

                      // creates two components:
                      // AuthContext.Provider 
                      // AuthContext.Consumer
                              </code></pre>
        </section>

        <section>
          <h2>Context Factory #2</h2>
          <p>
            <em>Context can use a default value</em>
          </p>
          <ul>
            <li class="fragment">
              You can specify a default value, that is returned by the context, if no provider is
              registered in your app, but (only) consumers.
            </li>
            <li class="fragment">
              This might not often appear in real life, but for example in tests or other "corner
              cases"
            </li>
            <li class="fragment">
              When using TypeScript the default parameter is required, whether needed or not!
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      import react from "React";

                      // A default value for the AuthContext...
                      const defaultValue = {
                        currentUser: null,
                        login: () => {}, // no op
                        logout: () => {} // no op
                      }

                      // Use the default value when creating the context
                      const AuthContext = React.createContext(defaultValue);
                              </code></pre>
        </section>

        <section>
          <h2>Context Provider</h2>
          <p><em>A React Component, that provides the context value</em></p>
          <ul>
            <li class="fragment">
              will be returned by your own component, that manages the context value
            </li>
            <li class="fragment">
              takes an object ("Context") with user defined values (even functions allowed)
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      const AuthContext = React.createContext();

                      function AuthProvider() {
                          const [ currentUser, setCurrentUser ] = React.useState(null);
                          const contextValue = {
                            // the current theme
                            currentUser,
                      
                            // function to set new theme
                            login: name => setCurrentUser(name),
                            logout: () => setCurrentUser(null)
                          };
                      
                          return &lt;AuthContext.Provider value={contextValue}>
                            {props.children}
                          &lt;/AuthContext.Provider>;
                        }
                      }                    
</code></pre>
        </section>

        <section>
          <h2>useContext-Hook</h2>
          <p><em>Reads values from the context</em></p>
          <p>Can be used in all components underneath the provider component</p>
          <p>Takes the object returned by <code>React.createContext</code> as parameter</p>
          <pre class="fragment"><code class="javascript">
function UserBadge() {
  const { currentUser } = React.useContext(AuthContext);

  return currentUser  ? &lt;h1>Welcome, {currentUser}&lt;h1> : null;
}            
          </code></pre>

          <p class="fragment">Changing Context value for example by a provided callback function</p>
          <p class="fragment">Inside the provider, state changes, provider will be re-rendered</p>
          <p class="fragment">All conumers are rerendered, app is up-to-date</p>
          <pre class="fragment"><code class="javascript">
function UserBadge() {
  const { currentUser, logout } = React.useContext(AuthContext);

  return currentUser  ? 
    &lt;>&lt;h1>Welcome, {currentUser}&lt;h1>&lt;button onClick={logut}>Logout&lt;/button>&lt;/> 
    : null;
}                
          </code></pre>
        </section>

        <section>
          <h2>Exercise!</h2>
          <h3>Build a Context providing a Counter (as seen in the live coding)</h3>
          <p>Steps:</p>
          <ol>
            <li class="fragment">
              Work inside <code>advanced/exercies/4_context</code>
              <p>Hint: only open this folder in your IDE</p>
            </li>
            <li class="fragment">Run <code>npm install</code> there</li>
            <li class="fragment">Run <code>npm start</code> there (this process does not stop)</li>
            <li class="fragment">
              In <code>CounterContext.tsx</code> implement the Context-Provider (see TODOs there)
            </li>
            <li class="fragment">
              In <code>App.tsx</code> add your Context-Provider and replace the dummy code in
              <code>CounterWithIncrease</code> and <code>Counter</code> by using your context (see
              TODOs there)
            </li>
            <li class="fragment">
              <b>Optional</b>: Can you build a custom hook, that returns the values of your
              CounterContext? Can you imagine if and why that could make sense in real life?
            </li>
            <li class="fragment">
              If you need help, ask your colleagues or me or find the solution in
              <code>steps/4a-context-hello-world</code> <br />Note: the context there takes a third
              function (reset) that we don't need in our exercise
            </li>
          </ol>
        </section>

        <section id="t-redux">
          <h2>Redux</h2>
          <h3>External Statemanagement</h3>
          <p>Real World Example</p>
          <p>(npm run start:withAuth)</p>
          <p>(npm start in 5-redux)</p>
        </section>

        <section>
          <h3>Remember...</h3>
          <h2>Render Cycle in Pure React</h2>
          <img src="slides/images/redux-01-react-cycle-no-redux.png" style="height: 650px;" />
        </section>

        <section>
          <h2>Redux moves responsibilities out of your component...</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px;" />
        </section>

        <section>
          <h2>Redux step-by-step</h2>
          <p>(npm start in workspace-redux)</p>
        </section>

        <section>
          <h2>All parts of Redux</h2>
        </section>

        <section>
          <h3>Action Creators</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export function setBlogListSort(sortBy, direction) {
  return {
    type: "SET_BLOGLIST_SORT",
    sortBy,
    direction,
  };
}
</code></pre>
          <ul>
            <li class="fragment">Action-Creators create action objects</li>
            <li class="fragment">
              They should hide the internal action structure from your application (it's
              questionable if it's worth the effort)
            </li>
            <li class="fragment">
              Actions are simple JavaScript objects that should describe Events that happend in your
              application (questionable, some say they should express what the application should
              do)
            </li>
            <li class="fragment">
              Using the <code>dispatch</code> function they are forwarded to <em>all</em> Reducers
              (<em>all</em> reducers receive <em>all</em> actions)
            </li>
            <li class="fragment">
              Actions contain a <b>type</b> and a <b>payload</b>. The payload is userdefined, Redux
              doesn't care.
            </li>
          </ul>
        </section>

        <section>
          <h3>Dispatching Actions</h3>
          <ul>
            <li class="fragment">
              Actions will be dispatched using the <code>dispatch</code> function that is returned
              by the <code>useDispatch</code> hook
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
import { useDispatch } from "react-redux"

function LogoutForm() {
  const dispatch = useDispatch();

  function handleLogout() {
    dispatch(logoutAction());
  }

  return &lt;button onClick={handleLogoutClickEvent}>Logout&lt;/button>;
}
          </code></pre>
        </section>

        <section>
          <h3>Action creators can be used for async code (e.g. data fetching)</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const loadPost = postId => dispatch => {
fetch(BACKEND_URL+'/'+postId)
    .then(response => response.json())
    .then(post => dispatch({
        type: ADD_POST,
        post
    });
};
</code></pre>
          <ul>
            <li class="fragment">
              An action creator does not return the action but a <em>thunk function</em> that
              <b>later</b> dispatches the action
            </li>
            <li class="fragment">
              The returned <em>thunk function</em> will be invoked by redux immediatley. The
              <em>thunk function</em> receives the <code>dispatch</code>-function
            </li>
            <li class="fragment">
              Inside the <em>thunk function</em> we can use the dispatch function to dispatch one or
              more events (for example: loadingDataStarted, dataReceived)
            </li>
          </ul>
        </section>

        <section>
          <h3>There is <em>only one</em> store, that contains the <em>whole</em> (Redux) state</h3>
          <p>Disclaimer: not all of your app state needs to be in redux</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import { rootReducer } from './reducers';

// http://redux.js.org/docs/api/createStore.html
const store = createStore(
  rootReducer // reducer
);

ReactDOM.render(
  &lt;Provider store={store}>
    &lt;App />
  &lt;/Provider>,
  document.getElementById("...")
);
    </code></pre>
          <ul>
            <li class="fragment">
              The store will be made available to all components via the <em>Provider</em> component
            </li>
          </ul>
        </section>
        <section>
          <h3>Middleware between Dispatch and Store</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
  rootReducer, // reducer
  applyMiddleware(thunk) // middleware as enhancer
);
    </code></pre>
          <ul>
            <li class="fragment">
              Allows you to 'plug-in' between a dispatched action and the store
            </li>
            <li class="fragment">Often used for logging or for thunk actions</li>
            <li class="fragment">
              Middleware is an advanced feature that you might not need very often (beside thunk
              middleware)
            </li>
          </ul>
        </section>
        <section>
          <h3>Sum up</h3>
          <ol>
            <li class="fragment">We create an Action, using an Action Creator</li>
            <li class="fragment">The action will be passed through all middlewares</li>
            <li class="fragment">If no middleware vetoes, the Action reaches the Store</li>
            <li class="fragment">The store dispatches the Action to all Reducers</li>
          </ol>
        </section>

        <section>
          <h3>Reducers contains your business logic</h3>
          <ul>
            <li class="fragment">
              Idea/Recommendation: put as much business logic as possible in reducers
            </li>
            <li class="fragment">You can have more than one reducer</li>
          </ul>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import {combineReducers} from 'redux';

// http://redux.js.org/docs/api/combineReducers.html
export const rootReducer = combineReducers({
  posts, // Blog Posts
  auth,   // Current User
  options // View Options (Search Order)
});
    </code></pre>
          <ul>
            <li class="fragment">
              Reducers are <em>pure functions</em> that receive their old state and an action. They
              might handle that action and return a new state.
            </li>
            <li class="fragment">
              You can have more than one reducer in your app. The return values of all reducers
              shapes the store. A reducer cannot see the "partial state" ("slice") of another
              reducer.
            </li>
          </ul>
        </section>

        <section>
          <h3>Reducer</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
const auth = (state = {}, action) => {
switch (action.type) {
    case "LOGIN":
        return { currentUser: action.username };
    case "LOGOUT":
        return {};
    default:
        return state;
  }
};
    </code></pre>
          <ul>
            <li class="fragment">
              A reducer must initialize it's initial state (often with default parameter)
            </li>
            <li class="fragment">
              Never mutates the old state, but creates a new one (for example a copy)
            </li>
            <li class="fragment">
              Library <a href="https://github.com/immerjs/immer">immer</a> can help with simplifying
              immutable code
            </li>
          </ul>
        </section>

        <section>
          <h3>useSelector: Access global state</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { useSelector } from 'react-redux';

function App() {
  const currentUser = useSelector(state => state.auth.currentUser);
  ...
}
</code></pre>
          <ul>
            <li class="fragment">useSelector takes a <em>selector function</em></li>
            <li class="fragment">
              The selector function is invoked by redux and gets the <em>whole state</em> as
              parameter
            </li>
            <li class="fragment">
              It returns the parts of the state, the component is interessted in
            </li>
            <li class="fragment">
              You can use more than on useSelector call in your component and you should return
              primitives from your selector function (no objects)
            </li>
          </ul>
        </section>

        <section>
          <h3>useSelector #2: TypeScript</h3>
          <ul>
            <li class="fragment">
              You can add a type parameter to <code>useSelector</code>, that describes your global
              store
            </li>
            <li class="fragment">
              Inside the selector callback function you than have type safety
            </li>
          </ul>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { useSelector } from 'react-redux';

function App() {
  const currentUser = useSelector( 
    (state: MyAppState) => state.auth.currentUser // OK
  ); 

  const invalidUser = useSelector(
    (state: MyAppState) => state.auth.currentUer // ERR: currentUer not defined
  ); 
  
  ...
}
</code></pre>
        </section>

        <section>
          <h2>Summary redux architecture</h2>
          <img
            src="slides/images/redux-03-resulting-redux-architecture.png"
            style="max-height: 650px;"
          />
        </section>
        <section>
          <h3>Redux Toolkit</h3>
          <em
            >"The official, opinionated, batteries-included toolset for efficient Redux
            development"</em
          >
          <ul>
            <li><a href="https://redux-toolkit.js">https://redux-toolkit.js.org/</a></li>
            <li>Pre-configured (including thunk and immer)</li>
            <li>Simplifies implementing action creators and reducers</li>
          </ul>
        </section>

        <section>
          <h3>Local state is still "allowed"!</h3>
          <p>There are a lot of places where you can hold state</p>
          <ul>
            <li class="fragment">Server and client</li>
            <li class="fragment">Component State</li>
            <li class="fragment">Redux</li>
            <li class="fragment">URL, Session or Local Storage</li>
          </ul>

          <img
            class="fragment"
            src="slides/images/three-kinds-of-state.png"
            style="max-height: 650px;"
          />
        </section>

        <section>
          <h3>Redux vs Context</h3>
          <p class="fragment">
            Redux hat Dev Tools, Time Travelling, Middlewares, globale Actions und Reducers/State
          </p>
          <p class="fragment">Redux ist sehr optimiert für Performance (häufige Updates)</p>
          <p class="fragment">Context von der API her einfacher (aber auch nicht so mächtig)</p>
          <p class="fragment">
            Redux lässt feingranularere Auswahl aus dem globalen Zustand zu (verhindert unnötige
            Renderings)
          </p>
        </section>

        <section>
          <h3>Redux vs Context</h3>
          <h3><em>Wie entscheiden wir uns?</em></h3>
          <p class="fragment">
            Entscheidung 1: Mischform: Redux <b>und</b> Context? Oder: Redux <b>oder</b> Context
          </p>
          <p class="fragment">Entscheidung 2: Was kommt wohin?</p>
          <p class="fragment">Auth-State (eingeloggter Benutzer)</p>
          <p class="fragment">Api-State: Netzwerk Request(s) laufen gerade</p>
          <p class="fragment">Draft-Post: editierters, neues, Post</p>
        </section>

        <section>
          <h2>Exercise!</h2>
          <h3>Migrate the Hello-World-Post-Editor to Redux</h3>
          <p>Steps:</p>
          <ol>
            <li class="fragment">
              Work inside <code>advanced/exercies/5_redux</code>
              <p>Hint: only open this folder in your IDE</p>
            </li>
            <li class="fragment">Run <code>npm install</code> there</li>
            <li class="fragment">Run <code>npm start</code> there (this process does not stop)</li>
            <li class="fragment">
              First implement the action creators (in <code>actions.ts</code>);
            </li>
            <li class="fragment">Implement the Reducer function (in <code>reducers.ts</code>)</li>
            <li class="fragment">
              Then migrate <code>PostEditor.tsx</code> so that it reads from redux and dispatches
              actions to redux
            </li>
            <li class="fragment">
              In all three files there are todos with more hints
            </li>
            <li class="fragment">
              If you need help, ask your colleagues or me or find the solution in
              <code>steps/5a-redux-hello-world</code>
            </li>
          </ol>
        </section>

        <!-- ######################################### GRAPHQL ############################################## -->
        <!-- ######################################### GRAPHQL ############################################## -->
        <!-- ######################################### GRAPHQL ############################################## -->
        <section id="t-graphql">
          <h3>Part V</h3>
          <h1>GraphQL</h1>
          <h2>Clients with Apollo React</h2>
        </section>

        <section>
          <h3>The Blog Application with Apollo GraphQL</h3>

          <p>👉 Example: steps/6-graphql</p>
        </section>
        <section>
          <h3>Contents</h3>
          <ol>
            <li>GraphQL concepts</li>
            <li>GraphQL clients with React</li>
          </ol>
        </section>

        <section>
          <h2>GraphQL</h2>
          <h3>
            "GraphQL is a <em>query language for APIs</em> and a
            <em>runtime for fulfilling those queries</em> with your existing data"
          </h3>
          <p><a href="https://graphql.org">https://graphql.org</a></p>
          <p class="fragment">
            Second part is your server. We don't have a look at server-side implementations in this
            training
          </p>
        </section>

        <section>
          <h2>Apollo</h2>
          <h3>"A community building flexible open source <em>tools for GraphQL</em>."</h3>
          <p><a href="https://github.com/apollographql">https://github.com/apollographql</a></p>
          <p class="fragment">
            Apollo Server: framework for GraphQL servers written in JavaScript<br />
            The example server is written using Apollo Server
          </p>
          <p class="fragment"><a href="">Apollo Client</a>: library for building GraphQL clients</p>
          <p class="fragment">
            <a href="https://www.apollographql.com/docs/react/api/react-apollo/"
              >Apollo Client (React)</a
            >
            is the implementation for React clients
          </p>
          <p class="fragment">
            De-facto Standard for React GraphQL Clients (other popular one:
            <a href="https://relay.dev/">Relay</a>)
          </p>
        </section>

        <section>
          <h3>Why GraphQL?</h3>
          <p class="fragment">Clients can query for the exact data they need</p>
          <p class="fragment">
            That allows very flexible architectures and decoupling between client and server
          </p>
          <p class="fragment">Clients ask for <b>data</b> not for <b>endpoints</b></p>
          <p class="fragment">That might reduce network traffic</p>
          <p class="fragment">
            You got "end-to-end" type-safety (GraphQL APIs must have a schema!)
          </p>
        </section>

        <section>
          <h3>Query Language</h3>

          <pre><code class="graphql">
{
  posts {
    id
    title
    user {
      name
    }
  }
}
          </code></pre>
          <p><b>Structured</b> language for requesting data from an API</p>
          <p>Looks like JSON, but is a string</p>
          <p>Requested are <b>fields</b> of (nested) objects</p>
        </section>

        <section>
          <h3>Query Language</h3>

          <pre><code class="graphql">
{
  # postId is an argument
  post(postId: "P1") {
    id
    title
    user {
      name
    }
  }
}
          </code></pre>

          <p>Fields can have <b>arguments</b> (making them look like methods)</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Query Language: Responses</h3>
          <img src="slides/images/graphql/query-response.png" />

          <p>Structure of a response matches the structure of the query</p>
          <p>A client already knows how the answer will look like when writing the query</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>GraphQL: Description of the API</h3>
          <p class="fragment">Every GraphQL API is described in a schema</p>
          <p class="fragment">A schema defines <b>Objects</b>. Objects have <b>Fields</b>.</p>
          <p class="fragment">A Field has a <b>Type</b></p>
          <p class="fragment">
            A type can either be scalar (ID, String, Int, Boolean) or another Object
          </p>
          <p class="fragment">A type can also be a <b>List/Array</b> of another type</p>
          <p class="fragment">
            Each field can be set to <b>mandatory</b> to indicate that you always get a value if you
            query the field (not-null)
          </p>
          <p class="fragment">
            There is a reflection-like API that allows quering the schema information using GraphQL
          </p>
          <p class="fragment">👉Let's have a look: <code>backend-graphql/src/schema.js</code></p>
        </section>

        <section>
          <h3>Query Language: Operations</h3>
          <p>A <b>operation</b> describes, what the client want to do</p>
          <p>
            Operations: <code>query</code> (default), <code>mutation</code> or
            <code>subscription</code>
          </p>

          <pre class="fragment"><code class="graphql">
# "query" is the operation type
# GetPost is the operation name (optional)

query GetPost {
  post(postId: "P1") {
    id
    title
    teaser
    user {
      name
    }
  }
}              
            </code></pre>
        </section>
        <section>
          <h3>Query Language: Variables</h3>
          <p>Operations can define variables that can be re-used in the query</p>
          <p>Makes writing reusable queries easier (like a prepared statement for a database)</p>

          <pre class="fragment"><code class="graphql">
# $postId is a variable here
# You can name them as you like but the need to prefixed with $
# You must also specify their type
# It's value must be set with each query invocation

query GetPost($postId: ID!) {
  post(postId: $postId) {
    id
    title
    teaser
    user {
      name
    }
  }
}              
            </code></pre>
        </section>

        <section>
          <h3>Fragments</h3>
          <p>
            You can use <b>fragments</b> to define re-usable "query parts", if you have to select
            the same the of fields again and again
          </p>

          <pre><code class="javascript">
fragment PostTeaser on Post {
  id
  teaser
  user { name }
}

query PostList {
  ...PostTeaser
}

query PostListWithData {
  ...PostTeaser
  date
}
            </code></pre>
        </section>

        <section>
          <h3>Query Language: Mutations</h3>
          <p>A mutation can be used to <b>modifiy</b> data on the server</p>
          <p>(like HTTP POST, PATCH, PUT, DELETE with REST)</p>
          <p>As with a query, you select the fields from the response that you want to have</p>

          <pre class="fragment"><code class="graphql">
mutation CreatePlogPost($newPost: NewBlogPost!) {
  createBlogPost(postData: $newPost) { 
    error 
    blogPost { id title date body }
  }
}           
            </code></pre>
        </section>

        <section>
          <h3>Query language: Aliases</h3>
          <p>You can rename a field in the response using an <b>Alias</b></p>
          <p>
            Useful if you have name conflicts or field names that doesn't make sense in your
            use-case
          </p>
          <pre class="fragment"><code class="graphql">
mutation CreatePlogPost($newPost: NewBlogPost!) {
  newPost: createBlogPost(postData: $newPost) { 
    error 
    blogPost { 
        id 
        title 
        publicationDate: date 
        body 
      }
  }
}
</code></pre>
          <img class="fragment" src="slides/images/graphql/field-aliases.png" height="300px" />
        </section>

        <section>
          <h3>Query Language: Subscriptions</h3>
          <p>With subscriptions, you can <b>subscribe</b> for <b>events</b> from the server</p>

          <pre class="fragment"><code class="graphql">
subscription {
  likedPost: onNewLike(postId: "P1") {
    id
    title
    likes
  }
}           
            </code></pre>
        </section>
        <section>
          <h3>GraphQL: Query execution</h3>
          <p>GraphQL queries are <b>always</b> executed using HTTP POST requests!</p>
          <p>Query and Variables are sent in the body</p>
          <p>There is a single endpoint that executed the queries (not multiple as with REST)</p>

          <pre class="fragment"><code class="bash">
$ curl -X POST -H "Content-Type: application/json" \
    -d '{"query":"{ posts { title } }"}' \
    http://localhost:4000/


{"data":
  {"posts": [
    {"title": "Creating GraphQL Frontends"},
    {"title ": "Implementing a React App"}
   ]}
}              
            </code></pre>
        </section>

        <section>
          <h3>GraphQL: Response from server</h3>
          <p>Always HTTP Status 200 (with a very few exceptions)</p>
          <p>Errors are handled using domain-specific error fields (for example)</p>
          <p>Response is a JSON object with up to three fields:</p>
          <div class="fragment">
            <pre><code class="javascript">
{
  {"errors": 
    [
      { "message": "Could not read User with ID 123",
        "locations": [ . . . ],
        "path": [ "post", "user" ]
      }
    ]
  },

  {"data": {"posts": [ . . . ] },

  {"extensions": { . . . }
}

            </code></pre>
            <p><b>errors</b> is set if an (unhandled) server error occures (like invalid data)</p>
            <p><b>data</b>: the result of the query (as seen before)</p>
            <p>
              <b>extensions</b>: for server-specific informations (debuging/tracing etc).
              Vendor-specific!
            </p>
          </div>
        </section>
        <section>
          <h3>Toolstack</h3>
          <p>
            <a href="https://github.com/graphql/graphiql">GraphiQL</a> /
            <a href="https://github.com/prisma-labs/graphql-playground">Playground</a>
          </p>
          <p>
            Code Generator
            <a href="https://github.com/apollographql/apollo-tooling">from Apollo</a> /
            <a href="https://graphql-code-generator.com/">for various languages</a>
          </p>
          <p>
            IDE support for
            <a
              href="https://marketplace.visualstudio.com/items?itemName=apollographql.vscode-apollo"
              >Apollo and VS Code</a
            >
          </p>
          <p>
            Apollo Client Developer Tools (<a
              href="https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm"
              >Chrome only</a
            >)
          </p>
        </section>
        <section>
          <h3>Exercise #1: Let's get started with GraphQL queries</h3>

          <div class="fragment">
            <p>Start the GraphQL backend:</p>
            <ol>
              <li>
                Go into <code><b>blog-example/backend-graphql</b></code>
              </li>
              <li><code>npm install</code></li>
              <li><code>npm start</code></li>
            </ol>
          </div>

          <div class="fragment">
            <p>
              Open the GraphQL Playground at
              <a href="http://localhost:4000">http://localhost:4000</a>
            </p>
          </div>
          <p class="fragment">Run some queries:</p>
          <ol class="fragment">
            <li>Request the IDs of all Blog Post</li>
            <li>
              Request a single Blog Post using its ID. Query its <b>title</b>, its <b>likes</b> and
              the name of it's author (<b>user</b>)
            </li>
            <li>
              Add a Like to the blog post (via mutation). Read the new number of likes from the
              response
            </li>
          </ol>
          <p class="fragment">
            Hint: Inside the playground you get completion and docs on the right side
          </p>
        </section>

        <section>
          <h2>GraphQL Clients with React and Apollo</h2>
        </section>

        <section>
          <h3>GraphQL Client with React but WITHOUT Apollo</h3>
          <pre><code class="javascript">
import React from "react";

function BlogListPage() {
  const [posts, setPosts] = React.useState([]);

  React.useEffect( () => {
    fetch("/graphql", {
      method: "POST",
      body: JSON.stringify({
        query:  "{ posts { id title } }"
      })
    })
    .then(res => res.json())
    .then(json => setPosts(res.data))
  }, [])

  if (!posts) { return "Please wait" }
  return &lt;PostList posts={posts} />;
}
          </code></pre>
          <p>Will this code work?</p>
          <p>What features are missing?</p>
          <p>What could be improved?</p>
        </section>

        <section>
          <h3>Apollo Client</h3>
          <p>
            <a href="https://www.apollographql.com/docs/react/"
              >https://www.apollographql.com/docs/react/</a
            >
          </p>
          <p>React Hooks (and components) to work with GraphQL backends</p>
          <p>
            Provides a <b>global cache</b> that ensures consistent presentation of data across your
            whole application
          </p>
        </section>
        <section>
          <h3>Apollo Client</h3>
          <p>
            The <code>ApolloClient</code> is a singleton, responsible for the communication with the
            backend
          </p>
          <p>
            It also manages the <b>cache</b>, <b>authentication</b>,
            <b>central error handling</b> and so on
          </p>

          <pre class="fragment"><code class="javascript">
import ApolloClient from "apollo-client";

const client = new ApolloClient({
  link: new HttpLink({uri: "http://..."}),
  cache: new InMemoryCache()
}};
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo Boost</h3>
          <p>Apollo Client is a modularized solution, can be hard to configure</p>
          <p>Apollo Boost provides a default configuration (with default modules etc)</p>
          <p>
            <a href="https://www.apollographql.com/docs/react/get-started/#apollo-boost"
              >Documentation</a
            >
          </p>

          <pre class="fragment"><code class="javascript">
// this example code is not much simpler, but
// it adds a lot of required dependencies
import ApolloClient from "apollo-boost";

const client = new ApolloClient({
  uri: "http://localhost:4000",
});

            </code></pre>
          <p class="fragment">
            For more sophisticated configurations, you need to
            <a href="https://www.apollographql.com/docs/react/migrating/boost-migration/"
              >migrate away</a
            >
            from Apollo Boost to Apollo Client.
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo Client</h3>
          <p>The Apollo Hooks needs access to the client object</p>
          <p>The Client object must be "provided" to your application (component hierarchy)</p>
          <p>Surround your own components on top-level with <code>ApolloProvider</code></p>

          <pre class="fragment"><code class="javascript">
import ApolloClient from "apollo-boost";
import { ApolloProvider } from "@apollo/react-hooks";

const client = ...;

ReactDOM.render(
  &lt;ApolloProvider client={client}>
    &lt;App />
  &lt;ApolloProvider>,
  document.getElementById("root")
);
</code></pre>
          <p class="fragment">
            Apollo Provider uses
            <a ref="https://reactjs.org/docs/context.html">React Context API</a> internally
          </p>
        </section>
        <section>
          <h3>Using GraphQL in your React Application</h3>
          <p>Live: exercises/graphql</p>
        </section>

        <section>
          <h3>Queries</h3>
          <p>
            Queries will be written in an external file or inline using the <code>gql</code> "tag
            function"
          </p>
          <p>The gql function returns a "document object" containing the parsed query</p>

          <pre><code class="javascript">
import { gql } from "apollo-boost";

const POST_LIST_QUERY = gql`
  query PostListQuery {
    posts {
      id
      title
      teaser(maxLength: 20)
      date
    }
  }
`;
</code></pre>

          <p class="fragment">
            Note: <a href="https://prettier.io">Prettier</a> can format the GraphQL code inside gql!
          </p>
          <p class="fragment">
            The TypeScript code generater uses the gql tag to find GraphQL queries in your source
            code
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useQuery: Execute a Query</h3>
          <p>The useQuery hook runs a query and provides the result and metadata</p>

          <pre><code class="javascript">
function BlogListPage() {
  const { loading, error, data } = useQuery(POST_LIST_QUERY);

  if (loading) {
    return <h1>Loading, please wait...</h1>;
  }

  if (error) {
    return <h1>GraphQL Failed: {error.toString()}</h1>;
  }

  return &lt;PostList posts={data.posts} />;
}
  
</code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Lifecycle of useQuery</h3>
          <ol>
            <li class="fragment">
              useQuery triggers your request and returns an object, where <code>loading</code> is
              set to true
            </li>
            <li class="fragment">
              Your component will be re-rendered and you can use loading to show user information
            </li>
            <li class="fragment">
              The response comes in, useQuery forces a re-rendering of your component
            </li>
            <li class="fragment">
              useQuery now returns either <code>error</code> or <code>data</code>, loading is false
              now
            </li>
            <li class="fragment">You can update your UI according to this information</li>
            <li class="fragment">If the request was successful, Apollo updates also the Cache</li>
            <li class="fragment">
              <em>All</em> visible components that receive data from the cache (using useQuery) are
              updated
            </li>
          </ol>
        </section>

        <section>
          <h3>useQuery: Variables</h3>
          <p>You can declare variables in your query.</p>
          <p>useQuery can receive an argument with options for a query</p>
          <p>With this object you can set your variables for a query</p>

          <pre class="fragment"><code class="javascript">
const POST_PAGE_QUERY = gql`
  query PostPageQuery($postId: ID!) {
    post(postId: $postId) {
      id  title date
      body user { name }
    }
  }
`;
</code></pre>
          <pre class="fragment"><code class="javascript">
function PostPage() {
  // Receive postId from URL params
  const { postId } = useParams();

  const { loading, error, data } = useQuery(POST_PAGE_QUERY,
    {
      variables: { postId }
    }
  );
  // ...
}
</code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useQuery: Control the Cache #1</h3>

          <p>
            If a component re-renders, by default useQuery <b>does not</b> executes the query
            <b>again</b>
            if it finds the result in it's internal cache
          </p>
          <p>👉 Let's inspect network requests when opening blog posts</p>
          <p class="fragment">
            We come back to this later!
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>The Apollo Cache</h3>
          <p><em>Apollo normalizes your data before putting it into the cache:</em></p>
          <p>
            For each object returned by a query (no matter what level), it extracts its
            <b>typename</b>
          </p>
          <p>
            The <code>__typename</code> is automatically added to all of your queries by Apollo!
          </p>
          <p>For each object returned by q query it extracts its <b>id</b></p>
          <p>
            If your <b>id</b> field is not <b>id</b>, you have to tell Apollo the name of your
            id-Field (e.g. primaryKey)
          </p>
          <p>
            <b>Recommandation:</b> <em>Always</em> include your id field in any object you query!
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Typesafe Queries with TypeScript</h3>

          <p>GraphQL APIs providing a Schema with objects, fields and types</p>
          <p class="fragment">
            useQuery can receive a type parameter that describes the query response and the
            variables
          </p>
          <p class="fragment">
            TypeScript then "knows" how the response looks and can provide code assistant and syntax
            checking
          </p>
          <p class="fragment">
            The types for a query can be genereated, using the
            <a href="https://github.com/apollographql/apollo-tooling">Apollo CLI</a>
          </p>
          <p class="fragment">
            👉Let's have a look how this works!
          </p>
          <ol class="fragment">
            <li>Run <code>npm run codegen:watch</code></li>
            <li>Change a Query in <code>PostListPage.tsx</code></li>
            <li>Inspect the generated types</li>
            <li>Change the schema</li>
          </ol>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Typesafe Queries with TypeScript</h3>
          <p>
            The type of the query response and the variables are specified using a type parameter on
            useQuery:
          </p>

          <pre><code class="javascript">
  function PostPage() {
    // ...
    const { loading, error, data } = 
      useQuery&lt;PostPageQuery, PostPageQueryVariables>
        (POST_PAGE_QUERY, { variables: { postId } });
    
    // ...
  }  
</code></pre>

          <p class="fragment">TypeScript ensures correct usage of the variables</p>
          <p class="fragment">
            You must check if data is not null, because <code>loading</code>, <code>error</code> and
            <code>data</code>
            are all optional
          </p>
          <p class="fragment">
            If loading is false and error is falsy, you know, data is available, but TypeScript does
            not know!
          </p>

          <pre class="fragment"><code class="javascript">
const { loading, error, data } = useQuery(...);

  if (loading) { return <h1>Loading, please wait...</h1>; }

  if (error) {return <h1>GraphQL Failed: {error.toString()}</h1>; }

  if (!data) { return <h1>Invalid response</h1> }

  // TypeScript now knows, data is set here
  // do something with data
</code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Exercise #2: Running a Query</h3>

          <p>
            Start the backend (if it's not already running): <br />
            <code>cd blog-example/backend-graphql</code><br />
            <code>npm install</code><br />
            <code>npm start</code>
          </p>

          <p class="fragment">Use folder: <b>advanced/exercises/6_graphql</b></p>

          <p>
            <code>npm install</code><br />
            <code>npm start</code>
          </p>
          <p>
            <em
              >Implement the <code><b>PostListPage</b></code> component</em
            >
            (TODOs in the file)
          </p>
          <p>
            After you change your GraphQL query with <code>gql</code> please run the code generator
            to generate the TypeScript code:<br />
            <code>npm run codegen:watch</code>
          </p>
        </section>

        <section>
          <h3>Apollo GraphQL: Mutations</h3>
          <p>Mutations can be used to modify data on the server</p>
          <p class="fragment">Running a Mutation is similiar to running a query</p>
          <p class="fragment">
            Hook:
            <a href="https://www.apollographql.com/docs/react/data/mutations/#executing-a-mutation"
              ><b>useMutation</b></a
            >
          </p>
          <p class="fragment">The useMutation hooks returns an array, consisting of two entries:</p>
          <p class="fragment">
            1. A function to actually run the mutation (e.g. after user interaction)
          </p>
          <p class="fragment">
            2. The result object as known from <code>useQuery</code> plus a <code>called</code> flag
          </p>

          <pre class="fragment"><code class="javascript">
function PostEditorPage() {
  const [mutate, { error, data, called }] = useMutation(NEW_BLOGPOST_MUTATION);

  async function savePost(post) {
    mutate({
      variables: {
        postData: post
      }
    });
  }
  
  const errorMessage = error ? ... : null;

  if (called && !errorMessage) {
    // Mutation has been executed and was successful
    return &lt;SuccessConfirmation />;
  }
  
  // Mutation hasn't been run or failed with an error
  return &lt;PostEditor onSavePost={savePost} error={errorMessage} />;
}
          </code></pre>
        </section>
        <section>
          <h3>Exercise #3: A Mutation</h3>
          <p>Implement the <code>PostEditorPage</code> component</p>
        </section>

        <section>
          <h3>Upating the Cache</h3>
          <p>Some strategies:</p>
          <ul>
            <li>
              <a
                href="https://www.apollographql.com/docs/react/api/react-apollo/#optionsfetchpolicy"
                >Fetch Policy</a
              >
            </li>
            <li>
              <a href="https://www.apollographql.com/docs/react/data/queries/#refetching"
                >Refetch function</a
              >
            </li>
            <li>
              <a href="https://www.apollographql.com/docs/react/data/queries/#polling"
                >Polling (every x ms)</a
              >
            </li>
            <li>
              Use the
              <a
                href="https://www.apollographql.com/docs/react/data/mutations/#making-all-other-cache-updates"
                >Cache API</a
              >
              to update the Cache after a Mutation
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Fetch Policy #1</h3>
          <p>
            Specify a Fetch Policy as option in <code>useQuery</code> that defines when a query is
            re-run after a rendering of your component
          </p>
          <pre class="fragment"><code class="javascript">
 function PostPage() {
  // Receive postId from URL params
  const { postId } = useParams();

  const { loading, error, data } = useQuery(POST_PAGE_QUERY,
    {
      variables: { postId },
      fetchPolicy: "network-only"
    }
  );
  // ...
} 
</code></pre>
        </section>
        <section>
          <h3>Fetch Policy #2</h3>
          <p>Allowed values</p>
          <ul>
            <li class="fragment">
              <b>cache-first</b>: If data is in the cache, use it, otherwise read from backend
            </li>
            <li class="fragment">
              <b>cache-and-network</b>: Use data from cache but always also execute backend request
              (fast response for user, but also newest data). Might flicker
            </li>
            <li class="fragment">
              <b>network-only</b>: Always run network request, don't use data from cache, but store
              received data in the cache
            </li>
            <li class="fragment">
              <b>no-cache</b>: Always run networt request, and also don't store data in the cache
            </li>
            <li class="fragment">
              <b>cache-only</b>: Only read data from cache. If data is not found in the cache, you
              don't get data
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Refetch function</h3>
          <p>
            <code>useQuery</code> returns a <b>refetch</b> function that you can invoke to
            re-execute the query
          </p>

          <pre class="fragment"><code class="javascript">
function BlogListPage() {
  const { loading, error, data, refetch } = useQuery(POST_LIST_QUERY);

  if (loading) {
    return <h1>Loading, please wait...</h1>;
  }

  if (error) {
    return <h1>GraphQL Failed: {error.toString()}</h1>;
  }

  return &lt;PostList posts={data.posts} onRefetch={refetch}/>;
}              
            </code></pre>

          <pre class="fragment"><code class="javascript">
function PostList({posts, onRefetch}) {
  return &lt;>
    &lt;button onClick={onRefetch}>Refresh Posts&lt;/button>
    ...
  &lt;/>
}  
</code></pre>
        </section>

        <section>
          <h3>Polling</h3>
          <p>
            You can specifiy a <code>pollInterval</code> as a query option. Apollo than executes the
            query every x milliseconds
          </p>
          <pre class="fragment"><code class="javascript">
function BlogListPage() {
  const { loading, error, data, refetch } = useQuery(POST_LIST_QUERY,
    { pollInterval: 1500 }
  );

  // ... as seen before
}              
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Updating Cache after a Mutation</h3>

          <ul>
            <li>
              <a href="https://www.apollographql.com/docs/react/data/mutations/#options"
                >refetch Queries</a
              >: You can specify a list of queries in <code>useMutation</code> that Apollo runs
              after the mutation
            </li>
            <li>Update the Cache manually (update-function)</li>
          </ul>
        </section>

        <section>
          <h3>After a Mutation... Cache might be updated</h3>
          <p class="fragment">
            If your mutation returns an object that is already in the cache, this object gets
            updated automatically
          </p>
          <p class="fragment">
            Example: You <b>update</b> an existing Blog Post and as the result of Mutation you
            receive the update blog post
          </p>

          <pre class="fragment"><code class="javascript">
const UPDATE_POST = gql`
  mutation {
    updateBlogPost(postId: "P1", newTitle: "...", newBody: "...") {
      id
      title
      body
    }
  }
`         
              </code></pre>
          <p class="fragment">Here Apollo can update the existing blog post (P1) in the cache</p>
        </section>

        <section>
          <h3>There are cases where Apollo can not update the cache</h3>
          <p>Example: you add a new item to a list</p>
          <p>Apollo does not know that the object you created belong to a list</p>
          <p>
            Example: you queried for Blog Posts. You run a mutation to add a new Blog Post. <br />
            Apollo does not know, that the new Blog Post belongs to the blog posts list
          </p>
        </section>

        <section>
          <h3>Cache API</h3>
          <p>You can query the contents of the Cache - using GraphQL!</p>
          <p>You can directly write contents to the cache</p>
        </section>

        <section>
          <h3>Example: Update the Cache</h3>
          <p>
            You can set an <b>update-Function</b> as an option for the <code>useMutation</code> hook
          </p>
          <p>
            This function is invoked by Apollo after the mutation received the response from your
            server
          </p>
          <p>The function receives the cache and the mutation response</p>
          <p>You can use the cache api to add the new object</p>

          <pre class="fragment"><code class="javascript">
const READ_POSTS_FROM_CACHE = gql`
  query ReadPosts {
    posts {
      id
    }
  }
`;

function PostEditorPage() {
  function savePost(post: NewBlogPost) {
    mutate({
       variables: {...},
       update: (cache, {data}) => {
         const { posts } = cache.readQuery({
          query: READ_POSTS_FROM_CACHE
        });
        cache.writeQuery({
          query: READ_POSTS_FROM_CACHE,
          data: { posts: posts.concat(data.newPost) }
        });
       }
      })
    }

    return ...;
}
</code></pre>
        </section>

        <section id="t-memo">
          <h3>Part VI</h3>
          <h1>Performance</h1>
        </section>

        <section>
          <h3>Performance</h3>
          <p>Where can the app become slow (or fast)?</p>
          <ul>
            <li class="fragment">
              Bundle-Size: Browser needs to download, parse and interpret your JavaScript.
              Bottlenecks might be: network performance, CPU
            </li>
            <li class="fragment">Runtime: unneccessary computations and re-renderings</li>
          </ul>
        </section>

        <section>
          <h3>Performance</h3>
          <p>Each time you change state, all components will be rerendered!</p>
          <p>There <em>might</em> be some re-renderings that are unneccessary and expensive</p>
          <pre class="fragment"><code class="javascript">
function PiCalculator() {
  const [name, setName] = React.useState("")
  const [digits, setDigits] = React.useState(10000);

  const pi = calculatePiWithDigits(digits); 

  return &lt;>
    &lt;input type="text" value={name} onChange={...} />
    &lt;input type="number" value={digits} onChange={...} />
    &lt;p>Pi is: {pi}&lt;/p>
  &lt;/>;

}            
          </code></pre>
          <ul>
            <li class="fragment">Each time you change a digit, pi is re-calculated: fine! 😊</li>
            <li class="fragment">Each time you change the name, pi is re-calculated: ouch! 😱</li>
          </ul>
        </section>

        <section>
          <h3>useMemo</h3>
          <p>useMemo lets you cache (memoize) a value across several renderings</p>
          <p>The first parameter specifies a function, that returns the value to be cached</p>
          <p>With the second paramter you specify dependencies, when the value should be rebuilt</p>
          <pre class="fragment"><code class="javascript">
function PiCalculator() {
  const [name, setName] = React.useState("")
  const [digits, setDigits] = React.useState(10000);

  // re-calculate pi only if digits have changed
  const pi = React.useMemo( () => calculatePiWithDigits(digits), [digits] );

  return &lt;>
    &lt;input type="text" value={name} onChange={...} />
    &lt;input type="number" value={digits} onChange={...} />
    &lt;p>Pi is: {pi}&lt;/p>
  &lt;/>;
}            
          </code></pre>
        </section>

        <section>
          <h3>A little Refactoring...</h3>
          <p>Let's move displaying and calculating Pi to its own component</p>

          <pre class="fragment"><code class="javascript">
            function PiDisplay({digits}) {
              const pi = calculatePiWithDigits(digits);
              return &lt;p>Pi is: {pi}&lt;/p>
            }             
          </code></pre>
          <p class="fragment">
            PiCalculator doesn't know anything about expensive calculations anymore:
          </p>
          <pre class="fragment"><code class="javascript">
            function PiCalculator() {
              const [name, setName] = React.useState("")
              const [digits, setDigits] = React.useState(10000);
            
              return &lt;>
                &lt;input type="text" value={name} onChange={...} />
                &lt;input type="number" value={digits} onChange={...} />

                &lt;PiDisplay digits={digits} />
              &lt;/>;
            
            }          
                    </code></pre>
          <p class="fragment">Again: expensive re-renderings! 😱</p>
        </section>

        <section>
          <h3>React.memo</h3>
          <p>
            Using React.memo you can create a wrapper around your component that avoids rerendings
            as long as all properties remain the same between two renderings:
          </p>

          <pre class="fragment"><code class="javascript">
            const PiDisplay = React.memo(function PiDisplay({digits}) {
              const pi = calculatePiWithDigits(digits);
              return &lt;p>Pi is: {pi}&lt;/p>
            })             
          </code></pre>
          <p class="fragment">
            (PiCalculator unchanged)
          </p>
          <p class="fragment">
            Another example might be a component that takes long to render (large table for
            example).
          </p>
          <p class="fragment">
            Note: All components that are rendered by PiDisplay (your memo'd component) are also NOT
            rerenderd!
          </p>
        </section>

        <section>
          <h3>React.memo</h3>
          <p>
            Using React.memo you can create a wrapper around your component that avoids rerendings
            as long as all properties remain the same between two renderings:
          </p>

          <pre class="fragment"><code class="javascript">
            const PiDisplay = React.memo(function PiDisplay({digits}) {
              const pi = calculatePiWithDigits(digits);
              return &lt;p>Pi is: {pi}&lt;/p>
            })             
          </code></pre>
          <p class="fragment">
            (PiCalculator unchanged)
          </p>
          <p class="fragment">
            Another example might be a component that takes long to render (large table for
            example).
          </p>
          <p class="fragment">
            Note: All components that are rendered by PiDisplay (your memo'd component) are also NOT
            rerenderd!
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Attention! Functions!</h3>
          <p>When you're using functions as properties (callbacks), also this functions change!</p>
          <div class="fragment">
            <p>Let's have a look at an enhanced PiCalculator example:</p>
            <pre><code class="javascript">
            function PiCalculator() {
              const [name, setName] = React.useState("")
              const [digits, setDigits] = React.useState(10000);

              function reset() { 
                // ...
              }
            
              return &lt;>
                &lt;input type="text" value={name} onChange={...} />
                &lt;input type="number" value={digits} onChange={...} />

                &lt;PiDisplay digits={digits} onResetClick={reset}/>
              &lt;/>;
            
            }    
          </code></pre>
          </div>
          <ul>
            <li class="fragment">
              Here <b>reset</b> is a <b>new function</b> each time the component is re-rendered!
            </li>
            <li class="fragment">
              The props check in memo'd PiDisplay is now more or less useless ( as the
              <code>onResetClick</code> changes on each rendering of the PiCalculator)
            </li>
            <li class="fragment">😧🤔</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useCallback</h3>
          <ul>
            <li class="fragment">
              With the <code>useCallback</code> hook we can create a "stale" (memoized) reference
              for a function
            </li>
            <li class="fragment">Same as <code>useMemo</code> but for functions</li>
            <pre class="fragment"><code class="javascript">
              function PiCalculator() {
                const [name, setName] = React.useState("")
                const [digits, setDigits] = React.useState(10000);
  
                const reset = React.useCallback(function reset() { 
                  // ...
                }, []);
              
                return &lt;>
                  &lt;input type="text" value={name} onChange={...} />
                  &lt;input type="number" value={digits} onChange={...} />
  
                  &lt;PiDisplay digits={digits} onResetClick={reset}/>
                &lt;/>;
              
              }    
            </code></pre>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Performance: Hints</h3>
          <p><em>Do not pre-optimize, optimize only when needed</em></p>
          <p class="fragment">Focus on your app code and architecture instead</p>
          <p class="fragment">
            You can find performance bootlenecks using your Browser tools and/or React Dev Tools
            (Profiler)
          </p>
          <p class="fragment">
            There are several ways of enhancing performance, for every problem there is a solution
          </p>
        </section>

        <section>
          <h2>That's all! 😊</h2>
          <h3>Thanks a lot for your participation!</h3>
          <h3>Good luck with React!</h3>
          <p>
            If you have question, don't hestitate to contact me:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
  </body>
</html>
