<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem;">
            <b>React Workshop</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Vorbereitung</span></h3>
            <p>
              <span class="transparent-bg"
                >git clone https://github.com/nilshartmann/react-training</span
              >
            </p>
            <p>
              <span class="transparent-bg">oder: git pull</span>
            </p>
          </div>
          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2021_07_05_react_redux_typescript.html</span>
            </p>
          </div>
        </section>
        <section>
          <img src="slides/images/Deckblatt_devmedia_Trainings.png" />
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center;">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px;">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
              <p>Alle Dienstleistungen <b>auch online!</b></p>
            </div>
            <div style="margin-left: 15px;">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px;"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ============================================================================= -->

        <section>
          <h2>Agenda</h2>
          <ul style="font-size: 85%;">
            <li class="fragment">
              <a href="#/t1">Testen von Anwendungen ("Klassisch" mit √úbungen)</a>
            </li>
          </ul>

          <p class="fragment">Eher Frage+Antwort, bzw. improvisiert</p>
          <ul>
            <li class="fragment">
              <a href="#/t-objekte"
                >Wie geht man mit komplexen Objekten oder sogar Arrays derselben in Hooks um?</a
              >
            </li>
            <li class="fragment" style="margin-top: 2rem;">
              <a href="#/t-cra">Anpassen von create-react-app</a>
            </li>
            <li class="fragment"><a href="#/t-projektstruktur">Projektstruktur</a></li>
            <li class="fragment"><a href="#/t-libs">Bibliotheken</a></li>
          </ul>
        </section>

        <section id="t-test">
          <h2>Testen von React Anwendungen</h2>
        </section>

        <section data-transition="slide none">
          <h2>Was testen wir?</h2>
          <ul>
            <li class="fragment">
              <b>UI-unabh√§ngige Logik</b> (zum Beispiel Backend Calls, Berechnungen etc.)
            </li>
            <li class="fragment">
              <b>Rendering</b> (Ist die Liste der Blog Posts korrekt? Sieht das Markup aus, wie wir
              uns das vorstellen?)
            </li>
            <li class="fragment">
              <b>Interaktionen</b> (funktionieren die Event Handler, die Callback-Funktionen, der
              Programmflu√ü etc.?)
            </li>
            <li class="fragment">
              <b>Verhalten im Browser</b> (z.B. korrekte, pixelgenaue Darstellung,
              Browser-spezifisches JavaScript, Arbeiten mit Browser-Technologie wie Titelzeile,
              Session Storage, Scrollbars etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a>)</em
            >
          </p>
          <p class="fragment">
            Vollst√§ndige Testl√∂sung f√ºr React (und andere):
          </p>
          <ul class="fragment">
            <li class="fragment">Test Runner</li>
            <li class="fragment">Specs/Assertions, Mocks</li>
            <li class="fragment">Code Coverage</li>
            <li class="fragment">"Snapshot testing"</li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Beispiel: Ein einfacher Testfall</h3>
          <pre><code class="javascript" contenteditable data-trim>// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code data-trim contenteditable>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code data-trim contenteditable>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>"Expectations" und "Matchers"</h2>
          <div class="fragment">
            <p>
              <code>expect()</code> liefert ein <em>Expectation</em> Objekt zur√ºck, das verschiede
              <em>Matcher</em> Funktionen bereitstellt:
            </p>
            <pre><code data-trim contenteditable>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div class="fragment">
            <p>Beispiele f√ºr Matchers</p>

            <pre><code data-trim contenteditable>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p class="fragment">
            <a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a>
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Funktionen</h2>
          <ul>
            <li class="fragment">
              <code>jest.fn()</code> erzeugt eine Mock-Funktion
              <pre><code data-trim contenteditable>// Gibt undefined zur√ºck, wenn die Mock-Funktion ausgef√ºhrt wird
const aMockFn = jest.fn();

const x = aMockFn("huhu"); // => undefined
expect(x).toBeUndefined();

expect(aMockFn).toHaveBeenCalled());
expect(aMockFn.toHaveBeenCalledWith("huhu"));
                      </code></pre>
            </li>

            <li class="fragment">
              Implementierung der Mock-Funktion kann als Parameter √ºbergeben:
              <pre><code data-trim contenteditable>
        const aMockFn = jest.fn( param => `Hello, ${param}` );
        
        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ausf√ºhren von Tests</h3>
          <ul>
            <li class="fragment">
              Mit <code>npm test</code> werden alle Tests ausgef√ºhrt:
              <ul>
                <li class="fragment">
                  In allen <code>__tests__</code>-Verzeichnissen (<b>alle!</b> Dateien darin werden
                  als Test-Datei interpretiert...)
                </li>
                <li class="fragment">Alle <code>*.test.*</code>-Dateien</li>
              </ul>
            </li>
            <li class="fragment">
              Test-Dateien werden √ºblicherweise in dasselbe Verzeichnis gelegt, in dem auch die zu
              testende Datei liegt oder in ein "__tests__"-Unterverzeichnis direkt darunter
            </li>
            <li class="fragment">
              Mehr Info:
              <a href="https://create-react-app.dev/docs/running-tests/#filename-conventions"
                >CRA Doku</a
              >
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>√úbung: Jest</h3>
          <ul>
            <li class="fragment">
              Wir arbeiten im Verzeichnis <code>blog-example/workspace-test</code>
            </li>
            <li class="fragment">
              Dort findest Du eine React-Anwendung, f√ºr die wir Tests entwickeln werden
            </li>
            <li class="fragment">
              Die Tests kannst Du ausf√ºhren mit <code>npm test</code> auf der Kommandozeile. Sobald
              Du √Ñnderungen im Workspace machst und speicherst, werden die Tests erneut ausgef√ºhrt
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <section>
          <h3>√úbung: Jest</h3>

          <p>Hintergrund: die <code>createPost</code>-Funktion</p>

          <p class="fragment">
            Die Funktion <code>createPost</code> erstellt aus einem <code>title</code> und
            <code>body</code>
            ein Blog-Post-Objekt:
          </p>

          <pre class="fragment"><code class="javascript">
            const post = createPost("Intro to Jest", "You will learn Jest here");
            // post:
            //  {
            //    title: "Intro to Jest",
            //    body: "You will learn Jest here"
            //  }  
          </code></pre>

          <p class="fragment">
            Wenn als einziger Parameter <code>null</code> √ºbergeben wird, liefert die Funktion null
            zur√ºck:
          </p>

          <pre class="fragment"><code class="javascript">
            const post = createPost(null);
            // post === null
          </code></pre>

          <p class="fragment">
            Zus√§tzlich kann der Funktion eine "Slug-Generator"-Funktion √ºbergeben werden. Diese
            Callback-Funktion wird von createPost verwendet, um eine Slug (f√ºr eine URL) zu
            erzeugen. Daf√ºr wird der Callback-Funktion der Post-Titel √ºbergeben. Die Funktion
            liefert dann einen Slug zur√ºck, der auch ins Post-Objekt aufgenommen wird:
          </p>
          <pre class="fragment"><code class="javascript">
           const post = createPost("Intro to Jest", "You will learn Jest here", 
                                   title => "/" + title.toLowerCase()
                                  );
            // post:
            //  {
            //    title: "Intro to Jest",
            //    body: "You will learn Jest here",
            //    slug: "/intro to jest"
            //  }  
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>√úbung: Jest</h3>
          <p><em>Implementiere Testf√§lle f√ºr die createPost-Funktion</em></p>
          <ol>
            <li class="fragment">
              Stelle sicher, dass beim Aufrufen mit zwei String-Parametern das korrekte Post-Objekt
              erzeugt wird
            </li>
            <li class="fragment">
              Stelle sicher, dass beim Aufruf mit einem Parameter (<code>null</code>) auch
              <code>null</code> zur√ºck geliefert wird
            </li>
            <li class="fragment">
              Schreibe eine Mock-Funktion f√ºr den Slug-Generator und rufe createPost damit auf.
              <ol>
                <li class="fragment">Stelle sicher, dass der Slug im Post-Objekt enthalten ist</li>
                <li class="fragment">
                  Stelle sicher, dass deine Generator-(Mock-)Funktion mit dem √ºbergebenen Post-Titel
                  aufgerufen wurde
                </li>
              </ol>
            </li>
          </ol>
        </section>

        <section>
          <h3>Testen von React Komponenten</h3>
          <h2>Nur rendern</h2>
        </section>

        <section>
          <h3>React Test Renderer</h3>
          <p>
            <a href="https://www.npmjs.com/package/react-test-renderer"
              >https://www.npmjs.com/package/react-test-renderer</a
            >
          </p>
          <p>Rendert React Komponenten in JSON Objekte (ohne DOM):</p>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';

const component = renderer.create(
  &lt;PostList posts={somePosts} />
);

console.log(component.toJSON());
            </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
        { type: 'div',
          props: {},
          children:  [
            { type: 'button', props: {}, children: [Object] },
            { type: 'article', props: [Object], children: [Object] },
            { type: 'article', props: [Object], children: [Object] }
          ]
        }
            </code></pre>
        </section>
        <section>
          <h3>"Snapshot Testing" mit Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> vergleicht ein erzeugtes JSON-Objekt mit
            einem gespeicherten JSON-Objekt aus einer Datei:
          </p>
          <ul>
            <li class="fragment">
              Bei der <b>ersten</b> Ausf√ºhrung: Snapshot-Datei wird angelegt (
              <a href="slides/images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
              <ul>
                <li class="fragment">Die Snapshot-Datei wird nun in Git eingecheckt</li>
              </ul>
            </li>
            <li class="fragment">
              In den <b>folgenden</b> Test Ausf√ºhrungen: ein neuer Snapshot wird jeweils erzeugt und
              mit dem <b>gespeicherten</b> Snapshot verglichen
            </li>
            <li class="fragment">
              Wenn die Snapshots nicht identisch sind:
              <ul>
                <li class="fragment">
                  Fehler mit Unterschieden (
                  <a href="slides/images/jest-snapshot-diff.png" target="_blank">Beispiel</a>)
                </li>
                <li class="fragment">
                  Im "watch mode" von Jest kann der Snapshot aktualisiert werden
                  <img src="slides/images/jest-snapshot-update.png" />
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Snapshot Tests mit Jest und React</h3>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
        
test('it should render correctly', () => {

  const somePosts = [ . . . ];

  const component = renderer.create(
    &lt;PostList posts={somePosts} />
  );

  expect(component.toJSON()).toMatchSnapshot();
});
            </code></pre>
        </section>

        <section>
          <h3>Testing React Components #2</h3>
          <h2>Interaktionen</h2>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage good testing
              practices."
            </em>
          </p>

          <p>
            <a href="https://github.com/testing-library/react-testing-library" target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophie: Tests werden aus User-Perspektive geschrieben. Das bedeutet, um die zu
            testenden Elemente zu finden, suchst Du nach Eigenschaften, nach denen auch ein User
            suchen w√ºrde (z.B. Labels, Placeholder etc.)
          </p>
          <p class="fragment">üëâ <code>workspace-typescript</code></p>
        </section>

        <section>
          <h3>Die render-Funktion</h3>
          <p>
            Die render-Function aus der react-testing-library wird im Test verwendet, um eine React
            Komponente (ohne Browser) zu rendern
          </p>
          <p>
            Genauso wie in der Anwendungen k√∂nnen Properties angegeben werden
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            import { render } from "@testing-library/react";

              // Render a single component
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
          </code></pre>
          <p class="fragment">
            Dran denken, ggf. Contexte ebenfalls zu erzeugen, falls diese ben√∂tigt werden (React
            Router, Redux etc)!
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>

              // Render with surrounding Redux Provider (or Router, your own Context etc.)
              render(
                &lt;Provider>
                  &lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />
                &lt;/Provider>
              );
            </code></pre>
        </section>
        <section>
          <h3>query Funktionen</h3>
          <p>
            Um die gerenderten HTML-Elemente aus deiner Komponente zu √ºberpr√ºfen und mit ihnen zu
            interagieren, musst Du sie ersteinmal finden ü§ì
          </p>
          <p>
            Auf dem globalen <b>screen</b> Objekt der Testing-Lib sind verschiedene Funktionen
            definiert, mit denen Du nach Elementen suchen kannst
          </p>
          <p>
            Die query-Funktionen haben unterschiedliche <b>Suffixe</b>, die beschreiben,
            <b>nach welchem Kriterium</b> Du suchst (nach Label, nach aria-role, ...)
          </p>
          <p>
            Die Funktionen haben au√üerdem jeweils einen <b>Pr√§fix</b> (getBy, queryBy etc) der
            beschreibt, die Art des R√ºckgabewerts der jeweilgen Funktion (z.B. ob sie einen Error
            wirft oder null zur√ºckgibt, wenn das angefragte Element nicht gefunden wurde)
          </p>
          <p>
            Mehr zu den query-Funktionen:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre class="fragment"><code class="javascript">
  // BEISPIELE: 

  // suche nach einem Button (Annahme: es gibt GENAU EINEN, ansonsten schl√§gt der Test fehl)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt null oder EINEN Button, wirft ansonst einen Fehler)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt alle gefunden zur√ºck oder ein leeres Array)  
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>√úberpr√ºfen von Elementen</h3>
          <p>
            Wenn Du dein gesuchtes Elemente gefunden hast, kannst Du es √ºberpr√ºfen, ob es deinen
            Erwartungen entspricht (korrekte Attribute gesetzt etc.)
          </p>
          <p>
            Die Bibliothek
            <a href="https://github.com/testing-library/jest-dom" target="_blank">jest-dom</a> f√ºgt
            dazu DOM-spezifiche Matcher f√ºr Jest hinzu.
          </p>

          <pre class="fragment"><code class="javascript">
  import { screen } from "@testing-library/react";

  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // stellt sicher, dass das Element im DOM vorhanden ist (getBy-Query w√ºrde hier vielleicht mehr Sinn machen)
  expect(buttonElement).toBeInTheDocument();

  // sicherstellen, dass ein Eingabefeld einen erwarteten Wert hat
  expect(titleInput).toHaveValue("Moin moin");

  // sicherstellen, dass ein Button disabled ist
  expect(okButton).toBeDisabled();
</code></pre>
          <p class="fragment">
            Alle Matcher sind auf der oben verlinkten GitHub Seite dokumentiert
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Playground: Browser-Plugin</h3>
          <p>
            Es gibt Browser-Plugins f√ºr Chrome und Firefox, mit denen Du Queries ausprobieren
            kannst:
          </p>
          <ul>
            <li class="fragment">
              <a href="https://addons.mozilla.org/de/firefox/addon/testing-playground/">Firefox</a>
            </li>
            <li class="fragment">
              <a
                href="https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano"
                >Chrome</a
              >
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Debugging</h3>

          <p>Du kannst den gerenderten DOM mit <code>prettyDOM</code> ausgeben:</p>

          <pre class="fragment"><code class="javascript">
import { prettyDOM, render } from "@testing-library/react";

test('...', () => {
  render(&lt;MyComponent />);

  console.log(prettyDOM());
});

  </code></pre>

          <p class="fragment">
            Du kannst alle aria-Rollen eines Elementes mit <code>logRoles</code> ausgeben:
          </p>

          <pre class="fragment"><code class="javascript">
import { logRoles, render } from "@testing-library/react";

test('...', () => {
  const result = render(&lt;MyComponent />);

  logRoles(result.baseElement);

});     
   </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>√úbung: Starten der Anwedung</h3>

          <p>
            <em
              >Wir brauchen zum Testen keine laufende Anwendung, wir starten sie aber gemeinsam,
              damit ihr sie ausprobieren k√∂nnt, und wisst, was ihr √ºberhaupt testet</em
            >
          </p>

          <ol>
            <li class="fragment">
              Schritt 1: REST-Backend, dazu bitte ein Terminal/eine Shell im Verzeichnis
              <code>blog-example/backend-rest</code> √∂ffnen
            </li>
            <li class="fragment"><code>npm install</code> ausf√ºhren</li>
            <li class="fragment"><code>npm start</code> ausf√ºhren</li>
            <li class="fragment">
              Schritt 2: React-Anwendung, dazu bitte ein Terminal/eine Shell im Verzeichnis
              <code>blog-example/workspace-test</code> √∂ffnen
            </li>
            <li class="fragment"><code>npm install</code> ausf√ºhren</li>
            <li class="fragment"><code>npm start</code> ausf√ºhren</li>
            <li class="fragment">
              Die Anwendung sollte jetzt auf
              <a href="http://localhost:3000">http://localhost:3000</a> laufen
            </li>
          </ol>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>√úbung: Rendern von Komponenten und √úberpr√ºfen von Elementen</h3>

          <p><em>Schreibe Tests f√ºr die PostList-Komponente</em></p>
          <ol>
            <li class="fragment">
              In der Datei <code>__tests__/PostEditor.test.ts</code> stehen TODOs f√ºr Testf√§lle
            </li>
            <li class="fragment">
              Mit <code>npm test PostEditor</code> kannst Du die Ausf√ºhrung der Tests auf diese
              Datei beschr√§nken.
            </li>
          </ol>
        </section>

        <section>
          <h3>Interaktionen</h3>
          <p>
            Du kannst mit den Elementen interagieren, in dem Du ihnen Events sendest, genau wie es
            ein Browser tun w√ºrde
          </p>
          <p>
            Es gibt eine weitere Bibliothek,
            <a href="https://github.com/testing-library/user-event" target="_blank"> user-event</a>,
            die dir dabei hilft, die Events zu erzeugen.
          </p>

          <pre class="fragment"><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // Simuliert die Eingabe in ein Textfeld
            userEvent.type(titleInput, "New Title");

            // Simuliert den Klick auf einen Button
            userEvent.click(clearButton);
          </code></pre>
          <p class="fragment">
            Alle Events sind in der
            <a href="https://testing-library.com/docs/ecosystem-user-event/">Dokumentation</a>
            beschrieben (Link oben)
          </p>

          <p class="fragment">
            Vor dem Versenden eines Events musst Du <b>nicht</b> √ºberpr√ºfen, ob das Element, dem Du
            das Event senden willst, vorhanden ist. Die Bibliothek gibt sehr sprechende Fehler aus,
            wenn das Element nicht vorhanden ist
          </p>
        </section>
        <section>
          <h3>Testen von fetch-Aufrufen</h3>
          <p>Herausforderungen:</p>
          <ul>
            <li class="fragment">Asynchroner Code (nicht beschr√§nkt auf fetch)</li>
            <li class="fragment">Server Zugriffe/Server Mocks</li>
          </ul>
        </section>
        <section>
          <h3>Behandlung von asynchronem code</h3>
        </section>

        <section>
          <h3>Testen von asynchronem Code</h3>
          <p>
            Beispiel: Die <b>App</b> Komponente l√§dt Daten, <em>erst dann</em> stellt sie die
            PostList dar. Das Laden der Posts ist asynchron.
          </p>

          <pre class="fragment"><code class="javascript">
            it("should render posts read from backend", () => {
              render(&lt;App />);
            
              // Annahme: es gibt einen Artikel mit dem Title "Learning React"
              const articleOne = screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
            });
          </code></pre>
          <p class="fragment">
            Wir k√∂nnen einen Test als async-funktion schreiben und darin mit <b>await</b> auf ein
            Element warten
          </p>
          <pre class="fragment"><code class="javascript">
            // Test-Funktion als async-Funktion (beachte 'async'):
            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // Beachte await hier:
              const articleOne = await screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
            });
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testen von fetch</h3>
          <p>Wie gesehen, k√∂nnen wir asynchronen Code testen</p>
          <p class="fragment">Wollen wir fetch-Aufrufe in unserem Code haben, den wir testen?</p>
          <p class="fragment">
            M√∂glicherweise nicht, weil wir bei echten fetch-Aufrufen auch einen echten, laufenden
            und funktionierenden Server im Test br√§uchten
          </p>
          <p class="fragment">Stattdessen wollen wir das "echte" fetch mocken</p>
        </section>

        <section>
          <h3>Ansatz #1: fetch API mocken</h3>
          <p>Es gibt mehrere Bibliothken mit fetch-Mocks</p>
          <p>
            F√ºr mich funktioniert
            <a href="https://www.npmjs.com/package/jest-fetch-mock" target="_blank"
              >jest-fetch-mock</a
            >
            am Besten
          </p>

          <pre class="fragment"><code class="javascript">
            // App.test.tsx
            it("should render posts read from backend", async () => {
              // setzen des Ergebnisses, das der n√§chste fetch-Aufruf zur√ºckliefern soll
              fetchMock.mockResponse(JSON.stringify(mockPosts));

              render(&lt;App />);
            
              // Immer noch asynchroner Code, aber kein "echter" fetch-Aufruf mehr,
              // zur√ºckgegeben wird das oben angegebene Ergebnis
              const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

              expect(articleOne).toBeInTheDocument();
            });

          </code></pre>
          <p class="fragment">
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_jest_mock.test.tsx</code
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ansatz #2: Mock Service Worker (MSW)</h3>

          <p><a href="https://github.com/mswjs/msw" target="_blank">MSW</a></p>
          <p>
            MSW mockt echte Server-Aufrufe mit einem
            <a href="https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API"
              >Service Worker</a
            >
          </p>
          <p>
            fetch-Aufrufe werden "richtig" ausgef√ºhrt, aber beantwortet von dem Service Worker Mock
          </p>

          <pre class="fragment"><code class="javascript">
            // PostList.test.js
            import { rest } from 'msw'
            import { setupServer } from 'msw/node'
            
            const server = setupServer(
              rest.get('/posts', (req, res, ctx) => {
                return res(ctx.json( mockPosts ))
              }),
            )

            test("it should render blog list", async () => {
              render(&lt;PostList />);
              // ...
            })
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>√úbung: FetchMock</h3>

          <p>
            <em
              >Schreibe einen Test, um die App-Komponente zu testen und mocke dabei die
              fetch-Funktion</em
            >
          </p>

          <ol>
            <li class="fragment">
              Die Test-Datei ist <code>App.test</code>, darin sind TODOs enthalten
            </li>
            <li class="fragment"><code>npm test App.test</code>, um den Test auszuf√ºhren</li>
          </ol>
        </section>

        <section>
          <h3>Fetch mocken, Ansatz #3</h3>
          <p>Wir k√∂nnen <b>komplette Module</b> in Jest mocken</p>
          <p class="fragment">
            Wir k√∂nnten unseren fetch-Code in ein eigenes Modul schieben und das dann mocken
          </p>

          <pre class="fragment"><code class="javascript">
            // api.ts (fetch vereinfacht!)
            export function readPosts() {
              return fetch("http://localhost:7000/posts").then(response => response.json());
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // App.tsx:

            import { readPosts } from "./api";
            function App() {
              // ...
              React.useEffect(() => {
                // Verwenden von readPosts hier:
                readPosts()
                  .then(json => {
                    setLoading(false);
                    setPosts(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            }
          </code></pre>
        </section>
        <section>
          <h3>Mocken von Modulen in Jest</h3>
          <p>Es gibt mehrere Varianten. Das hier die einfachste(?)</p>

          <pre class="fragment"><code class="javascript">
            // App.test.tsx

            const mockPosts = [
              { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
              { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
            ];

            jest.mock("../api", () => ({
              readPosts: () => Promise.resolve(mockPosts)
            }));

            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // Hier immer noch asnychroner Code (deswegen await), aber:
              // kein laufender Server mehr ben√∂tigt
              const articleOne = await screen.findByRole("heading", { name: "One" });
              expect(articleOne).toBeInTheDocument();

              expect(screen.getByText("Second Post")).toBeInTheDocument();
            });
          </code></pre>
          <p class="fragment">
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_module_mock.test.tsx</code
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>√úbung: Module mit Jest mocken</h3>

          <p><em>Schreibe ein gemocktes Modul f√ºr das Laden von Blog-Posts</em></p>

          <ol>
            <li class="fragment">
              Die Test-Datei ist <code>App-with-mock.test</code>, darin sind TODOs enthalten
            </li>
            <li class="fragment"><code>npm test App-with-mock</code>, um den Test auszuf√ºhren</li>
          </ol>
        </section>

        <!-- <section>
          <h2>√úbung: Ein Test f√ºr den PostEditor</h2>
          <p>Schritte:</p>
          <ol>
            <li class="fragment">Arbeite in <code>blog-example/workspace-typescript</code></li>
            <li class="fragment">
              Starte in einem neuen Terminal <code>npm test</code> (der Prozess l√§uft "ewig")
            </li>
            <li class="fragment">
              Es sollte einen fehlerhaften Test geben:
              <b><code>PostEditor.test.tsx</code></b
              >.
            </li>
            <li class="fragment">Warum? Weil der noch leer ist üò¨!</li>
            <li class="fragment">
              Implementiere den fehlenden Test. In der Datei<b><code>PostEditor.test.tsx</code></b>
              stehen TODOs daf√ºr
            </li>
          </ol>
          <p class="fragment">
            Hinweis: wenn Du die Datei speicherst, werden die Tests automatisch neu ausgef√ºhrt
            (solange Du
            <code>npm test</code> noch laufen hast), ansonsten kannst Du "a" auf der Kommandozeile
            dr√ºcken, zum erneuten Ausf√ºhren der Tests.
          </p>
          <p class="fragment">M√∂gliche L√∂sung in <code>steps/6-test</code></p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</p>
        </section> -->

        <section>
          <h2>Browser Tests</h2>
          <p>H√§ufig eingesetzt:</p>
          <ul>
            <li class="fragment">
              <a href="https://www.selenium.dev/">Selenium - The "classic"</a>
            </li>
            <li class="fragment">
              <a href="https://devexpress.github.io/testcafe/" target="_blank">TestCafe</a> (mit
              Support f√ºr sehr viele Browser, u.a. auch Cloud-Service
              <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>
            </li>
            <li class="fragment"><a href="https://www.cypress.io/" target="_blank">Cypress</a></li>
          </ul>
          <p class="fragment">
            In TestCafe und Cypress werden die Tests in JavaScript/TypeScript geschrieben, Selenium
            gibt's f√ºr mehrere Sprachen
          </p>
        </section>

        <!-- ============================================================================= -->
        <section id="t-objekte">
          <h3>Wie geht man mit komplexen Objekten oder sogar Arrays derselben in Hooks um?</h3>

          <p class="fragment">It depends...</p>
          <p class="fragment">K√∂nnen wir konkrete Beispiele finden und besprechen?</p>
        </section>

        <!-- ============================================================================= -->
        <section id="t-cra">
          <h3>Anpassen von create-react-app</h3>

          <ol>
            <li class="fragment">
              Ist es m√∂glich eine L√∂sung mit "npx create-react-app my-app --template typescript" zu
              erstellen und anschlie√üend Anpassungen an die Webpack Konfiguration vorzunehmen? Mir
              ist n√§mlich aufgefallen, dass mit diesem Befehl ein Modul "react-scripts" (oder so
              √§hnlich) geladen wird, worin sich vermutlich die Konfigurationen verstecken und wir
              somit da nicht so einfach etwas √§ndern k√∂nnen.
            </li>
            <li class="fragment">
              Wir haben n√§mlich tats√§chlich selten bis gar nicht eine reine React-App, sondern
              betten diese fast immer auf bestehenden Seiten ein.
            </li>
            <li class="fragment">Was m√∂chtet ihr denn anpassen?</li>
          </ol>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Anpassen von create-react-app</h3>
          <ul>
            <li class="fragment">
              Relativ starr, was Anpassungen angeht. Prinzip: kein Support f√ºr alles M√∂gliche,
              sondern eine Konfiguration, die auch funktioniert
            </li>
            <li class="fragment">
              Konfiguration befindet sich in
              <a
                href="https://github.com/facebook/create-react-app/tree/main/packages/react-scripts"
                >react-scripts</a
              >, dieses Modul kann bei Bedarf aktualisiert werden, ohne den Rest des Projekts zu
              beeinflussen
            </li>
            <li class="fragment">
              Es gibt "templates" (z.B. typescript), mit denen kann man das generierte Projekt
              anpassen, leider aber nicht die Konfiguration üò¢
            </li>
          </ul>
        </section>

        <section>
          <h3>create-react-app: Anpassungen</h3>
          <p>
            <em
              >"Anpassungen" beziehen sich in der Regel auf Anpassungen der
              Webpack-Konfiguration</em
            >
          </p>
          <ol>
            <li class="fragment">
              <b>eject</b>: L√∂st das react-scripts-Modul auf und kopiert alle Skripte direkt in
              Euren Workspace. Ihr k√∂nnt sie frei anpassen, seid aber von Updates in react-scripts
              abgekoppelt. Das ist die "offizielle" L√∂sung.
            </li>
            <li class="fragment">
              <a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a>: Damit
              k√∂nnt ihr einzelne Konfigurationen anpassen. Fraglich, wie gut das funktioniert, weil
              create-react-app solche Anpassungen "offiziell" nicht vorsieht. An dieser Idee sind
              schon andere Tools gescheitert.
            </li>
            <li class="fragment">
              Ihr forkt das
              <a
                href="https://github.com/facebook/create-react-app/tree/main/packages/react-scripts"
                >create-react-app-Repo</a
              >
              und baut Eure eigene Version von react-scripts. Dann seid ihr zwar auch von
              offiziellen Releases entkoppelt, aber k√∂nnt per Git immerhin die √Ñnderungen
              nachvollziehen und ggf. zu euch mergen
            </li>
          </ol>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>create-react-app: Alternativen</h3>

          <ol>
            <li class="fragment"><a href="https://nx.dev/react">NX</a></li>
            <li class="fragment">
              <a href="https://neutrinojs.org/packages/react/">NeutrinoJS</a>
            </li>
          </ol>

          <ul class="fragment">
            <li class="fragment">Beide viel mehr Features als create-react-app</li>
            <li class="fragment">
              NX m√∂glicherweise weiter verbreitet als NeutrinoJS und auch aktivere Entwicklung
            </li>
            <li class="fragment">Beide haben auch Support f√ºr Libraries und Mono-Repos</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section id="t-projektstruktur">
          <h3>Projektstruktur</h3>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Projekt-Struktur</h3>
          <p><a href="https://react-file-structure.surge.sh/">React File Structure</a></p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Grunds√§tzliches Prinzip: Colocation</h3>

          <ul>
            <li class="fragment">
              Colocation bedeutet, Dinge die zusammengeh√∂ren, sind auch zusammen
            </li>
            <li class="fragment">
              Das betrifft Source-Code, Tests, CSS etc.
            </li>
            <li class="fragment">
              Das ist ein Grundprinzip von React (z.B. auch: keine Trennung zwischen Template und
              Logik/Model in einer Komponente)
            </li>
            <li class="fragment">
              Man kann z.B. mehrere Komponenten in eine Datei tun, aber nur eine Komponente
              √∂ffentlich exportieren. Dann sind die anderen Komponenten Implementierungsdetails.
              Wenn man daran was √§ndern muss, muss man aber nicht in diversen Dateien suchen

              <pre class="fragment"><code class="javascript">
                function BlogTitle() { ... }

                export default function BlogPost() {
                  return &lt;article>
                    &lt;BlogTitle />
                    ...
                  &lt;/article>  
                }
              </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Projekt-Struktur: Verzeichnisse</h3>

          <ul>
            <li class="fragment">
              Im Zweifel: eher ein Verzeichnis/eine Verzeichnis-Ebene weniger, als mehr (das ist
              zumindest in Java mit Packages anders)
            </li>
            <li class="fragment">
              In Verzeichnissen nach Fachlichkeit gruppieren (z.B. "blog", "user", "security")
            </li>
            <li class="fragment">
              Ggf. ein Verzeichnis "components" oder "ui", in dem √ºbergreifenden Komponenten
              abgelegt werden
            </li>
            <li class="fragment">
              Ein "Fach-Verzeichnis", enth√§lt wiederrum alles, was zu der Fachlichkeit geh√∂rt
              (Komponenten, Hooks, TS Types etc.)
            </li>
            <li class="fragment">
              Ein "Fach-Verzeichnis" w√§re prinzipiell ein Kandidat zur Extraktion in eine Bibliothek
            </li>
          </ul>

          <img src="slides/images/verzeichnisstruktur.png" />
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Verzeichnisse: absolute Importe</h3>

          <ul>
            <li class="fragment">
              Ihr k√∂nnt in der <code>tsconfig.json</code>-Datei einen "Base-Pfad"
              (<code>baseUrl</code>) einstellen, z.B. auf <code>src/</code>
            </li>
            <li class="fragment">
              Alle Verzeichnisse und Dateien darunter k√∂nnen dann "absolut" importiert werden:

              <pre class="fragment"><code class="javascript">
                // src/blog/BlogPage.tsx
                import Button from "components/Button";

                // src/user/PasswordForm.tsx
                import Button from "components/Button";
              </code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>index.tsx als "Fassade"</h3>

          <ul>
            <li class="fragment">
              Jeder fachliche Teil in Eurer Anwendung ist in einem eigenen Verzeichnis
            </li>
            <li class="fragment">
              Jedes Verzeichnis hat eine index.tsx-Datei, die die √∂ffentlichen Teile exportiert
            </li>
            <li class="fragment">
              Damit ist festgelegt, welche Teile sichtbar sind f√ºr andere und welche nicht
            </li>

            <li class="fragment">
              Beim importieren reicht es als Quelle ("from ...") den Verzeichnisnamen anzugeben!
            </li>

            <li class="fragment">
              Achtung: Code-Splitting bzw. dynamische Importe funktionieren nur mit Default Exports
            </li>
            <li class="fragment">
              Achtung: Kann man erzwingen, dass man nur aus index.tsx importiert? Vielleicht mit
              <a
                href="https://github.com/import-js/eslint-plugin-import/blob/master/docs/rules/no-internal-modules.md"
                >ES Lint Rule</a
              >?
            </li>
            <li class="fragment">
              Hat auch den Vorteil, dass ihr innerhalb des Verzeichnisses umorganisieren k√∂nnt, und
              nur die index.ts(x)-Datei entsprechend anpassen m√ºsst
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            // blog/index.ts
            export default BlogPage from './BlogPage';
 </code></pre>
          <pre class="fragment"><code class="javascript">
            // src/index.tsx
            import BlogPage from "./blog";
          </code></pre>

          <p class="fragment">Beispiel: Komponenten</p>
          <pre class="fragment"><code class="javascript">
            // components/index.ts
            export Button from './Button';
            export Header from './Header';
 </code></pre>
          <pre class="fragment"><code class="javascript">
            // src/blog/BlogPage.tsx
            // (mit absolutem Pfad)
            import { Button } from "blog";
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section id="t-libs">
          <h3>(Komponenten-)Bibliotheken</h3>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Bibliotheken: Herausforderungen</h3>

          <ul>
            <li class="fragment">Code muss compiliert werden (Babel und/oder TypeScript)</li>
            <li class="fragment">Code muss gebundelt werden (Webpack, Rollup, Parcel)</li>
            <li class="fragment">
              Bibliothek muss anderen zur Verf√ºgung gestellt werden (npm Registry)
            </li>
            <li class="fragment">
              Bereitstellen von Sourcen (TypeScript, CSS) f√ºr Verwender der Bibliothek zum Debugen
            </li>
            <li class="fragment">Workflow: wie k√∂nnt ihr die Bibliothek testen/ausprobieren?</li>
            <li class="fragment">
              Workflow: wie k√∂nnt ihr die √Ñnderungen in den verwendenden Anwendungen testen bzw.
              dort einbinden
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ausgangssituation</h3>
          <ul>
            <li class="fragment">
              Der Code, der als Bibliothek zur Verf√ºgung gestellt werden soll, liegt in einem
              eigenen Projekt vor
            </li>
            <li class="fragment">
              Das kann ein eigenes Repository sein, oder ein Verzeichnis in einem bestehenden
              Repository
            </li>
            <li class="fragment">Er ist aber nicht Bestandteil einer bestehenden App</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Bibliotheken: npm Module</h3>
          <ul>
            <li class="fragment">
              npm-Module k√∂nnen in einer npm-Registry ver√∂ffentlicht werden
              <ul>
                <li class="fragment">
                  √∂ffentliche
                  <a href="https://docs.npmjs.com/cli/v7/using-npm/registry">NPM Registry </a>
                </li>
                <li class="fragment">
                  <a href="https://github.com/features/packages">GitHub Packages</a>
                </li>
                <li class="fragment">
                  <a href="https://help.sonatype.com/repomanager3/formats/npm-registry">Nexus</a>
                </li>
                <li class="fragment">
                  <a href="https://www.jfrog.com/confluence/display/JFROG/npm+Registry"
                    >Artifactory</a
                  >
                </li>
                <li class="fragment">
                  <a href="https://verdaccio.org/">Verdaccio</a> (leichtgewichtige
                  Open-Source-L√∂sung)
                </li>
                <li class="fragment">
                  <a href="https://www.pluralsight.com/guides/install-npm-packages-from-gitgithub"
                    >Direkt aus Git(Hub)</a
                  >
                </li>
              </ul>
            </li>
            <li class="fragment">
              Ver√∂ffentlichen bedeutet im Wesentlichen, das ein Verzeichnis mit Dateien und eine
              package.json-Datei in ein Respository hochgeladen wird
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Naiver Ansatz: Source-Dateien ver√∂ffentlichen</h3>

          <ul>
            <li class="fragment">
              Ihr stellt einfach Euer React-Projekt als npm-Modul zur Verf√ºgung
            </li>
            <li class="fragment">
              Die Verwender m√ºssen sich dann um das compilieren und bundlen k√ºmmern
            </li>
            <li class="fragment">
              Insb. f√ºr das compilieren ist es evtl. notwendig beim Verwenden die Konfiguration
              anzupassen, da Dateien im <code>node_modules</code>-Ordner nicht compiliert werden
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Typischer Ansatz: "Fertigen" Code publizieren</h3>
          <ul>
            <li class="fragment">
              Ihr setzt ein Projekt f√ºr die Lib auf, in dem ihr auch Compiler- und Bundler
              konfiguriert
            </li>
            <li class="fragment">
              F√ºr Bibliotheken wird oftmals <a href="https://rollupjs.org/guide/en/">Rollup</a> oder
              <a href="https://parceljs.org/">Parcel</a> verwendet.
              <a href="https://webpack.js.org/guides/author-libraries/">Webpack</a> geht nat√ºrlich
              auch, mit den anderen Ans√§tzen aber evtl. leichter
            </li>
            <li class="fragment">Der compilierte und gebundlete Code wird dann publiziert</li>
            <li class="fragment">
              Ihr m√ºsst entscheiden, ob ihr als Ziel ES-Modulsystem oder CommonJS verwendet (oder
              beides). F√ºr interne Bibliotheken reicht vermutlich ES-Modulsystem
            </li>
            <li class="fragment">
              Falls ihr Sass oder LESS oder CSS Modules verwendet, m√ºsst ihr das im Build nat√ºrlich
              auch nach CSS √ºbersetzen
            </li>
            <li class="fragment">
              Ihr k√∂nnt im Build Source-Maps (f√ºr JS, TS und CSS) erzeugen, damit ihr beim Verwenden
              debuggen k√∂nnt
            </li>
            <li class="fragment">
              Achtung! Einbinden der Source-Maps erfordert bei TS leider einen extra
              <a href="https://webpack.js.org/loaders/source-map-loader/">SourceMap Loader</a> in
              Webpack, der in der aktuellen create-react-app-Version leider nicht konfiguriert ist.
              Der entsprechende
              <a href="https://github.com/facebook/create-react-app/pull/8227"
                >PR ist aber gemerged</a
              >
              und m√ºsste in der n√§chsten Version von create-react-app vorhanden sein üôè
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Workflow</h3>
          <ul>
            <li class="fragment">Ihr entwickelt die Bibliothek in ihrem Repository</li>
            <li class="fragment">
              Testen k√∂nnt ihr die Komponenten z.B. in dem ihr
              <a href="https://storybook.js.org/">Storybook</a> verwendet. Damit k√∂nnt ihr auch
              dokumentieren
            </li>
            <li class="fragment">Neue Releases k√∂nnt ihr mit <code>npm publish</code> erstellen</li>
            <li class="fragment">
              Die verwendenden Anwendungen k√∂nnen mit <code>npm install</code> die neue Version
              installieren
            </li>
            <li class="fragment">(Statt npm geht nat√ºrlich auch yarn)</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Workflow: Optimierung</h3>

          <ul>
            <li class="fragment">
              Mit <a href="https://classic.yarnpkg.com/en/docs/cli/link/">yarn link</a> k√∂nnt ihr
              die Bibliothek testweise in einer lokalen Anwendung einbinden, ohne sie vorher
              publizieren zu m√ºssen (k√ºrzere Turn-around-Zeiten). Leider etwas instabil der Ansatz
            </li>
            <li class="fragment">
              Mono-Repo-Ansatz 1: alle Bibliotheken und alle Anwendungen kommen in ein
              Git-Repository (auf oberster Ebene dann verschiedene Verzeichnisse f√ºr jede
              Bibliothek, jede Anwendung)
              <ul>
                <li class="fragment">
                  Die Anwendungen k√∂nnen sofort mit allen √Ñnderungen der Bibliothek getestet werden
                </li>
                <li class="fragment">
                  Falls es API-√Ñnderungen an der Bibiothek gibt, k√∂nnen diese in den Anwendungen
                  gleich erfolgen und alles auf einmal committed werden
                </li>
                <li class="fragment">
                  Tools: <a href="https://lerna.js.org/">Lerna</a> oder
                  <a href="https://classic.yarnpkg.com/en/docs/workspaces/">Yarn workspaces</a>
                </li>
              </ul>
            </li>
            <li class="fragment">
              Mono-Repo-Ansatz 2: selbe Idee, aber mit
              <a href="https://nx.dev/latest/react/structure/creating-libraries">NX</a> umgesetzt
              (mit explizitem Support f√ºr
              <a href="https://nx.dev/latest/react/react/library">React Bibliotheken</a>). Das ist
              die all-inklusive-L√∂sung, aber mit einer Menge an eigenen Konzepten und Ideen.
            </li>
          </ul>
        </section>
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <p>
            Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
        <!-- ============================================================================= -->
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
  </body>
</html>
