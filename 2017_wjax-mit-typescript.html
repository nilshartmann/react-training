<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>React Workshop</title>

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="reveal.js/css/reveal.css">
	<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
	<style>
		/*pre code {*/

		/*display: block;*/

		/*padding: 0.5em;*/

		/*background: #FFFFFF !important;*/

		/*color: #000000 !important;*/

		/*}*/

		.right-img {
			margin-left: 10px !important;
			float: right;
			height: 500px;
		}

		.todo:before {
			content: 'TODO: ';
		}

		.todo {
			color: red !important;
		}

		code span.line-number {
			color: lightcoral;
		}

		.reveal pre code {
			max-height: 1000px !important;
		}

		.reveal section img {
			border: 0;
			box-shadow: 0 0 0 0
		}

		/*rgb(196, 215, 240)*/

		html.exkurs body {
			background: rgb(252, 220, 185) url("ai/es6-icon.png") no-repeat right bottom;
		}
	</style>

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<!--
  React und TypeScript Workshop – Moderne Webanwendungen entwickeln

Wenn es um die Entwicklung zeitgemäßer Webanwendungen geht,
fällt die Wahl mittlerweile immer häufiger auf die JavaScript Bibliothek React,
die unter anderem auch von Facebook, Netflix und Twitter verwendet wird.

In diesem Workshop lernen Sie, wie Sie mit React moderne Webanwendungen bauen können.
Dazu werden wir gemeinsam Schritt für Schritt eine Beispielanwendung entwickeln,
an Hand derer wir uns neben den React-Grundlagen auch ansehen,
wie Sie z.B. REST-Aufrufe an ein Backend machen.

Um Ansprüchen an Langlebigkeit, Entwicklungskomfort und Wartbarkeit gerecht zu werden,
nutzen wir zur Entwicklung der Anwendung die Programmiersprache TypeScript.

Voraussetzung für die Teilnahme an dem Workshop sind JavaScript-Kenntnisse.
Die für React notwendigen neueren JavaScript- und TypeScript-Features werde
ich Ihnen in dem Workshop Schritt für Schritt vermitteln.Zur Teilnahme an den Übungen
 ist ein Notebook erforderlich, auf dem Git, die LTS-Version von Node.js und eine IDE
 (z.B. Visual Studio Code oder WebStorm) installiert sind.

Workshop Short Label: React und TypeScript Workshop
  -->

<body>

	<div class="reveal">
		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<h3>React Workshop - Vorbereitung</h3>
				<p>Falls noch nicht gemacht:</p>
				<ol style="font-size: 85%">
					<li>
						<code>git clone https://github.com/DJCordhose/react-workshop.git</code>
					</li>
					<li>Im geklonten Verzeichnis:
						<code>npm install</code>
						<br>
						<span style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren
							<a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
						<li>
							<code>npm start</code>
						</li>
						<li>In neuem Terminal: in
							<code>code/workspace</code> wechseln</li>
						<li>Ausführen:
							<code>npm start</code>
						</li>
						<li>Browser öffnen:
							<a href="http://localhost:8080" target="_blank">http://localhost:8080</a>
						</li>
						<li>Wenn dort ein Hello-World-Text erscheint ist alles gut
				</ol>
				<p>Folien: Im geklonten Verzeichnis
					<code>2017_wjax-mit-typescript.html</code>
				</p>
			</section>

			<section>
				<h4>
					<a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> /
					<a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
				</h4>
				<h3>Workshop</h3>
				<h2>
					<b>Moderne Web-Anwendungen mit React und TypeScript</b>
				</h2>
				<p style="font-size:70%">
					<a href="http://bit.ly/wjax2017-react-typescript-workshop" target="_blank">Slides: http://bit.ly/wjax2017-react-typescript-workshop</a>
				</p>
				<p style="border-top: 2px solid darkgray;margin-top:25px;padding-top:25px;">
					10. November 2017 | W-JAX München
				</p>
			</section>

			<section>
				<h3>
					<b>Nils Hartmann</b>
				</h3>
				<h4>
					<a href="https://nilshartmann.net">Programmierer und Architekt aus Hamburg</a>
				</h4>
				<p>JavaScript, Java</p>
				<p>Trainings und Workshops</p>
				<p style="font-size:smaller">Kontakt:
					<a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
				</p>
				<a href="https://reactbuch.de" target="_blank">
					<img style="max-height:350px" src="images/reactbuch-de.png" />
				</a>
			</section>

			<section>
				<h2>Inhalt</h2>
				<ul>
					<li>
						<a href="#/t0">Teil 0: React-Einführung und Build-Prozess</a>
						<li>
							<a href="#/t1">Teil I: React-Komponenten</a>
							<li>
								<a href="#/t2">Teil II: Komponentenhierarchien</a>
								<li>
									<a href="#/t3">Teil III: Remote-Calls gegen Server</a>
									<li>
										<a href="#/t4">Teil IV: React mit TypeScript entwickeln</a>
									</li>
				</ul>
				<div style="font-size:80%">
					<p>
						<b>Jederzeit:</b> Fragen und Diskussionen!</p>
				</div>
			</section>

			<section id="example-app">
				<h2>Beispiel-Anwendung</h2>
				<a target="_blank" href="code/schritte/5-third-party-typescript/public/index.html">
					<img src="images/greeting-app.png" style="border:0;box-shadow:0 0 0 0;max-width: 80%" />
				</a>
			</section>

			<section id="t0">
				<h1>Teil 0</h1>
				<h2>React-Einführung und Build-Prozess</h2>
			</section>

			<section id="react">
				<h2>React</h2>
				<p>
					<a href="https://reactjs.org" target="_blank">https://reactjs.org</a>
				</p>
				<ul>
					<li class="fragment">Framework von und für Facebook (und viele andere)
						<li class="fragment">Minimales API
							<li class="fragment">Minimales Feature Set
								<ul>
									<li>Ihr könnt/müsst viele Entscheidungen selber treffen</li>
								</ul>
								<li class="fragment">Bewusste Verstöße gegen Best-Practices
									<li class="fragment">Zentrales Konzept: Komponenten
				</ul>
			</section>

			<section>
				<h3>Komponenten in React</h3>
				<img src="ai/soc.png">
			</section>

			<section>
				<h3>Komponenten in React</h3>
				<p style="font-size:smaller">Unser Beispiel in Komponenten</p>
				<img src="ai/greeting-example-component-hierarchy.png">
			</section>


			<section>
				<h3>React Komponenten</h3>
				<ul>
					<li class="fragment">bestehen aus
						<b>Logik und UI</b>
						<li class="fragment">
							<b>keine Templatesprache</b>
							<li class="fragment">werden
								<b>deklarativ</b> beschrieben
								<li class="fragment">werden immer
									<b>komplett gerendert</b> (kein 2-Wege-Data-Binding)
									<li class="fragment">werden zu
										<b>ganzen Anwendungen</b> aggregiert
										<li class="fragment" style="margin-top:20px">können auf dem
											<b>Server gerendert</b> werden
				</ul>
			</section>

			<section>
				<h3>React Komponenten</h3>
				<ul>
					<li class="fragment">Werden als ES6 Klasse oder Funktion implementiert
						<li class="fragment">Keine Templatesprache (stattdessen JavaScript)
							<li class="fragment">Templates können HTML-artige Syntax enthalten (JSX)
				</ul>
				<pre class="fragment"><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return &lt;h1 className='title'>Hello, World!&lt;/h1>
  }
}
</code></pre>
			</section>
			<section data-state="exkurs">
				<h2>Exkurs</h2>
				<h1>ES6/ES7</h1>
			</section>

			<section data-state="exkurs">
				<h2>ES6-Referenz</h2>
				<p>ES6 Features werden vorgestellt, wo wir sie brauchen</p>
				<p>
					<a href="http://exploringjs.com/es6/" target="_blank">
						http://exploringjs.com/es6/</a>
			</section>
			<section data-state="exkurs">
				<h3>ES6: Template Strings</h3>
				<p>Template Strings werden in Backticks (``) geschrieben und können Ausdrücke (in
					<code>${}</code>) enthalten:</p>

				<pre class="fragment"><code class="javascript" contenteditable>const name = "Susi";
const greeting = `Hello, ${name}`; // Hello, Susi

const four = `Two and two is: ${2+2}` // Two and two is: 4

const time = `The time is: ${new Date()}`); // The time is: ...
            </code></pre>
			</section>


			<section data-state="exkurs">
				<h3>ES6: Klassen</h3>
				<pre><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    getName() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return `${this.getName()} codes in ${this.language}`;
    }
}</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
			</section>

			<section data-state="exkurs">
				<h3>ES6: Arrow Functions</h3>
				<pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable>// Klammern können weggelassen werden, genau ein Parameter
// ebenso die geschweiften Klassen, wenn nur ein Statement:
const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
			</section>
			<section>
				<h3>Eine erste Komponente: Hello, World!</h3>
				<a target="_blank" href="code/schritte/0-hello_world/public/index.html">Demo</a>
			</section>

			<section>
				<h3>Hello World React</h3>
				<pre><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return (&lt;div>
            &lt;input ref={input => this.input = input}
                   onChange={event => this.updateModel(event)}
                   value={this.state.greeting} />
            &lt;p>{this.state.greeting}, World&lt;/p>
            &lt;button
                onClick={() => this.reset()}>
                Clear
            &lt;/button>
        &lt;/div>);
  }</code></pre>
				<pre class="fragment"><code contenteditable class="javascript">  constructor(props) {
    super(props);
    this.state = {greeting: this.props.greeting};
  }
  updateModel(event) {
    this.setState({greeting: event.target.value});
  }
  reset() {
    this.setState({greeting: ""});
    this.input.focus();
  }
}</code></pre>
			</section>

			<section>
				<h3>Aufruf</h3>
				<pre><code data-trim contenteditable>
// index.html
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
				<pre class="fragment"><code data-trim contenteditable class="javascript">
// main.js
import React from 'react';
import ReactDOM from 'react-dom';

import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage greeting="Hello"/>, mountNode);
</code></pre>
				<a target="_blank" href="code/schritte/0-hello_world/public/index.html">Run</a>
			</section>


			<section>
				<h2>Buildprozess</h2>
				<ul>
					<li>ES6- und JSX-Code muss nach ECMAScript 5 übersetzt werden
						<ul>
							<li>Status der ES6 Implementierungen der Browser:
								<a href="https://kangax.github.io/compat-table/es6/" target="blank">
									https://kangax.github.io/compat-table/es6/
								</a>
							</li>
						</ul>
						<li>Typische Werkzeuge
							<ul>
								<li>Babel oder TypeScript (Compiler)
									<li>Webpack (Bundler)
										<li>Webpack Dev Sever (HTTP Server mit Hot Reload)
							</ul>
				</ul>
			</section>
			<section>
				<h2>Webpack und Babel</h2>
				<img src="images/webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0" />
			</section>
			<section>
				<h2>Webpack Development Server</h2>
				<ul>
					<li>Zum Ausführen der Anwendung wird ein Webserver benötigt</li>
					<li class="fragment">Für die Entwicklung
						<b>Webpack Dev Server</b>:
						<ul>
							<li>...führt Webpack auf Basis der Projekt Webpack Konfiguration aus</li>
							<li>...erzeugt Ausgabe in Memory (Performance)</li>
							<li>...Hot Reloading: Automatische Aktualisierung nach Code Änderung</li>
							<li>...React Hot Loader: Zustand bleibt nach Aktualisierung erhalten (Beta)</li>
						</ul>
						<li class="fragment">
							<code>npm start</code> in unserem Beispiel-Projekt</li>
				</ul>
			</section>
			<section>
				<h2>Übung 0: React Hello-World</h2>
				<h3>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</h3>
			</section>
			<section>
				<h3>Schritt #1: Tool-Chain starten (falls noch nicht gemacht)</h3>
				<p>Nutze für die Übungen das
					<code>workspace</code>-Verzeichnis in diesem Repository. Hier ist eine Tool-Chain mit Webpack und Babel vorbereitet</p>
				<ol style="font-size: 85%">
					<li>
						<code>npm install</code> (auf oberster Ebene)
						<br>
						<span style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren
							<a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
						<li>
							<code>cd code/workspace</code>
							<li>
								<code>npm start</code>
								<li>Öffne
									<a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
									<li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
				</ol>
			</section>
			<section>
				<h3>Schritt #2: Deine erste React-Komponente</h3>
				<ul>
					<li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel aus den Folien
						<li>
							<em>Zusatzaufgabe: Experimentiere mit der Anwendung, mache einige Änderungen, wie z.B.</em>
							<ul>
								<li>Alle Eingaben sollen in Großbuchstaben auftauchen
									<li>Gib irgendeine Rückmeldung wenn die Eingabe erfolgreich gelöscht wurde
							</ul>
							</li>
				</ul>
			</section>

			<section id="t1">
				<h1>Teil I</h1>
				<h2>React-Komponenten</h2>
				<a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
			</section>

			<section>
				<h2>Referenz</h2>
				<p>
					<a href="https://reactjs.org/docs/hello-world.html" target="_blank">
						https://reactjs.org/docs/hello-world.html
					</a>
				</p>
			</section>


			<section>
				<h3>Themen</h3>
				<ul>
					<li>Rendering
						<li>Properties und Zustand
							<li>Referenzen auf DOM-Elemente (Refs)
				</ul>
			</section>

			<section>
				<h3>React: Rendering</h3>
				<span class="fragment">
					<p>
						<em>Jede React-Komponente braucht eine
							<code>render</code>-Methode:</em>
						<ul>
							<li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
							<li>liefert genau
								<b>ein</b> Element oder
								<b>null</b> oder
								<b>ein Array</b> oder
								<b>einen String</b> zurück</li>
							<li>kann HTML-artige JSX-Syntax nutzen</li>
						</ul>
						<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
				</span>
			</section>
			<section>
				<h3>React: JSX</h3>
				<ul>
					<li style="font-size: 80%" class="fragment">Wird wie HTML hingeschrieben, inkl Attribute:
						<pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
					</li>
					<li style="font-size: 80%" class="fragment">Attribute, die keine Strings sind, müssen in {} eingechlossen werden:
						<pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
					</li>
					<li style="font-size: 80%" class="fragment">Kann pures JavaScript enthalten, eingeschlossen in {}:
						<pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
					</li>

					<li style="font-size: 80%" class="fragment">
						<code>class</code>-Attribut heißt
						<code>className</code>:
						<pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
					</li>
					<li style="font-size: 80%" class="fragment">CSS-Eigenschaften werden als Objekt übergeben in Camel-Case-Notation:
						<pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
					</li>
				</ul>
			</section>
			<section>
				<h3>React: Rendering #2</h3>
				<ul class="fragment">
					<li>DOM-Events werden in React-Events verpackt
						<li>React-Events haben weitgehend selbe API wie DOM-Events
							<li>Es gibt keine automatische Bindung an Modelle (2-Wege Databinding)
								<li>Besonderes Event:
									<b>onChange</b>
								</li>
				</ul>
				<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
        &lt;input onKeyPress={event => . . .} />
    );
  }
  // ...
}
</code></pre>
			</section>
			<section data-state="exkurs">
				<h3>ES6: Erweiterte Objekt-Literale</h3>
				<pre><code class="javascript" contenteditable>const firstName = 'Klaus';

// ES5:
const person = {
    firstName: firstName
};

// ES6:
const person = {
    firstName
};
console.log(person.name); // Klaus
   </code></pre>
			</section>


			<section data-state="exkurs">
				<h2>ES6: Module, Importe und Exporte</h2>
			</section>
			<section data-state="exkurs">
				<h3>ES6: Export einer einzigen Klasse</h3>
				<pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
   </code></pre>
				<pre><code class="javascript" contenteditable>// Person.js

// in einer Zeile zusammengefasst
export default class Person {
  // ...
}
   </code></pre>
			</section>
			<section data-state="exkurs">
				<h3>ES6: Import</h3>
				<pre><code class="javascript" contenteditable>// Programmer.js
import Person from './Person';

export default class Programmer extends Person {
  // ...
}
   </code></pre>
			</section>
			<section data-state="exkurs">
				<h3>ES6: Benannte Exporte</h3>
				<pre><code class="javascript" contenteditable data-trim>// util.js
export function displayInPage(text) {
    document.body.innerHTML +=
        `${text}<br>` ;
}

export showInfo = msg => window.alert(`Wichtige Info: ${msg}`);

// or
function displayInPage(text) { . . . }

const showInfo = ...;

// specify exports
export { displayInPage, showInfo };
   </code></pre>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
displayInPage('Hello, World');
   </code></pre>
				<!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
				<!--display('Hello, World');-->
				<!--</code></pre>-->
				<!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
				<!--util.displayInPage('Hello, World');-->
				<!--</code></pre>-->
			</section>
			<!--<section>-->
			<!--<h2>Neuerungen und Verbesserungen in ES6</h2>-->
			<!--</section>-->

			<!--<section>-->
			<!--<h3>Tagged Template Literals</h3>-->
			<!--<p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">-->
			<!--Mini-DSLs: Template-Literals mit tag-->
			<!--</a>-->
			<!--</p>-->

			<!--<pre class="fragment"><code class="javascript" contenteditable>function tag(strings, ...values) {-->
			<!--console.log(strings);-->
			<!--//[ '', ' codes in ', '.' ]-->
			<!--console.log(values);-->
			<!--//[ 'Oma', 'Haskell' ]-->
			<!--return 'whatever you want';-->
			<!--}-->
			<!--</code></pre>-->

			<!--<pre><code class="javascript" contenteditable>const expanded = tag`${person} codes in ${language}.`;-->
			<!--console.log(expanded);-->
			<!--//whatever you want-->
			<!--</code></pre>-->

			<!--</section>-->

			<section data-state="exkurs">
				<h3>ES6: Destructuring von Objekten</h3>
				<pre><code class="javascript" contenteditable>const person = {
  name: 'Olli',
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable>const {name, notThere} = person;

console.log(`name=${name}`);
// name=Olli
console.log(`notThere=${notThere}`);
// notThere=undefined
</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable>function someFunction({name, notThere}) {
  console.log(`name=${name}`);
  // name=Olli
  console.log(`notThere=${notThere}`);
  // notThere=undefined
}

someFunction(person);
</code></pre>
			</section>
			<section>
				<h3>React: Properties und Zustand</h3>
				<ul class="fragment">
					<li>
						<b>Properties</b> werden der Komponente von
						<b>außen</b> übergeben (und nicht verändert)</li>
					<li>
						<b>Zustand (State)</b> ist eine
						<b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
					<li>Beides sind Objekte mit Key-Value-Paaren</li>
					<li>Beide können an Unterkomponenten übergeben werden</li>
				</ul>
			</section>

			<section>
				<h3>Properties einer Komponente</h3>
				<ul class="fragment">
					<li>Properties werden über den Konstruktor in die Komponente hineingereicht</li>
					<li>Properties dürfen nicht verändert werden</li>
					<li>Zugriff über
						<code>this.props</code>
					</li>
					<li>
						<code>this.props.children</code> enthält Kind-Elemente</li>
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
class NavBar extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
      return &lt;div className="NavBar">
        <h1>{this.props.title}</h1>
        {this.props.children}
        &lt;/div>;
    }
   // ...
}
</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
	&lt;NavBar title="Navigation">&lt;a href=""> ... &lt;/a>&lt;/NavBar>
</code></pre>

			</section>

			<section>
				<h3>Zustand einer Komponente</h3>
				<ul class="fragment">
					<li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server</li>
					<li>Werte üblicherweise immutable</li>
					<li>
						<b>Initialisieren</b> im Konstruktor mit
						<code>this.state={}</code>
						<li>Zustand
							<b>lesen</b> über
							<code>this.state</code>
							<li>Zustand
								<b>setzen</b> über
								<code>this.setState()</code>
								<ul>
									<li>
										<b>Achtung:</b> kein "reiner" Setter</li>
									<li>Führt alten und neuen Zustand zusammen</li>
									<li>Wird asynchron ausgeführt!</li>
									<li>
										<b>Löst erneutes rendern der
											<i>gesamten</i> Komponente aus</b>
									</li>
								</ul>
				</ul>
			</section>

			<section>
				<h3>Beispiel: Zustand einer Komponente</h3>
				<pre><code class="javascript" contenteditable data-trim>
class GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
			</section>
			<section>
				<h3>Render Zyklus</h3>
				<img src="images/event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
			</section>

			<section>
				<h3>Virtual DOM</h3>
				<p>"Rendern" hat doppelte Bedeutung!</p>
				<img src="images/virtual-dom.png" style="border:0;box-shadow:0 0 0 0">
			</section>

			<section>
				<h3>React: Referenzen auf nativen DOM</h3>
				<ul class="fragment">
					<li>Elementen kann eine Callback-Funktion
						<code>refs</code> übergeben werden
						<li class="fragment">Funktion wird nach dem Rendern mit Referenz auf DOM Element aufgerufen (oder
							<code>null</code>)
							<li class="fragment">Diese Referenz kann man z.B. als Member-Variable speichern
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
    render() {
        return (
            <div>
                &lt;input ref={input => this.input = input} />
                &lt;button
                    onClick={() => this.input.focus()}>
                    Focus
                &lt;/button>
            </div>);
    }
}
</code></pre>
			</section>

			<section>
				<h2>Übung 1: Detail-Ansicht für unsere Gruß-Anwendung</h2>
				<h3>Erzeuge eine Komponente mit der man einen Namen und eine Grußformel eingeben kann</h3>
			</section>
			<section>
				<h3>Schritte</h3>
				<h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
				<ul>
					<li>benenne deine Komponente in
						<code>GreetingDetail</code> um
						<li>du brauchst zwei Eingabefelder, die
							<code>name</code> und
							<code>greeting</code> im Zustand der Komponente setzen
							<li>Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand initialisieren
								<li>Optionaler Schritt: Kannst du die Komponente so bauen, dass du mit einer einzigen update-Methode beide Felder im
									Zustand updaten kannst?
				</ul>
			</section>

			<section id="t2">
				<h1>Teil II</h1>
				<h2>Komponentenhierarchien</h2>
				<h3>Komplette Anwendung aus Komponenten bauen</h3>
				<a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a>
			</section>

			<section>
				<h2>Thinking in React</h2>
				<p>
					<a href="https://reactjs.org/docs/thinking-in-react.html" target="_blank">
						https://reactjs.org/docs/thinking-in-react.html
					</a>
				</p>
			</section>

			<section>
				<h3>Herausforderungen</h3>
				<ul>
					<li>Wie kommt das neue Greeting zum GreetingMaster?
						<li>Wie stellen wir Listen von Komponente (Greetings!) dar?
							<li>Wer steuert den Programmfluss? Vom GreetingMaster zum Detail und zurück?
				</ul>
			</section>


			<section>
				<h3>Themen</h3>
				<ul>
					<li>Komponenten als Funktion
						<li>Darstellung von Listen und Keys
							<li>Architektur-Idee: Controller-Komponente und View-Komponente
								<li>Durchreichen von Zustand und Callbacks
									<li>PropTypes
				</ul>
			</section>

			<section>
				<h3>Komponenten als Funktion</h3>
				<ul class="fragment">
					<li>Komponente ist eine einfache Funktion</li>
					<li>entspricht der
						<code>render</code>-Methode</li>
					<li>Properties werden als Object per Parameter übergeben</li>
					<li>Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
					<li>Empfehlung: Funktionen statt Klassen verwenden (wenn möglich)</li>
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
import React from 'react';
export default function Greet(props) {
  return (
      <div>
          <h1>{props.greeting}</h1>
          <h2>{props.name}</h2>
      </div>
  );
}

// Verwendung:
&lt;Greet name="Susi" greeting="Hello" /&gt;

</code></pre>
			</section>
			<section>
				<h3>Komponenten als Funktion</h3>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Mit Destructuring
export default function Greet({greeting, name}) {
  return (
      &lt;div>
          &lt;h1>{greeting}&lt;/h1>
          &lt;h2>{name}&lt;/h2>
      &lt;/div>
  );
}
</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Als Arrow Function
const Greet = ({greeting, name}) => (
  &lt;div>
    &lt;h1>{greeting}&lt;/h1>
    &lt;h2>{name}&lt;/h2>
  &lt;/div>
);

export default Greet;
</code></pre>

			</section>

			<section>
				<h3>Listen und Keys</h3>
				<ul class="fragment">
					<li>JSX bietet nichts für Listen
						<li>Ausgabe typischerweise über
							<code>Array.map</code>
							<li>Elemente einer Liste brauchen einen eindeutigen Key
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [
  { id: 0, name: 'Olli', greeting: 'Huhu' },
  { id: 1, name: 'Oma', greeting: 'Hallo' }
];

const MyTable({greetings}) =>
    &lt;table>
      {greetings.map(greeting =>
        &lt;tr key={greeting.id}>
            &lt;td>{greeting.name}&lt;/td>
            &lt;td>{greeting.greeting}&lt;/td>
        &lt;/tr>
      )}
    &lt;/table>
;
</code></pre>
			</section>
			<section>
				<h3>Listen und Keys</h3>
				<ul class="fragment">
					<li>Ab React 16 können Arrays in
						<code>render</code> zurückgegeben werden
						<li>(Anstatt
							<b>eines</b> Root Elements)</li>
						<li>Elemente brauchen trotzdem einen eindeutigen Key
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
const Title = ({title, subtitle}) => {
	return [
		&lt;h1 key="title">{title}&lt;/h1>,
		&lt;h2 key="subtitle">{subtitle}&lt;/h2>
	];
}
</code></pre>
			</section>
			<section>
				<h3>Komponenten in Hierarchien</h3>
				<p>Beispiel: Unsere Anwendung</p>
				<img src="ai/greeting-hierarchy-without-callbacks.png" />
			</section>

			<section>
				<h3>Smart und Dumb Components</h3>
				<p style="font-size: smaller;margin-bottom:0">(Alternativ: Container und Presentation Components)</p>
				<!--<img src="smart-dumb.jpg">-->
				<!--<img src="smart-dumb.png">-->
				<img style="margin-top:0" src="images/component-communication.png">
			</section>

			<section>
				<h3>Durchreichen vom Zustand und Callbacks</h3>
				<ul class="fragment">
					<li>Funktioniert beides über Properties
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
    render() {
        const {greetings} = this.state;
        return &lt;div>
                &lt;GreetingMaster greetings={greetings}
                    onAdd={() => this.setState({mode: MODE_DETAIL})} />
            &lt;/div>;
    }
    // ...
}
    </code></pre>
			</section>
			<section>
				<h3>Properties übergeben mit Object-Spread</h3>
				<ul class="fragment">
					<li>Übergibt
						<b>alle</b> Eigenschaften eines Objektes als individuelle Properties</li>
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {


    render() {
        const greeting = { name: 'Klaus', greeting: 'Hello' };

        return &lt;GreetingDetail {...greeting} />

        // entspricht:
        // &lt;GreetingDetail name='Klaus' greeting='Hello' />
    }
}
        </code></pre>
			</section>

			<section>
				<h3>PropTypes</h3>
				<ul>
					<li class="fragment">Eine Komponente kann deklarieren, welche Properties sie erwartet
						<li class="fragment">Auch der Typ kann angegeben werden (
							<a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank">Mögliche Typen</a>)
							<li class="fragment">Fehlende / falsche Properties führen zu Laufzeitfehlern
								<li class="fragment">Ab React 15.5 eigenes npm modul:
									<a href="https://www.npmjs.com/package/prop-types" target="_blank">
										<code>prop-types</code>
									</a>
								</li>
								<li class="fragment">Alternative: Typsystem (
									<a href="https://flow.org" target="_blank">Flow</a> oder
									<a href="https://typescriptlang.org" target="_blank">TypeScript</a>)
				</ul>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

class GreetingDetail extends React.Component { . . . };

GreetingDetail.propTypes = {
    greeting: PropTypes.shape({
      name: PropTypes.string.isRequired,
      greeting: PropTypes.string.isRequired
    }),
    onAdd: PropTypes.func.isRequired
};
</code></pre>
			</section>
			<section>
				<h3>PropTypes</h3>
				<p>Mit statischen Properties (
					<code>static</code> noch kein JS Standard!)</p>
				<pre><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

class GreetingDetail extends React.Component {
  static propTypes = {
    greeting: PropTypes.shape({
      name: PropTypes.string.isRequired,
      greeting: PropTypes.string.isRequired
    }),
    onAdd: PropTypes.func.isRequired
  };

  render() { . . . }
};
            </code></pre>
			</section>
			<section>
				<h3>PropTypes</h3>
				<p>Für Komponenten als Funktionen</p>
				<pre><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

function HelloMessage(text) { . . . }

HelloMessage.propTypes = {
  text: PropTypes.string.isRequired
}
            </code></pre>
			</section>


			<section>
				<h2>Übung 2: Eine komplette Anwendung zusammen setzen</h2>
				<h3>Füge deinen bestehenden Detail-View (
					<code>GreetingDetail</code>) und einen Master-View über eine Controller-Komponente zusammen</h3>
			</section>
			<section>
				<h3>Schritte</h3>
				<ol>
					<li>kopiere das Material aus
						<code>code/material/2-hierarchy</code> in deinen src-Ordner
						<li>erweitere im
							<code>GreetingController</code> die render-Methode, so dass dein
							<code>GreetingDetail</code> angezeigt wird, wenn der Benutzer den Add-Button klickt:
							<ul>
								<li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
									<li>übergib einen Callback der
										<code>addGreeting</code> nutzt
							</ul>
							<li>im deinem
								<code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
								<br>
								<span style="font-size:85%">(Du kannst dein
									<code>GreetingDetail</code> verwenden, oder die Vorlage code/material/2-hierarchy/src/_GreetingDetail.js verwenden)</span>

				</ol>
			</section>
			<section>
				<h3>Architektur Beispiel-Anwendung</h3>
				<img src="ai/greeting-hierarchy.png" style="border:0;box-shadow:0 0 0 0" />
			</section>
			<section>
				<h3>GreetingMaster</h3>
				<img src="images/greeting-master.png" style="border:0;box-shadow:0 0 0 0" />
			</section>
			<section>
				<h3>GreetingDetail</h3>
				<img src="images/greeting-detail.png" style="border:0;box-shadow:0 0 0 0" />
			</section>

			<section id="t3">
				<h1>Teil III</h1>
				<h2>Remote-Calls gegen Server</h2>
				<a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
			</section>

			<section>
				<h3>Herausforderungen</h3>
				<ul>
					<li>Wie machen wir das Laden und Speichern technisch?
						<li>Wo steht der Code zum initialen Laden der Grüße?
							<li>Wo speichern wir?
								<li>Wie funktioniert asynchrone Verarbeitung in React?
				</ul>
			</section>

			<section>
				<h3>Server-Calls</h3>
				<ul>
					<li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
					<li>Häufig in React verwendet:
						<b>fetch</b> API
						<ul>
							<li>Browser-API zum Ausführen von HTTP Requests</li>
							<li>
								<a href="http://caniuse.com/#search=fetch" target="_blank">hohe Verbreitung</a>
							</li>
							<li>Spezifikation:
								<a href="https://fetch.spec.whatwg.org/" target="_blank">https://fetch.spec.whatwg.org/</a>
							</li>
							<li>Polyfill:
								<a href="https://github.com/github/fetch" target="_blank">https://github.com/github/fetch</a>
							</li>
						</ul>
				</ul>
			</section>
			<section>
				<h3>Beispiel: fetch</h3>

				<pre><code class="javascript" contenteditable data-trim>
// GET
fetch('http://localhost:7000/api/greetings')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));

// PUT
fetch(url, {
    method: 'PUT',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
})
  .then(...)
</code></pre>
			</section>


			<section data-state="exkurs">
				<h2>ES6: Promises</h2>
			</section>
			<section data-state="exkurs">
				<h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
				<h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
			</section>

			<section data-state="exkurs">
				<h3>Verkettete Ausführung</h3>
				<pre><code class="javascript" contenteditable>const promise = . . .;
</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
			</section>
			<section data-state="exkurs">
				<h3>Fehler führen zum Abbruch der Chain</h3>
				<h4>Allerdings
					<b>muss</b> man etwas tun, um das mitzubekommen: catch()</h4>
			</section>

			<section data-state="exkurs">
				<h3>Catch-Klausel im Erfolgsfall</h3>
				<pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
			</section>
			<section data-state="exkurs">
				<h3>Catch-Klausel im Fehlerfall</h3>
				<pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
			</section>

			<section>
				<h3>fetch im Detail</h3>

				<pre><code class="javascript" contenteditable data-trim>
// 1. fetch returns a promise, that will be resolved
// with a Response object when response is received
// from server
fetch('http://localhost:7000/api/greetings')

// 2. the Response object contains a json() function,
// that returns the parsed JSON from the Response body
  .then(response => response.json())

// 3. with the resolved JSON object we set the
// component state (=&gt; leads to re-rendering)
  .then(json => this.setState({greetings: json})

// 4. in case something goes wrong (during request,
// request processing or rendering)
  .catch(ex => console.error('request failed', ex));
// as an alternative we could set and render an error msg:
//  .catch(ex => this.setState({error: ex})
</code></pre>
				<p>
					<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
				</p>
			</section>
			<section>
				<h3>Initiales Laden von Daten</h3>
				<p style="font-size:80%">Komponenten können optionale
					<a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank">Lifecycle-Methoden</a> haben</p>
				<img style="max-height: 500px;margin:0" src="images/react-lifecycle-1.png" />
				<p style="font-size:40%">(c) "React: Die praktische Einführung in React, React Router und Redux", dpunkt 2016</p>
			</section>
			<section>
				<h3>Initiales Laden von Daten</h3>
				<p>
					<code>componentDidMount</code> wird aufgerufen, wenn Komponente ins DOM gerendert wurde</p>
				<p>Hier werden Daten üblicherweise initial geladen:</p>
				<pre><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  constructor(props) {
    // intial state (empty now)
    this.state = { greetings: [] };
  }
  componentDidMount() {
    fetch('/api/greetings')
      .then(response =&gt; response.json())
      .then(json =&gt; this.setState({greetings: json})
      .catch(. . .)
    ;
  }
}
                </code></pre>
				</p>
			</section>
			<section>
				<h3>Speichern von Daten</h3>
				<p>Zum Beispiel als Folge einer Benutzerinteraktion:</p>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  render() {
    ...
      &lt;GreetingDetail onAdd={greeting => this.saveGreeting(greeting)} />
    ...
  }
  saveGreeting(greetingToBeSaved) {
    fetch('/api/greetings', {
      method: 'POST',
      headers: ...,
      body: JSON.stringify(greetingToBeSaved)
    })
      .then(response =&gt; response.json())
      .then(json =&gt; ...)
      .catch(. . .);
  }
}
                </code></pre>
			</section>

			<section>
				<h2>Übung: Laden und Speichern der Daten von/auf einem Server</h2>
				<p>
					<em>Entwickle auf Basis von fetch eine Version des GreetingControllers, der die Daten auf dem Server laden und dort wieder
						speichern kann</em>
				</p>
				<p>Der Server ist bereits vorgegeben und kann mit
					<code>npm start</code> im Root-Verzeichnis gestartet werden. Er ist dann unter Port 7000 erreichbar</p>
			</section>
			<section>
				<h3>Schritte</h3>
				<ol>
					<li>Kopiere
						<code>code/material/3-remote/GreetingController.js</code> in deinen Arbeitsbereich
						<li>Die Serverzugriffe sollen in
							<code>loadGreetings</code> und
							<code>saveGreeting</code> erfolgen</li>
						<li>Dort sind bereits entsprechende TODOs für dich eingetragen</li>
				</ol>
			</section>

			<section>
				<h2>Exkurs</h2>
				<h1>Integration von 3rd-Party Libs</h1>
			</section>
			<section>
				<h2>3rd Party Libs?</h2>
				<div class="fragment">
					<p>Es gibt eine große Anzahl von sehr praktischen JavaScript-Bibliotheken</p>
					<p>Viele davon sind aber nicht als React-Komponenten entwickelt worden</p>
				</div>
				<div class="fragment">
					<p>
						<b>Beispiele</b>
					</p>
					<p>
						<em>jQuery</em> und
						<em>jQuery</em> Plugins wie z.B.
						<em>Bootstrap</em>
					</p>
					<p>
						<em>d3</em> für interaktive SVGs und Chart Bibliotheken wie
						<em>nvd3</em>
					</p>
				</div>
			</section>

			<section>
				<h3>Unser Beispiel: Verteilung der Grüße</h3>
				<p>Aufgabe: Einbetten des d3/nvd3 Pie Charts in eine React-Komponente</p>
				<a href="code/schritte/5-third-party/public/index.html" target="_blank">
					<img src="images/screenshot-nvd3.png" height="400px">
				</a>
				<p style="font-size:75%">
					<em>nvd3</em> Pie Chart mit
					<em>d3</em>
				</p>
			</section>

			<section>
				<h3>Herausforderungen?</h3>
				<ol>
					<li>Wie kommen wir an den DOM Knoten der React-Komponente?
						<li>Wie sagen wir React, dass nun NVD3 den Rest macht? Also, dass React nicht mehr neu rendern soll.
							<li>Änderungen des Zustands sollen nach wie vor richtig dargestellt werden
								<li>Ab welchem Zeitpunkt soll NVD3 das Rendern übernehmen?
									<li>Wie können wir aus NVD3 heraus auch wieder andere React-Komponenten beeinflussen?
										<li>Wie räumen wir wieder auf?
				</ol>
			</section>
			<!--<section>-->
			<!--<h3>Hintergrund: Charts mit NVD3</h3>-->
			<!--<p>Basiert auf D3.js</p>-->
			<!--<p>Benötigt svg DOM-Element um sich zu rendern</p>-->
			<!--<p class="fragment">Stark vereinfachtes Beispiel:</p>-->
			<!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import d3 from 'd3';-->
			<!--import nv from 'nvd3';-->

			<!--// Chart erzeugen-->
			<!--const chart = nv.models.pieChart();-->
			<!--// ...Chart Config ausgelassen ...-->

			<!--// mit d3 rendern und mit Daten versorgen-->
			<!--const element = document.getElementById('chart');-->
			<!--d3.select(element)-->
			<!--.datum(data)-->
			<!--.call(chart);-->

			<!--// Callbacks registrieren (z.B. bei Klick auf ein Element)-->
			<!--chart.pie.dispatch.on("elementClick",-->
			<!--e => console.log(e.data.label));-->
			<!--</code></pre>-->

			<!--</section>-->

			<!--<section>-->
			<!--<h3>Übersicht über den Komponenten-Lifecycle</h3>-->
			<!--<a href="https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle" target="_blank">-->
			<!--https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle-->
			<!--</a>-->
			<!--</section>-->
			<!--<section>-->
			<!--<img src="ai/lifecycle-methods-1.png" height="600px"/>-->
			<!--</section>-->
			<!--<section>-->
			<!--<img src="ai/lifecycle-methods-2.png" height="600px" />-->
			<!--</section>-->
			<!--<section>-->
			<!--<h3>React Lifecycle Methoden</h3>-->
			<!--<ul>-->
			<!--<li class="fragment"><code><b>componentDidMount()</b></code>: Komponente wurde gerendert, Elemente sind im DOM (einmalig)</li>-->
			<!--<li class="fragment"><code><b>componentWillReceiveProps(nextProps)</b></code>: An die Komponente wurden neue Properties übergeben. Die neuen Properties-->
			<!--werden als Parameter übergeben</li>-->
			<!--<li class="fragment"><code><b>shouldComponentUpdate()</b></code>: Entscheidet, ob Komponente erneut gerendert werden soll (default: <code>true</code>)</li>-->
			<!--<li class="fragment"><code><b>componentWillUnmount()</b></code>: Wird aufgerufen, bevor Komponente aus dem DOM entfernt wird (einmalig)</li>-->
			<!--</ul>-->

			<!--</section>-->
			<section>
				<h3>Greeting Chart Komponente: Verwendung</h3>
				<pre><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Chart
  data={...}
  onSegmentSelect={segment => . . . }
/>
        </code></pre>
			</section>
			<section>
				<h3>Greeting Chart Komponente #1</h3>
				<pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    render() {
        //  we render an empty svg and
        //  remember the reference to the DOM node
        return &lt;svg ref={c => this._chart = c}>&lt;/svg>
    }

    // called directly after first render
    componentDidMount() {
        // once rendered by react we create the nvd3 chart
        const chart = createNvd3Chart(this._chart, this.props.data);

        // we delegate the label of clicked segment
        // back to parent component
        chart.pie.dispatch.on("elementClick",
                              e => this.props.onSegmentSelected(e.data.label));
    }

    // ...
}
       </code></pre>
			</section>
			<section>
				<h3>Lifecycle-Methoden #2</h3>
				<img src="ai/lifecycle-methods-2.png" height="600px" />
			</section>
			<section>
				<h3>Greeting Chart Komponent #2</h3>
				<pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    // ...

    // if it returns false, component will not be rendered
    shouldComponentUpdate() {
        // once rendered react never renders again
        return false;
    }

    // called when properties update
    componentWillReceiveProps(nextProps) {
        const {data} = nextProps;
        // we still get updates of properties making it reactive
        updateNvd3Chart(this._chart, data);
    }

    // called just before destroying component
    componentWillUnmount() {
        this._d3selection.remove();
    }
}
       </code></pre>
			</section>



			<section id="t4">
				<h1>Teil IV</h1>
				<h2>React mit TypeScript entwickeln</h2>
				<p>
					<a href="code/schritte/5-third-party-typescript/public/index.html" target="_blank">Ziel-Anwendung</a>
				</p>
			</section>

			<section>
				<h2>Hintergrund: TypeScript</h2>
				<p>
					<em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
					<a href="http://www.typescriptlang.org/" target="_blank">http://www.typescriptlang.org/</a>)</p>
				<ul>
					<li>Erweitert JavaScript um ein Typen System</li>
					<li>Jeder gültige JavaScript Code ist auch gültiger TypeScript Code</li>
					<li>Mittels des TypeScript Compilers wird aus TS Code JavaScript Code</li>
					<li>Entwickelt von Microsoft (!)</li>
					<li>Unterstützung in vielen IDEs (z.B. Anzeige von Fehlern, Refactoring, ...) </li>
				</ul>
			</section>

			<section>
				<h3>TypeScript Grundlagen</h3>
				<p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Variablen können Typ-Informationen bekommen
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;
               </code></pre>
				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Funktionen
function sayIt(what: string): string {
  return `Saying: ${what}`;
}

sayIt('Klaus'); // ok
sayIt(10); // error
</code></pre>


				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Arrow Funktionen
const sayIt = (what: string): string => `Saying: ${what}`;

sayIt('Moin');
sayIt(123); // Error: Argument of type '123' is not assignable
            // to parameter of type 'string'.
</code></pre>
			</section>

			<section>
				<h2>Eingebaute Typen</h2>
				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// string
let city: string = 'Hamburg';

// boolean
let isDone: boolean = false;

// number
let theAnswer: number = 42;

// array (note the [])
let cities: string[] = ['Hamburg', 'Barcelona'];
// alternative:
let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

// any
let theUnknown: any = 'Who cares';
theUnknown = 666; // ok
theUnknown = true; // ok
let a: number = theUnknown; // ok

// void
function log(s: string): void { /* ... */ }
            </code></pre>

			</section>
			<section>
				<h2>Typen können abgeleitet (inferred) werden</h2>
				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let city = 'Hamburg'; // city ist ein String

city = 42;
// Fehler: [ts] Type '42' is not assignable to type 'string'.
</code></pre>
				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Explizite Angabe eines Types (parameter)
// und abgeleiteter Typ (Return Type der Funktion)

function sayIt(what: string) {
  return `Saying: ${what}`;
}

const said: string = sayIt('Hello TypeScript'); // ok
const saidItWrong: number = sayIt('Hello TypeScript'); // error!


</code></pre>
			</section>
			<section>
				<h2>Strict Mode</h2>
				<ul>
					<li>
						<b>strict</b>: seit TypeScript 2.3</li>
					<li>Shortcut u.a. für:
						<ul>
							<li>
								<b>noImplicitAny</b>:
								<code>any</code> muss explizit hingeschrieben werden</li>
							<li>
								<b>strictNullChecks</b>: Null muss explizit erlaubt werden (z.B. bei Rückgabewerten)</li>
						</ul>
					</li>
					<li>Empfehlung: für neue Projekte einschalten, sonst Schrittweise</li>
					<p>
						<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a>
					</p>
				</ul>
			</section>
			<section>
				<h2>null und undefined</h2>
				<div class="fragment">
					<p>
						<code>null</code> muss explizit zugelassen werden (
						<em>strictNullChecks</em>):</p>
					<pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = null; //Type 'null' is not assignable to type 'string'.

let optionalCity:string|null = null; // OK
            </code></pre>
				</div>
				<div class="fragment">
					<p>Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
						<code>undefined</code>)</p>
					<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function greet(name: string, greeting?: string) {
  console.log(`${greeting || 'Hello'}, {name}`);
}

greet('Susi', 'Moin')// Moin, Susi

// 2. Parameter ist optional:
greet('Klaus'); // Hello, Klaus

greet('Peter', null); // Argument of type 'null' is not assignable
                      // to parameter of type 'string | undefined'.
            </code></pre>
				</div>
			</section>


			<section>
				<h2>Klassen</h2>
				<pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  what: string; // Typ-Angabe für Felder ist erforderlich

  constructor(what: string) { // Typ-Angabe für Parameter ist erforderlich
    this.what = what;
  }

  // Angabe des Return-Types optional
  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

</code></pre>
			</section>
			<section>
				<h2>Eigene Typen</h2>
				<p>Mit
					<code>interface</code> können eigene Typen defniert werden:</p>

				<pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Komplexer Typ
interface Person {
	name: string; // Pflicht
	livesIn?: string; // Optional
}

const susi: Person = { // OK
	name: 'Klaus',
	livesIn: 'Hamburg'
};
const klaus: Person = { // OK (livesIn ist optional)
	name: 'Klaus'
}

const helmut: Person = {} // Error: Property 'name' is missing

const lukas: Person = {
	name: 'Lukas',
	profession: 'Lokführer'
} // Error: 'profession' does not exist in type 'Person'.
               </code></pre>

			</section>

			<section>
				<h2>Typ Kompatibilität</h2>
				<em>Im Gegensatz zu Java ("nominal typing") sind bei TypeScript zwei Typen kompatibel, sofern sie
					<b>dieselbe Struktur</b> haben ("structural typing")</em>
				<pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Book {
	title: string
}

interface Movie {
	title: string
}

const book:Book = { title: "Das Kapital" };
const movie:Movie = book; // OK, obwohl Book !== Movie
               </code></pre>
			</section>
			<section>
				<h2>Generics</h2>
				<p>Generische Typen verwenden</p>
				<pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Person { name: string };
interface Movie { title: string };

let persons:Array&lt;Person&gt; = [];
let movies:Array&lt;Movie&gt; = [];

persons.push({name: 'Klaus'});
movies.push({title: 'Batman'});

persons.push({title: 'Casablanca'}) // error ('title' not in Person)

persons = movies; // error

      </code></pre>
			</section>
			<section>
				<h2>Arbeiten mit externen Bibliotheken</h2>
				<p>Typings installieren und verwenden</p>
				<ul>
					<li>Typings sind optional, können aber über zusätzliches Deklarations-File hinzugefügt werden
						<li>Typings für Kern-Bibliotheken kommen mit TypeScript Compiler
							<li>Manche Bibliotheken werden bereits mit TypeScript Deklarations-Files ausgeliefert (z.B. Redux)
								<li>Typen können über
									<a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/" target="_blank">npm</a> installiert werden und sind dann ohne weiter Schritte nutzbar (z.B.
									<em>npm install @types/react --save</em>)
				</ul>
			</section>

			<section>
				<h2>React-Komponenten mit TypeScript</h2>
				<em>State und Properties von Komponenten werden mit Typen beschrieben</em>
			</section>
			<section>
				<h2>Vorraussetzungen</h2>
				<ul>
					<li class="fragment">React Type Deklarationen installieren:
						<pre><code data-trim contenteditable class="line-numbers bash" data-leftpad>
npm install --save @types/react @types/react-dom
        </code></pre>
					</li>
					<li class="fragment">(Externe) Module, die kein Default-Export haben müssen mit
						<code>import *</code> importiert werden:
						<pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// JavaScript/Babel:
import React from 'react';

// TypeScript
import * as React from 'react';
        </code></pre>
					</li>
					<li class="fragment">Dateien, die JSX-Code enthalten, müssen mit
						<code>.tsx</code> enden</li>
					<li class="fragment">Compiliert wird mit TypeScript (statt Babel). Integration in Webpack mit
						<a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank">
							<code>awesome-typescript-loader</code>
						</a>
					</li>
				</ul>
			</section>
			<section>
				<h2>Getypte React Komponenten</h2>
				<p>
					<code>React.Component</code> ist eine generische Klasse, die einen Typ für Properties und State erwartet</p>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Greeting = {name: string; greeting: string};

interface GreetingDetailProps {
    greeting?: Greeting;
    onSave: (newGreeting: NewGreeting) => void;
}

interface GreetingDetailState {
    name: string;
    greeting: string;
}
            </code></pre>

				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>

class GreetingDetail
  extends React.Component&lt;GreetingDetailProps, GreetingDetailState> {
  // ...
}
            </code></pre>
			</section>
			<section>
				<h3>Typsicherheit in React Komponenten</h3>
				<p>Properties und State sind typsicher</p>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
constructor(props: Props) {
    super(props);

    this.state = { name: '', greeting: ''} // OK

    // ERROR: Object literal may only specify known properties,
    // and 'aha' does not exist in type 'Readonly&lt;State>'
    this.state = {name: '', greeting: '', aha: 10};

    // ERROR: Cannot assign to 'greeting' because
    // it is a constant or a read-only property.
    this.state.greeting = 'no way';
}

render() {
  // ERROR: Property 'nothere' does not exist on type...
  return &lt;div>{this.props.nothere}&lt;/iv>;
}
               </code></pre>
			</section>
			<section>
				<h2>React Events in TypeScript</h2>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
class GreetingDetail extends React.Component&lt;Props, State> {
  // . . .
  updateModel(event: React.SyntheticEvent&lt;HTMLInputElement>) {
    // 'currentTarget' anstatt 'target' verwenden:
    const { name, value } = event.currentTarget;
    // . . .
  }
}

        </code></pre>

			</section>
			<section>
				<h2>Functional Components</h2>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type GreetingMasterProps = {
    greetings: Greeting[]
    onAdd: () => void
};
        </code></pre>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
const GreetingMaster = (props: GreetingMasterProps) => {
    const {greetings, onAdd} = props;
    // . . .
}

        </code></pre>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster = ({greetings, onAdd}: GreetingMasterProps) => {
    // . . .
}

        </code></pre>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster: React.SFC&lt;GreetingMasterProps> = props => {
    const {greetings, onAdd} = props;
    // . . .
}
        </code></pre>
			</section>
			<section>
				<h2>Übung: Eine Komponente auf TypeScript umstellen</h2>
				<h3>
					<em>Stelle die GreetingDetail Komponente auf TypeScript um</em>
				</h3>
				<div style="font-size: 80%">
					<p>
						<b>Hinweis: </b> Bitte arbeite dazu in dem neuen Workspace
						<code>code/workspace-typescript</code>:</p>
					<ul>
						<li>Dieses Verzeichnis enthält die Anwendung aus unserem letzten Schritt, aber in TypeScript implementiert</li>
						<li>Lediglich das
							<code>GreetingDetail</code> ist noch in JavaScript implementiert</li>
						<li>Du kannst den Webpack Server in diesem Verzeichnis ebenfalls mit
							<code>npm start</code> starten</li>
						<li>Denk dran, deinen laufenden Webpack Server vorher zu beenden</li>
					</ul>
				</div>
			</section>
			<section>
				<h2>Schritte</h2>
				<ol style="font-size:80%">
					<li>Benenne
						<code>GreetingDetail.js</code> in
						<code>GreetingDetail.tsx</code> um (danach Webpack neu starten)</li>
					<li>Definiere einen Typen für die Properties und den State und passe die
						<code>GreetingDetail</code>-Klasse an</li>
					<li>Füge der Komponente die
						<code>input</code>-Variable hinzu (Typ:
						<code>HTMLInputElement</code>)</li>
					<li>Experimentiere (optional):
						<ul>
							<li>Was passiert, wenn Du im
								<code>GreetingDetail</code> auf ein nicht bekanntes Property zugreifst?</li>
							<li>Was passiert, wenn Du im
								<code>GreetingDetail</code> den State mit
								<code>this.state = { . . .}</code> neu setzt?</code>
							</li>
							<li>Was passiert, wenn Du beim Aufrufen des
								<code>GreetingDetail</code> (
								<code>GreetingController</code>) ein zusätzliches Property übergibst?</li>
						</ul>
					</li>
				</ol>
			</section>

			<section>
				<h1>Anhang</h1>
			</section>
			<section id="t5">
				<h1>Teil V</h1>
				<h2>Testen (Überblick)</h2>
				<ul style="font-size:85%">
					<li>
						<a href="code/schritte/4-test/public/index.html" target="_blank">Ziel-Anwendung</a>
						<li>
							<a href="code/schritte/4-test/test-report.html">Test Report</a>
							<li>
								<a href="code/schritte/4-test/coverage/lcov-report/index.html">Coverage Report</a>
				</ul>
			</section>

			<section data-transition="slide none">
				<h2>Was testen wir überhaupt?</h2>
				<ul>
					<li class="fragment">
						<b>UI-unabhängige Logik</b> (z.B. Services, Backend-Calls)</li>
					<li class="fragment">
						<b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)</li>
					<li class="fragment">
						<b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)</li>
					<li class="fragment">
						<b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit history, Titelzeile,
						Scrollbars etc)</li>
				</ul>
			</section>

			<section data-transition="none">
				<h2>Was testen wir überhaupt?</h2>
				<ul>
					<li style="color: lightgrey">
						<b>UI-unabhängige Logik</b>
					</li>
					<li>
						<b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)
						<b>React-spezifisch!</b>
					</li>
					<li>
						<b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)
						<b>React-spezifisch!</b>
					</li>
					<li style="color: lightgrey">
						<b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit history, Titelzeile,
						Scrollbars etc)</li>
				</ul>
			</section>

			<section>
				<h2>Anforderungen</h2>
				<ul>
					<li class="fragment">Komponenten müssen im Test gerendert werden können</li>
					<li class="fragment">Gerenderte Komponenten/HTML-Elemente müssen gefunden und validiert werden</li>
					<li class="fragment">Zustand und Properties der Komponenten müssen veränderbar sein</li>
					<li class="fragment">Events müssen getriggert oder simuliert werden können</li>
					<li class="fragment">Interaktion mit DOM muss evtl möglich sein</li>
				</ul>
			</section>

			<section>
				<h1>Jest</h1>
				<p>
					<em>"Painless JavaScript Testing" (
						<a href="http://facebook.github.io/jest/" target="_blank">http://facebook.github.io/jest/</a>)</em>
				</p>
				<p class="fragment">Vollständige Test-Lösung, wird von Facebook für Testen von React verwendet:</p>
				<ul class="fragment">
					<li class="fragment">Test Runner</li>
					<li class="fragment">Specs, Assertions, Mocks</li>
					<li class="fragment">Code Coverage</li>
					<li class="fragment">Snapshot testing</li>
				</ul>
			</section>
			<section>
				<h3>Beispiel: Ein einfacher Test</h3>
				<pre><code class="javascript" contenteditable data-trim>// sum.js
export const sum = (a,b) => a+b;
</code></pre>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
    expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
    expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
			</section>
			<section>
				<h3>React Test Renderer</h3>
				<p>
					<a href="https://www.npmjs.com/package/react-test-renderer">https://www.npmjs.com/package/react-test-renderer</a>
				</p>
				<p>Rendert React Komponenten in JSON Objekte (ohne DOM):</p>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
const component = renderer.create(
        &lt;GreetingMaster greetings={someGreetings} />
);

console.log(component.toJSON());
            </code></pre>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>
{ type: 'div',
  props: {},
  children:  [
    { type: 'table', props: {}, children: [Object] },
    { type: 'button', props: [Object], children: [Object] }
  ]
}
            </code></pre>

			</section>
			<section>
				<h3>"Snapshot Testing" mit Jest</h3>
				<p>
					<code>expect(obj).toMatchSnapshot()</code> vergleicht ein JSON-Objekt mit einer gespeicherten Datei:</p>
				<ul>
					<li class="fragment">Bei
						<b>erster</b> Ausführung: legt Snapshot-File an (
						<a href="images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
						<ul>
							<li class="fragment">Snapshotdateien werden in Git versioniert</li>
						</ul>
					</li>
					<li class="fragment">Bei
						<b>folgenden</b> Ausführungen: erzeugt neuen Snapshot und vergleicht mit gespeichtertem Snapshot
					</li>
					<li class="fragment">Wenn Snapshots unterschiedlich
						<ul>
							<li>Fehler samt Diff (
								<a href="images/jest-snapshot-diff.png" target="_blank">Beispiel</a>)</li>
							<li>Im Watch Mode kann Snapshot aktualisiert werden
								<img src="images/jest-snapshot-update.png">
							</li>
						</ul>
					</li>

				</ul>
			</section>

			<section>
				<h3>Snapshot Testing mit Jest und React</h3>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';

test('it should render correctly', () => {

  const someGreetings = [ . . . ];

  const component = renderer.create(
    &lt;GreetingMaster greetings={someGreetings} />
  );

  expect(component.toJSON()).toMatchSnapshot();
});
            </code></pre>
				<p class="fragment">
					<em>Snapshot sagt nicht, ob UI richtig oder falsch gerendert wird, sondern nur, ob sie verändert wurde!</em>
				</p>
			</section>

			<section>
				<h3>Enzyme</h3>
				<p>
					<em>JavaScript Testing utilities for React (
						<a href="http://airbnb.io/enzyme/" target="_blank">http://airbnb.io/enzyme/</a>)</em>
				</p>
				<p>Bibliothek mit Funktionen zum Testen von React Komponenten</p>
				<ul>
					<li class="fragment">Rendern von Komponenten:
						<ul>
							<li>
								<b>shallow</b> zum "flachen" Rendern einer Komponente</li>
							<li>
								<b>mount</b> zum Rendern einer Komponete in einen (headless) DOM, z.B. jsdom</li>
						</ul>
					</li>
					<li class="fragment">Navigieren durch den DOM und Suchen von Elementen und Komponenten</li>
					<li class="fragment">Modifizieren von Komponenten und Auslösen von Events</li>
				</ul>
			</section>

			<section>
				<h3>Testen einer Komponente mit Jest und Enzyme</h3>
				<pre class="fragment"><code class="javascript" contenteditable data-trim>import {mount} from 'enzyme';
import GreetingController from '...';
import GreetingDetail from '...';
test('it should open detail view on button click', () => {
    // mount the component into a real dom (implemented by JSDom)
    const component = mount(&lt;GreetingController  />);

    // on initial render the list with greetings (GreetingMaster)
    // is visible but no GreetingDetail
    expect(component.find(GreetingDetail)).toHaveLength(0);

    // find the "add" Button...
    const addButton = component.find('button');

    // click on the button
    addButton.simulate('click');

    // now the GreetingDetail should be visible
    expect(component.find(GreetingDetail)).toHaveLength(1);
});
            </code></pre>
			</section>

			<section id="t6">
				<h1>Teil VI (Überblick)</h1>
				<h2>Client-seitiges Routing</h2>
				<a href="code/schritte/router-v4/public/index.html" target="_blank">Ziel-Anwendung</a>
			</section>
			<section>
				<h2>Warum Routing?</h2>
				<span class="fragment">
					<p>Mappen von URLs auf Komponenten
						<br>
						<span style="font-size: 80%">(Navigation findet ohne Server-Roundtrip statt)</span>
					</p>
				</span>
				<span class="fragment">
					<p>Komponenten halten (Teil) des Zustandes der Anwendung
						<br>
						<span style="font-size: 80%">Welche Komponente ist sichtbar (Master oder Detail)?</span>
						<br>
						<span style="font-size: 80%">Welche Daten werden dafür geladen (z.B. Greeting Id)</span>
					</p>
				</span>
			</section>

			<section>
				<h2>Herausforderungen</h2>
				<p class="fragment">Auf Änderungen der URL reagieren
					<br>
					<span style="font-size: 80%">Ableiten des Zustandes aus der URL
						<br>Wenn sich die URL ändert, kein Server roundtrip</span>
				</p>
				<p class="fragment">Hierarchische Komponentenstrukturen</p>
				<p class="fragment">Beim Klick auf Links etc aktualisieren der URL</p>
			</section>

			<section>
				<h2>React Router</h2>
				<ul>
					<li>Kein Bestandteil von React</li>
					<li>Sehr häufig verwendet (de-facto Standard)</li>
					<li>Aktuelle Version 4:
						<a href="https://reacttraining.com/react-router/" target="_blank">
							https://reacttraining.com/react-router/</a>
					</li>
				</ul>
			</section>
			<section>
				<h3>Router</h3>
				<p class="fragment">Top-Level-Objekt, das einmalig (oben) in der Komponenten Hierarchie eingebunden werden muss</p>
				<p class="fragment">Mehrere Ausprägungen zum Arbeiten mit den URL und der Browser History:
					<ul>
						<li class="fragment">
							<b>HashRouter</b>: codiert Pfad in angehängten Hash (#/greetings)</li>
						<li class="fragment">
							<b>BrowserRouter</b>: codiert Pfad direkt in URL (/greetings)</li>
					</ul>
				</p>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router} from "react-router-dom";

const app = &lt;Router>&lt;GreetingController/>&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
            </code></pre>
			</section>

			<section>
				<h3>Route</h3>
				<ul>
					<li class="fragment">Kann überall in der Anwendung verwendet werden, wo Pfad-abhängig Komponenten ausgewählt werden sollen</li>
					<li class="fragment">Mit
						<code>path</code> wird der Pfad übergeben, für den die Route matchen soll</li>
					<li class="fragment">Mit
						<code>component</code> wird die Komponente übergeben</li>
				</ul>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route} from "react-router-dom";

const app = &lt;Router>
    &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
    &lt;Route path="/" component={GreetingController}/>
&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
            </code></pre>
			</section>
			<section>
				<h3>Route</h3>
				<ul>
					<li class="fragment">Statt einer Komponente kann eine Funktion übergeben werden, die eine Komponente zurückliefert</li>
					<li class="fragment">Ermöglicht es, zusätzliche Properties an die Komponente zu übergeben</li>
					<li class="fragment">Kann unterschiedliche Komponenten zurückliefern (z.B. für Authorisierung) </li>
					<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/"
  render={() => {
    return loggedIn ? &lt;GreetingMaster greetings={initialGreetings} />
                    :
                    &lt;LoginForm />
                    }
/>
            </code></pre>
				</ul>
			</section>
			<section>
				<h3>Pfade</h3>
				<ul>

					<li class="fragment">Sind per Default gültig für Teilstrings</li>
					<li class="fragment">Mit
						<code>exact</code> kann das Verhalten verändert werden
						<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// trifft zu für / und /greeting
&lt;Route path="/" component={GreetingController}/>
// trifft nur zu für /
&lt;Route path="/" exact component={GreetingController}/>
            </code></pre>
					</li>
					<li class="fragment">Route ohne
						<code>path</code> matcht immer</li>
					<li class="fragment">Kann variable Segmente enthalten:
						<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/greeting/:greetingId"
          component={&lt;GreetingDisplay />} />

// in GreetingDisplay kann die greetingId über
// this.props.match.params.greetingId abgefragt werden
            </code></pre>

					</li>
				</ul>
			</section>
			<section>
				<h3>Switch</h3>
				<ul>
					<li class="fragment">Wenn mehrere path-Ausdrücke matchen, werden mehrere Komponenten gerendert (z.B. "/" und "/greetings")</li>
					<li class="fragment">
						<code>Switch</code> sorgt dafür, dass nur die erste Komponente im Block gerendert wird</li>
				</ul>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route, Switch} from "react-router-dom";

const app = &lt;Router>
  &lt;Switch>
    &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
    &lt;Route path="/" component={GreetingController}/>

    // "No match": ohne Pfad
    &lt;Route component={NotFoundPage}/>

  &lt;/Switch>
&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
            </code></pre>
			</section>

			<section>
				<h3>Router Properties für Komponente</h3>
				<p>Der Router übergibt drei Properties an die gerenderte Komponente (oder an die
					<code>render()</code>-Funktion)</p>
				<ul>
					<li class="fragment">
						<code>match</code>: Enthält u.a. die Parameter aus dem Pfad (
						<code>match.params.xyz</code>)</li>
					<li class="fragment">
						<code>history</code>: Zum Arbeiten mit der History (z.B.
						<code>push()</code> zum Navigieren)</li>
					<li class="fragment">
						<code>location</code>: Der aktuelle Pfad (z.B.
						<code>pathname</code>,
						<code>search</code>)</li>
				</ul>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
const HelloComponent = ({match, history, location}) => (
  &lt;div>
    &lt;h1>Hello, {match.params.name}&lt;/h1>
    &lt;small>The current path is: {location.pathname}&lt;/small>
    &lt;button onClick={() =&gt; history.push('/greetings')}>Show Greetings&lt;/button>
  &lt;/div>
);

// ...
&lt;Route path="/greet/:name" component={HelloComponent}/>

            </code></pre>
			</section>

			<section>
				<h3>Links</h3>
				<p>Mit
					<code>Link</code> und
					<code>NavLink</code> können Links erzeugt werden</p>
				<ul>
					<li>Mit
						<code>to</code> wird das Ziel angegeben</li>
					<li>Gerendert wird per default ein
						<code>a</code> Element</li>
					<li>URL wird entsprechend der History (Browser oder Hash) erzeugt</li>
					<li>Mit
						<code>activeClassName</code> und
						<code>activeStyle</code> auf
						<code>NavLink</code> können Styles übergeben werden, die angewendet werden, wenn der Link der aktiven Route entspricht
				</ul>
				<pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {Link, NavLink} from "react-router-dom";
&lt;Link to='/greetings'>Show all greetings&lt;/Link>
&lt;NavLink to='/greeting/me' activeClassName="highlight">Greet me&lt;/NavLink>

            </code></pre>
			</section>

			<section>
				<h2>Geschafft ;-)</h2>
				<h3>Vielen Dank für Eure Teilnahme!</h3>
				<p>Kontakt: nils@nilshartmann.net</p>
			</section>


		</div>

	</div>

	<script src="reveal.js/lib/js/head.min.js"></script>
	<script src="reveal.js/js/reveal.js"></script>
	<script src="lib/jquery-2.2.4.js"></script>

	<script>
		Reveal.addEventListener('ready', function (event) {
			if (window.location.hostname.indexOf('localhost') !== -1) {
				// only applies to presentation version
				Reveal.configure({ controls: false });
			} else {
				// only applies to public version
				//            $('.fragment').removeClass('fragment');
			}
			// applies to all versions
			$('code').addClass('line-numbers');
			//        $('.fragment').removeClass('fragment');
		});
	</script>


	<script>

		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [
				{
					src: 'reveal.js/lib/js/classList.js', condition: function () {
						return !document.body.classList;
					}
				},
				{
					src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
						return !!document.querySelector('[data-markdown]');
					}
				},
				{
					src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
						return !!document.querySelector('[data-markdown]');
					}
				},
				{
					src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
						return !!document.querySelector('pre code');
					}, callback: function () {
						hljs.initHighlightingOnLoad();
					}
				},
				{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
				{ src: 'reveal.js/plugin/notes/notes.js', async: true },
				{ src: 'lib/js/line-numbers.js' }
			]
		});

	</script>

</body>

</html>
