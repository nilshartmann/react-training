<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>TypeScript &amp; State</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem;">
            <b>React hands-on</b>
          </h2>
          <h3>
            TypeScript &amp; State
          </h3>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Vorbereitung</span></h3>
            <p>
              <span class="transparent-bg"
                >git clone https://github.com/nilshartmann/react-training</span
              >
            </p>
          </div>
          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: react-training/2021_04_19_typescript_state.html</span
              >
            </p>
          </div>
        </section>

        <section>
          <img src="slides/images/Deckblatt_devmedia_Trainings.png" />
        </section>

        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center;">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px;">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px;">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px;"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Agenda

            * **Tag 1: TypeScript und React** 

            * TypeScript: Fortgeschrittene Typen
            * React: Klassen API vs. Hooks API
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Agenda

            * **Tag 2: React** 

            * State: Wie kommt der State dahin, wo wir ihn hinhaben m√∂chten? Wie k√∂nnen wir den State effizient ver√§ndern?
            * Arbeiten mit HTTP Endpunkten: React Bibliotheken zur Verwaltung von Daten (√úbersicht)
            * Performance-Analysen
            * √úbersicht: welche Ans√§tze zum Stylen von Komponenten gibt es?
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen vs Hooks</h3>
          <ul>
            <li class="fragment"><em>Gemeinsamkeiten Klassen und Funktionskomponenten</em></li>
            <li class="fragment">State: neu rendern</li>
            <li class="fragment">Properties</li>
            <li class="fragment">Komponente gibt UI zur√ºck</li>
            <li class="fragment">Lebenszyklus: render und commit-Phase</li>
            <li class="fragment">Deklarativ</li>
            <li class="fragment">Klassen und Funktionen k√∂nnen in einer App gemischt werden</li>
            <li class="fragment">Klassen sind nicht deprecated</li>
            <li class="fragment">Neue Features evtl. nur f√ºr funktionen</li>
          </ul>
        </section>
        <section>
          <h3>Warum dann Funktionskomponenten?</h3>
          <ul>
            <li class="fragment">Einfacher (?) zu implementieren</li>
            <li class="fragment">
              "Klassen verwirren Menschen und Computer" (aus dem Blogpost zur Vorstellung der Hooks
              API)
            </li>
            <li class="fragment">Besseres Tooooling m√∂glich</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>

          <p>Eine Komponente...</p>

          <pre class="fragment"><code class="javascript">
              class Search extends React.Component {
                state = {
                  loading: false
                };
              
                async componentDidMount() {
                  if (!this.props.searchString) {
                    return;
                  }
                  this.setState({
                    loading: true
                  });
                  const result = await executeSearchApiCall(this.props.searchString);
                  this.setState({
                    result
                  });
                }
              
                render() {
                  if (!this.state.result) {
                    return null;
                  }
              
                  if (this.state.loading) {
                    return &lt;h2>Searching...&lt;/h2>;
                  }
              
                  return (
                    &lt;div>
                    &lt;h2>Search Result:&lt;/h2>
                    &lt;p>{this.state.result}&lt;/p>
                    &lt;/div>
                  );
                }
              }           
             </code></pre>

          <p class="fragment">Was passiert, bei dem folgenden Aufruf?</p>

          <pre class="fragment"><code class="javascript">
&lt;Search searchString="React" />               
             </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Eine Komponente...</h3>
          <p>Der State wird nicht korrekt gesetzt: setState f√ºhrt zusammen!</p>

          <pre class="fragment"><code class="javascript">
    async componentDidMount() {
      if (!this.props.searchString) {
        return;
      }
      this.setState({
        loading: true
      });
      const result = await executeSearchApiCall(this.props.searchString);

      // loading weiterhin auf true!
      this.setState({
        result
      });
    }
  </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>

          <p>
            Welche Probleme hat die folende Implementierung, jetzt mit korrekter
            "componentDidMount"-Methode?
          </p>

          <pre class="fragment"><code class="javascript">
            class Search extends React.Component {
              state = {
                loading: false
              };
            
              async componentDidMount() {
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  loading: false,
                  result
                });
              }
            
              render() {
                if (!this.state.result) {
                  return null;
                }
            
                if (this.state.loading) {
                  return &lt;h2>Searching...&lt;/h2>;
                }
            
                return (
                  &lt;div>
                  &lt;h2>Search Result:&lt;/h2>
                  &lt;p>{this.state.result}&lt;/p>
                  &lt;/div>
                );
              }
            }                
          </code></pre>
          <p class="fragment">Was passiert, wenn <b>searchString</b> sich √§ndert?</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>
          <p>Jetzt mit componentDidUpdate...</p>

          <pre class="fragment"><code class="javascript">
async componentDidMount() {
    if (!this.props.searchString) {
      return;
    }
    this.setState({
      loading: true
    });
    const result = await executeSearchApiCall(this.props.searchString);
    this.setState({
      result,
      loading: false
    });
  }

  async componentDidUpdate() {
    if (!this.props.searchString) {
      return;
    }
    this.setState({
      loading: true
    });
    const result = await executeSearchApiCall(this.props.searchString);
    this.setState({
      result,
      loading: false
    });
  }            
          </code></pre>

          <p class="fragment">Endlosschleife! üò±</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>
          <p>Reparierte Callback-Methoden: Wir m√ºssen die Properties √ºberpr√ºfen!</p>

          <pre class="fragment"><code class="javascript">
              async componentDidMount() {
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  result,
                  loading: false
                });
              }
            
              async componentDidUpdate(prevProps: SearchProps) {
                if (this.props.searchString === prevProps.searchString) {
                  // do not update if nothing changed
                  return;
                }
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  result,
                  loading: false
                });
              }
                        </code></pre>

          <p class="fragment">Funktioniert üòä</p>
          <p class="fragment">aber: viel redundanter Code üòû</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>

          <p>Gemeinsame Logik auslagern</p>

          <pre class="fragment"><code class="javascript">
              async componentDidMount() {
                this.search();
              }
            
              async componentDidUpdate(prevProps: SearchProps) {
                if (this.props.searchString === prevProps.searchString) {
                  // do not update if nothing changed
                  return;
                }
            
                this.search();
              }
            
              async search() {
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  result,
                  loading: false
                });
              }
            </code></pre>

          <p class="fragment">Ganz gut, aber:</p>
          <p class="fragment">Fachlichkeit "Suchen" auf drei Methoden verteilt</p>
          <p class="fragment">
            Was w√ºrde passieren, wenn wir nicht nur suchen, sondern noch zweiten Use-Case haben, der
            technisch √§hnlich implementiert ist?
          </p>
          <p class="fragment">
            Wie k√∂nnten wir den Such-Code verallgemeinern und mehreren Komponenten zur Verf√ºgung
            stellen?
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API: Lebenszyklus</h3>
          <p>
            Unsere Suche dauert sehr lange! Die Komponente wird vor erhalten des Ergebnisses
            entfernt. Was passiert?
          </p>
          <img
            class="fragment"
            src="slides/images/cant-perform-update-on-unmounted-component.png"
          />
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API: Lebenszyklus</h3>
          <p>Wir m√ºssen componentWillUnmount implementieren</p>

          <pre class="fragment"><code class="javascript">
            class Search extends React.Component {
              state: SearchState = {
                loading: false
              };
            
              // track if component is still mounted
              componentMounted = true;

              componentWillUnmount() {
                this.componentMounted = false;
              }            
            
              async search() {
                // as before
                const result = await executeSearchApiCall(this.props.searchString);

                // component might be unmounted now
                if (!this.componentMounted) {
                  console.log("Compontent already unmounted!");
                  return;
                }
                this.setState({
                  result,
                  loading: false
                });
              }
            
          </code></pre>
        </section>

        <section>
          <h3>Klassen API: Lebenszyklus</h3>
          <p>
            Was passiert eigentlich, wenn die Search-Komponente mit unterschiedlichen Properties,
            zweimal hintereinader gerendert wird?
          </p>
          <p class="fragment">Es werden zwei Suchen gestartet...</p>
          <p class="fragment">Was passiert, wenn die zweite schneller ist als die erste?</p>

          <pre class="fragment"><code class="javascript">
            class Search extends React.Component {

              // ...
            
              async search() {
                // ...
                const result = await executeSearchApiCall(this.props.searchString);

                if (!this.componentMounted) {
                  return;
                }
                this.setState({
                  result,
                  loading: false
                });
              }
            
          </code></pre>
          <p class="fragment">Die 1. Suche "√ºberschreibt" das Ergebnis der 2.-Suche!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Error Boundaries: hier sind Klassen ein Muss!</h3>
          <p>
            Um ein <a href="https://reactjs.org/docs/error-boundaries.html">Error Boundary</a> zu
            implementieren, <b>m√ºsst</b> ihr eine Klasse verwenden. Das geht mit Funktionen nicht!
          </p>
          <p>
            Tipp: Ihr solltet in jedem Fall mind. ein Error Boundary um Eure ganze Anwendung legen,
            um im Fall der F√§lle zumindest eine freundliche Fehlermeldung auszugeben
          </p>
          <p class="todo">beispiel!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Funktionskomponenten</h3>
          <ul>
            <li class="fragment todo">Slide an andere Stelle!</li>
            <li class="fragment">Funktionskomponenten gibt es schon l√§nger in React</li>
            <li class="fragment">Fr√ºher auch Stateless Functional Components (SFC) genannt</li>
            <li class="fragment">
              Man hatte darin keine M√∂glichkeit State zu verwenden oder am Lebenszyklus zu
              partizipieren
            </li>
            <li class="fragmnet">
              Also man konnte eigentlich nur Properties entgegennehmen und etwas rendern
            </li>
            <li class="fragment">Warum war diese Art von Komponenten (trotzdem) n√ºtzlich? ü§î</li>
            <li class="fragment">
              Funktionskomponenten API plus Hooks API = vollwertiger Klassen API Ersatz
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Unterschied Ref, State und Props: was wof√ºr?</h3>
          <ul>
            <li>Properties: Informationen von au√üen, d√ºrfen nicht ver√§ndert werden</li>
            <li>
              State: "Render-relevante" Informationen innerhalb der Komponente. D√ºrfen ver√§ndert
              werden.
            </li>
            <li>
              Ref: H√§lt Informationen, die f√ºr das Rendern irrelevant sind, aber √ºber mehrere
              Renderzyklen erhalten bleiben sollen (z.B. eine ID). In Klassen API w√ºrden hier
              Instanz-Variablen verwendet
            </li>
          </ul>
          <p class="todo">
            Timer Beispiel aus heise-Artikel
            https://www.heise.de/hintergrund/Ein-Jahr-React-Hooks-API-eine-Bilanz-4643554.html?seite=all
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Funktionskomponenten mit Hooks</h3>
          <ul>
            <li class="fragment">
              Funktionskomponenten gibt es schon lange in React, aber erst mit der Hooks API (16.8)
              wurden sie gleichwertig zu Klassenkomponenten
            </li>
            <li class="fragment">
              Mit React Hooks kann sich eine Komponente in Zustand und Lebenszyklus "einhaken"
            </li>
            <li class="fragment">
              Hooks machen Funktionskomponenten damit aus Feature-sicht gleichwertig mit
              Klassenkomponenten
            </li>
            <li class="fragment">
              Es gibt eingebaute Hooks (useState, useEffect etc.) und man kann eigene Hooks
              schreiben ("Custom Hooks")
            </li>
            <li class="fragment">
              <b
                >Die Hooks API bzw. eigene Hooks erlauben es Euch, wiederverwenbaren Code zu
                schreiben</b
              >, den ihr in diversen Komponenten einsetzen k√∂nnt
            </li>
            <li class="fragment">
              Ihr k√∂nnt Hooks auch in eigene Module auslagern und anderen Teams/Projekten zur
              Verf√ºgung stellen
            </li>
            <li class="fragment">
              Hooks sind technisch normale Funktionen, ihr k√∂nnt R√ºckgabewert und Parameter v√∂llig
              frei w√§hlen
            </li>
            <li class="fragment">
              Hooks setzen das React Prinzip √§hnlich wie Komponenten um: wenn in einem Hook etwas
              ge√§ndert wird, wird der Hook und die verwendenden Komponente neu gerendert!
            </li>
            <li class="fragment">
              Ich las mal den Satz: Hooks sind wie Komponenten nur ohne die Begrenzung auf Props als
              Parameter und UI als R√ºckgabewert...
            </li>
          </ul>
        </section>

        <section>
          <h3>Hook vs Komponente</h3>
          <p class="todo">Andere Reihenfolge</p>

          <pre class="fragment"><code class="javascript">
            // eine Komponente...
            function Dialog(props) {
              const { title, text } = props;
              const [visible, setVisible] = React.useState(true);

              if (!visible) { return null; }

              return &lt;div className="Dialog">
                &lt;h1>{title}&lt;h1>
                &lt;p>{text}&lt;/p>
                &lt;button onClick={() => setVisible(false)}>Close&lt;/button>
            }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // ein hook...
            function useDialog(props) {
              const { title, text } = props;
              const [visible, setVisible] = React.useState(true);

              if (!visible) { return null; }

              return &lt;div className="Dialog">
                &lt;h1>{title}&lt;h1>
                &lt;p>{text}&lt;/p>
                &lt;button onClick={() => setVisible(false)}>Close&lt;/button>
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Hooks vs Komponente 2</h3>
          <pre class="fragment"><code class="javascript">
            // eine Komponente...
            function InfoDialog(props) {
              const { text } = props;

              return &lt;Dialog title="info" text={text} />
            }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // ein hook...
            function useInfoDialog(props) {
              // wie sieht der useInfoDialog aus, der den useDialog-Hook verwendet?
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Search-Komponente als Funktion</h3>

          <pre class="fragment"><code class="javascript">
            function Search({ searchString }) {
              const [loading, setLoading] = React.useState(false);
              const [result, setResult] = React.useState();
            
              React.useEffect(() => {
                let cancelled = false;
                async function search() {
                  setLoading(true);
                  const searchResult = await executeSearchApiCall(searchString);
                  if (cancelled) {
                    console.log("already cancelled");
                    return;
                  }
                  setLoading(false);
                  setResult(searchResult);
                }
            
                search();
            
                return () => {
                  cancelled = true;
                };
              }, [searchString]);
            
              if (loading) {
                return &lt;h2>Searching...&lt;/h2>;
              }
            
              if (!result) {
                return null;
              }
            
              return (
                &lt;div>
                &lt;h2>Search Result:&lt;/h2>
                &lt;p>{result}&lt;/p>
                &lt;/div>
              );
            }
            
          </code></pre>
        </section>
        <section>
          <h3>Search-Komponente als Funktion</h3>

          <ul>
            <li class="fragment">
              Fachlichkeit "Suche durchf√ºhren" ist an einer Stelle konzentriert (useEffect-Hook).
              Wir k√∂nnten sie sogar mit einem Custom Hook rausziehen
            </li>
            <li class="fragment">
              Lebenszyklus ist mehr oder weniger sauber abgebildet: R√ºckgabe-Wert ist die
              "Aufr√§um-Funktion", wann der Hook ausgef√ºhrt wird, wird mit dem Dependency Array
              beschrieben
            </li>
            <li class="fragment">
              Wir haben hier zwei States, ob das in diesem Fall besser ist, sei dahin gestellt, denn
              die beiden State-Eintr√§ge sind nicht unabh√§ngig. Wir k√∂nnten aber ein Objekt verwenden
            </li>
            <li class="fragment">
              Das Objekt wird mit der setter-Funktion dann komplett gesetzt und nicht
              zusammengef√ºhrt (wie in setState), das ist m√∂glicherweise erwartungskonformer
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendering</h3>
          <p>
            Wir √ºbergeben eine Callback-Funktion ("resultFormatter"), mit der das Surch-Ergebnis vor
            der Darstellung formatiert werden soll. Was m√ºssen wir beim Verwenden beachten?
          </p>

          <pre class="fragment"><code class="javascript">
                function App() {
                  function myFormatter(s) { return s.toUpperCase(); }

                  return &lt;Search searchString={...} resultFormatter={myFormatter} />
                }

                function Search({ searchString, resultFormatter }) {
                  const [loading, setLoading] = React.useState(false);
                  const [result, setResult] = React.useState();
                
                  React.useEffect(() => {
                    let cancelled = false;
                    async function search() {
                      setLoading(true);
                      const searchResult = await executeSearchApiCall(searchString);
                      if (cancelled) {
                        console.log("already cancelled");
                        return;
                      }
                      setLoading(false);
    
                      // Ergebnis formatieren
                      const formattedResult = resultFormatter(searchResult);
                      setResult(formattedResult);
                    }
                
                    search();
                
                    return () => {
                      cancelled = true;
                    };
                  }, [searchString, resultFormatter]);
                
                  if (!result) {
                    return null;
                  }
                
                 // ab hier unver√§ndert: Loading oder Such-Ergebnis anzeigen
                }
                
              </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendering</h3>
          <ul>
            <li class="fragment">
              Wenn eine Komponente sich neu rendert, werden alle Funktionen darin neu "erzeugt", sie
              sind also "neu"
            </li>
            <li class="fragment">
              Wenn Funktionen im Dependency-Array angegeben werden, f√ºhrt das dazu, dass der Effekt
              neu ausgef√ºhrt wird
            </li>
            <li class="fragment">
              Das kann richtig oder falsch sein. In unserem Beispiel wollen wir das <b>nicht</b>
            </li>
            <li class="fragment">
              Wir m√ºssen beim Aufrufer daf√ºr sorgen, dass dieser eine "stabile" Funktion √ºbergibt
            </li>
            <li class="fragment">
              Mit <code>useCallback</code> k√∂nnen wir eine Funktion √ºber mehrere Renderzyklen hinweg
              stabil halten
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function App() {
              function myFormatter(s) { return s.toUpperCase(); }

              return &lt;Search searchString={...} resultFormatter={myFormatter} />
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>A propos Such-Ergebnis formatieren...</h3>
          <ul>
            <li class="fragment">
              Unabh√§ngig vom technischen Problem: ist unsere Implementierung "gut"?
            </li>
            <li class="fragment">
              Was k√∂nnten wir besser machen? Was w√§re vielleicht mehr "React-like"?
            </li>
            <li class="fragment">
              Insb: vielleicht soll der Formatter ver√§ndert werden, w√§hrend der Request l√§uft und
              nach Request-Ende dann f√ºr das Ergebnis verwendet werden?
            </li>
          </ul>
          <ul>
            <li class="fragment">
              "Abgeleitete" Daten werden in der Regel in React nicht in den State gelegt
            </li>
            <li class="fragment">Man w√ºrde wahrscheinlich den formatter beim rendern verwenden</li>
            <li class="fragment">
              Vorteil: der formatter ist immer aktuell (beeinflusst aber den Request nicht)
            </li>
            <li class="fragment">
              Keine Inkosistenzen (stellt euch vor, wir setzen den Result-State noch an einer
              anderen Stelle...
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useCallback-Hook</h3>
          <ul>
            <li class="fragment">
              Auch der useCallback-Hook hat als zweiten Parameter ein Dependency-Array, das
              bestimmt, wie lange die Callback-Funktion g√ºltig ist
            </li>
            <li class="fragment">
              Im Gegensatz zu useEffect ist das Array hier <b>pflicht</b> und kann nicht weggelassen
              werden
            </li>
            <li class="fragment">Warum gibt es das Array? Was m√ºssen wir darein schreiben?</li>
          </ul>
        </section>

        <section>
          <h3>Hintergrund: Closures und Stale Data</h3>
          <p>Folgendes (fehlerhaftes!!!) Beispiel:</p>

          <pre class="fragment"><code class="javascript">
            function App() {
              const [search, setSearch] = React.useState("typescript");
              const [prefix, setPrefix] = React.useState("");

              const resultFormatter = React.useCallback(
                 function prefixFormatter(s) {return prefix + s}
              , []);

              return &lt;div>
                &lt;input value={change} onChange={...} />
                &lt;input value={prefix} onChange={...} />
                &lt;Search searchString={search} formatter={resultFormatter} />
              &lt;div>
            }
          </code></pre>

          <ol>
            <li class="fragment">Search starts with value="typescript" and formatter</li>
            <li class="fragment">User changes prefix (for example to "a")</li>
            <li class="fragment">App re-renders</li>
            <li class="fragment">
              App invokes Search component with value="typescript" and formatter (same as before)
            </li>
            <li class="fragment">Search finishes, formatter is called</li>
            <li class="fragment">What is prefix now in our formatter function?</li>
          </ol>
        </section>

        <section>
          <h3>Hintergrund: Closures und Stale Data</h3>
          <ul>
            <li class="fragment">
              In einer Closure werden die Daten aus dem umgebenen Kontext "eingefroren" mit dem
              Stand, wenn die Closure erzeugt wird
            </li>
            <li class="fragment">
              Die Formatter-Funktion wird also im fehlerhaften Beispiel <b>immer</b> den allerersten
              prefix zur√ºckliefern
            </li>
            <li class="fragment">
              Wollen wir auf den Prefix zugreifen, m√ºssen wir also eine neue formatter-Funktion
              erzeugen, wenn sich der Prefix √§ndert:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function App() {
              const [search, setSearch] = React.useState("typescript");
              const [prefix, setPrefix] = React.useState("");

              const resultFormatter = React.useCallback(
                 function prefixFormatter(s) {return prefix + s}
              , [prefix]);

              // ...
          </code></pre>
          <ul>
            <li class="fragment">
              Das hat (leider) zur Folge, dass nun die Search-Komponente eine neue Funktion erh√§lt
              und unsere Suche neue ausf√ºhrt
            </li>
            <li class="fragment">Habt ihr andere Ideen, wie wir das Problem l√∂sen k√∂nnten?</li>
            <li class="fragment">
              üëÜ Grunds√§tzlich gilt: <b>React vergleicht per Referenz</b>. Das gilt z.B. auch f√ºr
              <code>useState</code>, <code>useMemo</code> und <code>React.memo</code>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>
          <p class="fragment">Wie k√∂nnen wir die bauen, wenn wir "setTimeout" verwenden?</p>
          <p class="fragment">
            Zur Erinnerung
            <a
              href="https://developer.mozilla.org/de/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout"
              >setTimeout</a
            >-JavaScript-Funktion:
          </p>
          <pre class="fragment"><code class="javascript">
const timerId = setTimeout( 
  () => console.log("Nach f√ºnf Sekunden"), // 1. Paramter: Callback-Funktion
  5000 // 2. Parameter: Timeout in ms
);

// Bei Bedarf, mit clearTimeout den Timer vorzeitig beenden:
clearTimeout(timerId);
            </code></pre>
        </section>
        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>
          <p class="fragment">Wie k√∂nnen wir die bauen, wenn wir "setTimeout" verwenden?</p>

          <pre class="fragment"><code class="javascript">
// Sehr naive Implementierung... Was fehlt hier?            
function Message({ message }: MessageProps) {
  const [msgVisible, setMsgVisible] = React.useState(true);

  React.useEffect(() => {
    setTimeout(() => setMsgVisible(false), 2500);
  }, []);

  if (!msgVisible) {
    return null;
  }

  return &lt;h2>{message}&lt;/h2>;
}

          </code></pre>
        </section>

        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>

          <pre class="fragment"><code class="javascript">
// Mit Clean-Up-Funktion           

function Message({ message }: MessageProps) {
  const [msgVisible, setMsgVisible] = React.useState(true);

  React.useEffect(() => {
    const id = setTimeout(() => setMsgVisible(false), 2500);
    return () => {
      clearTimeout(id);
    };
  }, []);

  if (!msgVisible) {
    return null;
  }

  return &lt;h2>{message}&lt;/h2>;
}


          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Neue Anforderung: Per Button soll die Message f√ºr immer angezeigt werden k√∂nnen, der
            timeout muss also abgebrochen werden
          </p>

          <pre class="fragment"><code class="javascript">
              function Message({ message }: MessageProps) {
                const [msgVisible, setMsgVisible] = React.useState(true);
              
                React.useEffect(() => {
                  const id = setTimeout(() => setMsgVisible(false), 2500);
                  return () => {
                    clearTimeout(id);
                  };
                }, []);

                function handleOnClick() {
                   // ????
                }
              
                if (!msgVisible) {
                  return null;
                }
              
                return &lt;div>
                &lt;button onClick={handleOnClick}>Show Message forever&lt;/button>
                &lt;h2>{message}&lt;/h2>
                &lt;/div>;
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Mehr zu Hooks</h3>
          <ul>
            <li class="fragment">
              In einer "Referenz", die wir mit dem useRef-Hook erzeugen, k√∂nnen wir Daten √ºber
              Renderzyklen erhalten
            </li>
            <li class="fragment">Diese Daten liegen unter <code>ref.current</code></li>
            <li class="fragment">
              Das √§ndern der Daten f√ºhrt <b>nicht</b> zu einem neu rendern der Komponente!
            </li>
            <li class="fragment">
              Vergleichbar mit einer Instanz-Variablen in einer Klassen Komponente
            </li>
          </ul>
        </section>

        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>
          <p>Zusatzaufgabe:</p>
          <ol>
            <li class="fragment">
              Die Parent-Komponente rendert die Nachricht-Komponente und √ºbergibt ihr nicht nur eine
              Message, sondern auch die Dauer, wie lange diese Nachricht angezeigt werden soll, z.B.
              <b>f√ºnf Sekunden</b>
            </li>
            <li class="fragment">
              Die Parent-Komponente rendert sich nach <b>vier Sekunden</b> erneut, und √ºbergibt nun
              dieselbe Message, aber mit einer anderen Dauer (z.B. <b>sechs Sekunden</b>)
            </li>
            <li class="fragment">
              Die Message-Komponente soll die Dauer nun anpassen. Von <b>ersten</b> Rendern der
              Message bis zum Verschwinden, sollen nicht mehr Zeit vergehen als die √ºbergebene Dauer
              (also im Beispiel: <b>zwei Sekunden</b> nach dem zweiten Aufruf) ü§Ø
            </li>
          </ol>
          <p class="fragment">Puh... üòÆ kriegen wir das gemeinsam hin?</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Stale Data #2 (im Event Handler)</h3>
          <p>Was kann hier passieren?</p>
          <p class="todo">
            Beispiel?!: Laden von Daten bei onClick ("Load more"), das dauert. Daten sollen ans Ende
            eines Arrays ("loaded users") geh√§ngt werden. Das Array wurde w√§hrend des LAdens
            ver√§ndert (z.B. per Button gel√∂scht ("Clear Data"))
          </p>
          <p class="fragment">Asynchrones Verhalten und Stale Data im Event Handler</p>

          <p class="fragment">
            Einfacher Fall: setState-Callback-Funktion, um aktuellen Wert zu bekommen: setUsers(
            oldUsers => [...oldUsers, newLoadedUser]);
          </p>
          <p class="fragment">
            Komplizierter Fall: State lesen, ggf. mit Ref (nur besprechen, zu kompliziert)
          </p>
          <p class="fragment">
            Hinweis: das kann auch passieren, wenn sich die Properties ver√§ndert haben
            (Result-Formatter!). Was machen wir in diesem Fall? K√ºndigen! ü§Ø
          </p>
          <p class="fragment">
            https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function
          </p>
        </section>

        <!-- ============================================================================= -->

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hooks</h3>
          <ul>
            <li class="fragment">
              Custom Hooks erlauben es, wiederverwenbaren Code zu schreiben und zu teilen
            </li>
            <li class="fragment">
              Habt ihr Beispiele in euren bestehenden Anwendungen? Wo k√∂nnten Custom Hooks Sinn
              machen und helfen?
            </li>
          </ul>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p class="todo">Beispiel: Daten Laden (auch als √úbergang zum n√§chsten Thema)</p>
          <p>Beispiel: fetch Hook</p>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>
            Problem: (alle) Hooks d√ºrfen nur am Anfang stehen und m√ºssen in selber Reihenfolge
            gerendert werden
          </p>

          <pre class="fragment"><code class="javascript">
            function BlogPost({postId}) {
              const blogPost = useBlogLoader(postId); // ok

              return ...;
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            function BlogPost({postId}) {
              if (postId !== null) {
              const blogPost = postId != null ? useBlogLoader(postId) : null; // ????
              
              return ...;
            }
          </code></pre>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>
            Problem: (alle) Hooks d√ºrfen nur am Anfang stehen und m√ºssen in selber Reihenfolge
            gerendert werden
          </p>

          <p>Warum ist das eigentlich so?</p>
          <p>Hinweis auf Linter</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Data Libraries f√ºr React</h3>
          <ul>
            <li class="fragment">SWR und React Query und Redux Toolkit Query (und Apollo)</li>
            <li class="fragment">
              Anforderungen: Daten laden, Caching samt korrektem Invalidieren..., Requests sollen
              nicht bei jedem Rendern ausgef√ºhrt werden, globales(!) Caching: Daten sollen √ºber
              Komponetengrenzen und -wechsel erhalten bleiben, Fehlerbehandlung bzw. Abbildung
              Request-Lebenszyklus...
            </li>
            <li class="fragment">
              fetch: Browser Standard API, Low-Level, keinerlei Abstraktionen, quesi HTTP "pur"
            </li>
            <li class="fragment">
              axios bzw. redaxios: Quasi-standard (aber kein Browser API). Etwas h√∂hrere Abstraktion
              (z.B. HTTP Fehlercodes werden auf Exceptions gemappt, Payload automatisch von/nach
              JSON konvertiert). axios benutzt "Ajax", Redaxios selbe API aber basiert auf fetch
              (sehr kleine lib)
            </li>
            <li class="fragment">SWT, React Query und RTK Query, alle React-spezifisch</li>
            <li class="fragmnet">
              Die Idee ist bei allen √§hnlich und vermutlich von Apollo inspiriert: per Hooks API
              wird der Lebenszyklzs eines Requests abgebildet.
            </li>
            <li class="fragment">Je nach Request Status unterscheidet sich der R√ºckgabewert</li>
            <li class="fragmnent">
              Die gelesenen Daten werden global gecached, deswegen Provider-Kompponente (bzw. Redux
              bei RTK) notwendig
            </li>
            <li class="fragment todo">Beispiele</li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
            ### Klassen API mit TypeScript

            * State-Objekt und Props als Types
            * Argumente der Callback-Methoden m√ºssten Typ-Parameter haben
            * Wenn man nur State, aber keine Props hat, leeres Objekt angeben (s. App-Komponente)
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zur Erinnerung

            * **State**: Interner Zustand (Model) einer Komponente
            * **Properties**: Daten, die einer Komponente von au√üen √ºbergeben werden
            * Wenn sich **State** √§ndert, wird die Komponente (und alle Unterkomponenten) neu gerendert
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>State</h3>
          <ul>
            <li class="fragment">Darf nicht ver√§ndert werden</li>
          </ul>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            function UserEditor() {
              const [user, setUser] = React.useState({ name: "Klaus", age: 32});

              function onSetAge(newAge) {
                // ???
                user.age = newAge;
              }

              return &lt;input value={user.age} onChange={e => onSetAge(e.target.value)} />
            }
                        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>State</h3>
          <ul>
            <li class="fragment">Darf nicht ver√§ndert werden</li>
          </ul>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
          function UserEditor() {
            const [user, setUser] = React.useState({ name: "Klaus", age: 32});

            function onSetAge(newAge) {
              // ???
              user.age = newAge;
              // ???
              setUser(user);
            }

            return &lt;input value={user.age} onChange={e => onSetAge(e.target.value)} />
          }
                      </code></pre>
        </section>

        <section>
          <h3>Initialisieren von State</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
        function UserEditor() {
          const [user, setUser] = React.useState({ name: "Klaus", age: 32});

          // ...
        }
                    </code></pre>

          <h3 class="fragment">(Lazy) Initialisieren √ºber Callback-Funktion</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
                      function UserEditor() {
                        // Uebergebene Funktion muss Seiteneffekt-frei sein!
                        const [user, setUser] = React.useState( () => newUserObject() );
              
                        // ...
                      }
                                  </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
        // Objekt-Spread-Operator zum Kopieren und ver√§ndern

        const newObject = {
          ...oldObject, // altes Objekt hier "einf√ºgen"
          updatedProperty: "new value" // (ausgew√§hlte) Werte in NEUEM Objekt ver√§ndern
        }
                    </code></pre>
          <h3 class="fragment">Object-Spread-Operator kopiert nur "flach"</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// Beispiel mit Verschachtelung:
const oldPerson = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };                      

const newPerson = {
  ...oldPerson, // altes Objekt hier "einf√ºgen"

  // address muss nun auch kopiert werden:
  address: { ...newPerson.address, city: "Hamburg" } 
}
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <pre class="fragment"><code class="javascript">
        // Spread-Operator bei Arrays

        const oldArray = [ "b", "c" ];

        // Anf√ºgen eines Elementes
        const newArray = [
          "a",  // vorne anf√ºgen
          ...oldArray, // hier altes Array reinkopieren
          "c" // hinten anf√ºgen
        ]

      </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <h3 class="fragment">Ver√§ndern von Objekten in Arrays</h3>

          <pre class="fragment"><code class="javascript">
        // Ver√§ndern von Arrays:

        const newArray = oldArray.map(oldEntry => {
          if (oldEntry.id === "user-1") { // dieses Element soll ver√§ndert werden
            return { ...oldEntry, name: "Klaus" }
          }
          return oldEntry; // unver√§ndert
        });

        // newArray ist eine Kopie, mit ggf. ver√§nderten Eintr√§gen
      </code></pre>

          <h3 class="fragment">Eintr√§ge aus Arrays entfernen</h3>

          <pre class="fragment"><code class="javascript">
        const newArray = oldArray.filter(oldEntry => oldEntry.id === idToBeRemoved);

        // newArray ist eine Kopie ohne die rausgefilterten Eintraege
        
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
          ## Immer f√ºr Arbeiten mit unver√§nderlichen Datenstrukturen

          <img src="slides/images/immer.png" /> 

          * [ImmerJs](https://immerjs.github.io/immer/docs/introduction): _Create the next immutable state tree by simply modifying the current tree_
          * Konzept: altes Objekt wird in eine Funktion gesteckt, die daraus ein _Draft_ erzeugt
          * Das _Draft_ wird mit regul√§ren JavaScript APIs ver√§ndert, als wenn es mutable w√§re
          * Immer zeichnet die √Ñnderungen auf
          * Zum Schluss werden die √Ñnderungen auf eine Kopie des alten Objektes angewendet

        </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Immer: produce-Funktion</h3>

          <p>
            Die <b>produce</b>-Funktion bekommt ein Objekt √ºbergeben, sowie eine zweite Funktion,
            die von immer mit einem Draft aufgerufen wird.
          </p>
          <p>Dieses Draft kann ver√§ndert werden</p>
          <p>
            Der R√ºckgabe-Typ der produce-Funktion ist dann eine Kopie des alten Objektes mit den
            √Ñnderungen, die auf dem Draft vorgenommen wurden.
          </p>

          <pre class="fragment"><code class="javascript">
              import produce from "immer";

              const person = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };

              const newPerson = produce(person, draft => {
                person.name = "Susi";
                person.address.city = "Hamburg";
              })

              newPerson; // Neues Objekt!
              newPerson.name; // Susi
              newPerson.address // Neues Objekt!
              newPerson.address.city; // Hamburg
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Immer</h3>

          <pre class="fragment"><code class="javascript">
          function handleLastNameChange(newLastName: string) {
              const newUser = produce(user, draft => {
                // draft kann ver√§ndert werden, als ob es ein mutable Objekt sei
                draft.lastName = newLastName;
              })
            );
            setUser(newUser);
          }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          function handleContactTypeChange(contactId: string, newType: string) {
            setUser(
              produce(user, draft => {
                const ix = draft.contacts.findIndex(contact => contact.id === contactId);
                draft.contacts[ix].type = newType;
              })
            );
          }
        </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Hands-on! üë®‚Äçüíª
            ### Der Workspace

            * Unser heutiges Arbeitsverzeichnis f√ºr √úbungen ist `state/workspace`.
            * darin:
              * `npm install`
              * `npm start`
            
            * Die √úbungen sind alle in TypeScript. 
              * F√ºr das User "Domain-Objekt" findet ihr Typ-Beschreibung in `types.ts`
              * F√ºr alle anderen Typen (Properties an neuen Komponenten) m√ºsst ihr Euch keine M√ºhe geben, und k√∂nnt auf `any` zur√ºckfallen üòá  

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### M√∂gliche √úbung: Mit ES6 Operatoren und Immer vertraut machen</h3>

            * Verzeichnis: **state/workspace** 
            * In `App.tsx` die leeren Handler-Funktionen implementieren 
            * Du kannst jeweils ES6 Operatoren oder `produce` von immer verwenden, je nachdem was
            besser passt
            </textarea
          >
        </section>

        <section>
          <h3>N√§chster Schritt</h3>
          <h2>Zustand "verteilen"</h2>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### Erinnerung:

    * **Zustand** wird von Parent-Komponenten nach unten gereicht (√ºber **Properties**)
    * Die Unterkomponenten k√∂nnen den Zustand darstellen (oder andere Dinge davon ableiten), aber ihn nicht **ver√§ndern**
    * (Unterkomponenten k√∂nnen zus√§tzlich eigenen Zustand haben)
    * Oberkomponenten k√∂nnen au√üerdem Callback-Funktionen an ihre Unterkomponenten √ºbergeben
    * √úber die Callback-Funktionen k√∂nnen Unterkomponenten den Oberkomponenten Ereignisse schicken
    * Die Oberkomponente kann auf das Ereignis z.B. mit einer State-√Ñnderung reagieren, so dass Ober- und Unterkomponente neu gerendert werden
    * Das Durchreichen von State- und Callbacks ist √ºber mehr als eine Ebene erlaubt (und gew√∂hnlich)

    <img class="fragment" style="height:600px" src="slides/images/state/datenfluss.svg" />
  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel</h3>
          <pre class="fragment"><code class="javascript">
    function App() {
      const [user, setUser] = React.useState(...);

      function handleFullNameChange(newFullName: string) { setUser(...) }

      return &lt;...>
        &lt;TextInput label="Full Name" value={user.fullName} 
           onTextChange={handleFullNameChange} />
      &lt;...>
    }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          // kein eigener State!
          function TextInput(props) {
            return &lt;...>
              &lt;input value={props.value}
                 onChange={e => props.onTextChange(e.target.value)} />
            &lt;...>
          }
              </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### M√∂gliche √úbung

    * **Baue eine _TextInput_-Komponente.** Diese Komponente soll nur ein Wrapper um ein `input`-Element darstellen (also einen Wert entgegennehmen und eine Callback-Funktion, die 
    aufgerufen wird, wenn der Wert ver√§ndert wird). Setze die Komponente anstatt der `input`-Felder ein
    * **Baue eine _Passwort_-Komponente**. Auch diese Komponente soll nur ein Wrapper um ein `input`-Element darstellen. Allerdings soll sie noch eine M√∂glichkeit haben, dass man
    umstellen kann, ob das Passwort sichtbar oder unsichtbar angezeigt wird (`<input type="text" ... />` bzw. `<input type="password"... />`). Dazu kannst Du z.B. eine Checkbox-verwenden
    (`<input type="checkbox">`) Verwende diese Komponente f√ºr die Eingabe von `user.password`.

  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendern unterdr√ºcken</h3>
          <ul>
            <li class="fragment">
              Wenn sich der Zustand √§ndert, wird die Komponente und alle darunterliegenden
              Komponenten erneut gerendert
            </li>
            <li class="fragment">
              Nicht immer <b>m√ºssen</b> alle Komponenten aus fachlicher Sicht neu gerendert werden
            </li>
            <li class="fragment">
              Eine Komponente kann "memoiziert" werden, und rendert sich dann nur erneut, wenn
              mindestens <b>ein</b> Property sich ver√§ndert hat (Identit√§tsvergleich)
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
    // Nur neu rendern, wenn Properties sich ver√§ndert haben
    const InvalidContactDisplay = React.memo(function InvalidContactDisplay(props) {
      return ...;
    });

    // Verwendung wie gewohnt:
    &lt;InvalidContactDisplay contacts={...} />
  </code></pre>
          <p class="fragment">
            <b>Achtung!</b>: Diese Optimierungen bitte nicht auf "vorrat" vornehmen, sondern nur,
            wenn wirklich n√∂tig! Auch das Caching/Memoization hat seinen Preis!
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendern unterdr√ºcken: Stabile Funktionsreferenzen</h3>
          <ul>
            <li class="fragment">
              Wenn eine Komponente sich neu rendert, werden alle darin enthaltenen Funktionen "neu
              erzeugt"
            </li>
            <li class="fragment">
              Wenn eine solche Funktion als Callback-Funktion an eine memoizierte Komponente
              √ºbergeben wird, ist sie "ver√§ndert", es wird also neu gerendert
            </li>
            <li class="fragment">
              Mit <code>React.useCallback</code> k√∂nnen stabile Funktionsreferenzen erzeugt werden,
              die √ºber einen Renderzyklus hinaus g√ºltig sind:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
    function UserInput(props) {
      const handleFullNameChange = React.useCallback(function(...) { ... }, []);
    }
  </code></pre>

          <ul class="fragment">
            <li>
              Mit dem zweiten Paramater k√∂nnen - wie bei <code>React.useEffect</code> -
              Abh√§ngigkeiten angegeben werden, wann die Funktion neu erzeugt werden soll
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendern unterdr√ºcken: Stabile Funktionsreferenzen #2</h3>
          <ul>
            <li class="fragment">
              In einer "stabilen" Funktion m√ºsst ihr darauf achten, Werte, die ihr in der Funktion
              verwendet, als Dependency anzugeben
            </li>
            <li class="fragment">
              F√ºr den Zustand gibt es die M√∂glichkeit, die Callback-Notation von
              <code>setState</code> zu verwenden. Damit bekommst Du immer den aktuellen Wert des
              Zustandes, und brauchst ihn nicht in den Dependencies anzugeben:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
      const handleUpdate = React.useCallback(function()  {
        // der Callback-Funktion wird der aktuelle Zustand √ºbergeben
        // ihr R√ºckgabewert wird als neuer State gesetzt
        setState(oldState => ...);
      }, []);
    </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### M√∂gliche √úbung: Memoization von Komponenten

    * Die `TextInput`-Komponente soll sich nur neu rendern, wenn sich eines ihrer Properties ver√§ndert hat
    * Du musst die TextInput-Komponente als "memoizieren"
    * Und die Aufrufe an die Komponente anpassen?

  </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung von komplexem Zustand

        ## Reducer-Funktionen und useReducer-Hook
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung und √Ñnderung von Zustand

        * Wir halten den Zustand lokal in einer Komponente
        * S√§mtliche √Ñnderungen daran passieren innerhalb der Komponente
        * Mit einer reducer-Funktion kann die Verwaltung des Zustandes aus der Komponente herausgel√∂st werden
        * Warum sollte man das tun? Ideen? ü§î
      </textarea
          >
        </section>

        <section>
          <h3>useReducer-Hook</h3>
          <p>Hintergrund: Eine reducer-Funktion...</p>
          <ul>
            <li class="fragment">
              ...erh√§lt einen (vorherigen) Zustand und eine Action als Parameter √ºbergeben
            </li>
            <li class="fragment">
              <b>Actions</b> sind anwendungsspezifische, beliebige JavaScript-Objekte
            </li>
            <li class="fragment">...verarbeitet die Action</li>
            <li class="fragment">...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li class="fragment">...muss Seiteneffekt frei sein ("pure function")</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
          reducer(old_state, action) => new_state
        </code></pre>

          <p class="fragment">
            <em
              >Reducer sind zentrales Konzept von Redux, kommen aber auch in anderen Bereichen vor
              (z.B. <code>Array.reduce</code>)</em
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Actions</h3>
          <ul>
            <li class="fragment">Pure JavaScript-Objekte</li>
            <li class="fragment">Haben √ºblicherweise <b>type</b> und <b>payload</b></li>
            <li class="fragment">√úber das <b>type</b>-Property k√∂nnen sie identifiziert werden</li>
            <li class="fragment">Der <b>Payload</b> enth√§lt Action-spezifische Daten</li>
          </ul>

          <pre class="fragment"><code class="javascript">
        const apiRequestStartedAction = {
          type: "requestStarted"; // kein Payload erforderlich
        }

        const apiRequestFinishedAction = {
          type: "requesFinished",
          dataReceived: data  // Action-spezifischer Payload (hier: geladene Daten)
        }
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion</h3>
          <ul>
            <li class="fragment">
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li class="fragment">
              Zustand ist immutable! Kann mit <code>immer</code> kombiniert werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function apiReducer(state, action) {
  switch (action.type) {
    case "requestStarted": {
      // vorherigen Zustand teilweise √ºbernehmen
      return { ...state, status: "loading" };
    }

    case "requestFinished": {
      // komplett neuen Zustand zur√ºckliefern
      return { status: "finished", data: action.dataReceived };
    }

    return state; // alle anderen Actions: Zustand unver√§ndert zur√ºck
  }
}            
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useReducer-Hook</h3>
          <ul>
            <li class="fragment">
              Mit dem <b>useReducer</b>-Hook wird die reducer-Funktion in der Komponente registriert
            </li>
            <li class="fragment">
              Der Hook bekommt die reducer-Funktion √ºbergeben und den initialen Zustand (√§hnlich wie
              useState)
            </li>
            <li class="fragment">
              Der Hook liefert ein Array zur√ºck mit zwei Eintr√§gen: dem aktuellen Zustand und der
              <b>dispatch</b>-Funktion. Auch hier √§hnlich wie bei useState: Zustand und Funktion zum
              √Ñndern des Zustandes
            </li>
            <li class="fragment">
              Mit der dispatch-Funktion k√∂nnen Actions an den Reducer gesendet werden
            </li>
            <li class="fragment">
              Der reducer aktualisiert verarbeitet die Action, liefert neuen Zustand zur√ºck,
              Komponente wird neu gerendert (wie bei useState)
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
        function App() {
          const [apiState, dispatch] = React.useReducer(apiReducer, { status: "loading" });

          function loadData() {
            dispatch({ type: "requestStarted "});
            // ...Daten laden...
            dispatch({ type: "requestFinished", dataReceived: "..."});
          }

          // ...

        }
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
        ### M√∂gliche √úbung: Reducer-Funktion

        _Baue eine Komponente, die Daten mit `fetch` l√§dt._
        
          * Du kannst den Endpunkt `/api/user` mit HTTP GET aufrufen, da kommt eine Mock-Antwort (ein valides User-Objekt). Auf der n√§chsten Slide findest Du
          ein Beispiel dazu, falls dir `fetch` nicht mehr gel√§ufig ist.
          * Der Zustand in der Komponente wird in einem Reducer verwaltet.
          * Der Zustand soll mindestens die beiden API-Status "started" und "finished" unterst√ºtzen. Im `finished`-Status soll der Zustand au√üerdem die geladenen Daten halten.
          * Du brauchst also auch zwei Actions
          * W√§hrend die Daten geladen werden, zeige eine "Bitte warten Sie"-Meldung an
          * Wenn die Daten geladen sind, zeige die Komponente mit dem User-Editor an. Diese Komponente sollte nun das User-Objekt als Property entgegennehmen.
          * Sollte die Komponente das User-Objekt direkt ver√§ndern? Oder w√§re eine Kopie schlauer? 
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: fetch</h3>

          <pre><code class="javascript">
        function App() {
          React.useEffect(() => {
            // todo: Action ausl√∂sen
            fetch("/api/user")
              .then(response => response.json())
              .then(data => {
                // todo: Action ausl√∂sen
                // "data" ist ein g√ºltiges User-Objekt
              });
          }, []);
  
          ...
        }
          
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
        ### N√§chster Schritt: Globaler Zustand

        * Man kann Zustand in **lokalen Zustand** und **globalen Zustand** einteilen
        * **Lokaler Zustand** ist Zustand, der "mehr oder weniger" einer Komponente zur Verf√ºgung steht
        * **Globlaer Zustand** hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon zust√§ndig
        * Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition

        * Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme
        * Es spricht nichts dagegen, globalen Zustand, mit useState/useReducer zu verwalten, aber...
        * Du musst ihn mit unter weit nach unten reichen
        * oder andersrum: er muss sehr weit oben aufgeh√§ngt sein, um z.B. f√ºr verschiedene Ansichten zur Verf√ºgung zu stehen, oder Ansichtswechsel zu "√ºberleben"
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### React Context

        * Der **React Context** ist eine M√∂glichkeit, globalen Zustand Komponenten zur Verf√ºgung zu stellen, ohne ihn √ºber Properties durchreichen zu m√ºssen
        * Es gibt dabei eine **Provider** Komponente, die ein beliebiges Objekt, den Kontext, allen unterhalb liegenden Komponenten zur Verf√ºgung stellt
        * Das Objekt kann Daten und (Callback-)Funktionen enthalten
        * Das Prinzip ist √§hnlich wie wir es schon gesehen haben, nur dass diese Daten nicht explizit per Properties von einer Ebene zur n√§chsten weitergerreicht werden m√ºssen.
        Stattdessen findet das Durchreichen transparent statt
        * Du kannst beliebig viele Kontexte in deiner Anwendung verwenden. Dann hast Du entsprechend mehr Provider-Komponenten.
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Factory</h3>
          <ul>
            <li class="fragment">Der Provider stellt ein beliebiges Objekt zur Verf√ºgung</li>
            <li class="fragment">
              Daf√ºr muss ein Context-Objekt mit <code>React.createContext</code> erzeugt werden.
              Dieses Objekt enth√§lt die Provider- und die Consumer-Komponente
            </li>
            <li class="fragment">(Consumer-Komponente ist mit Hooks API irrelevant)</li>
          </ul>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        import react from "React";

        const ThemeContext = React.createContext();

        // erzeugt:
        // ThemeContext.Provider 
        // ThemeContext.Consumer (irrelevant mit Hooks API)
                </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Provider</h3>
          <ul>
            <li class="fragment">
              Die mit <code>createContext</code> erzeugte Provider Komponente erh√§lt ein Objekt als
              Properties, das sie allen unterhalb liegenden Komponenten (<code>children</code>) zur
              Verf√ºgung stellt.
            </li>
            <li class="fragment">Die Verwendung ist wie eine "normale" Komponente</li>
            <li class="fragment">
              √úblicherweise baut man sich eine Komponente darum, die dann auch die Daten h√§lt, die
              √ºber den Context zur Verf√ºgung gestellt werden sollen
            </li>
            <li class="fragment">Auch hierbei handelt es sich um eine "normale" Komponente:</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        const ThemeContext = React.createContext();

        function ThemeContextProvider(props) {
          const [themeName, setThemeName] = React.useState();


          return &lt;ThemeContext.Provider value={{
            currentTheme: themeName,
            setCurrentTheme: setThemeName 
          }}>
          {props.children}
        &lt;/AuthContext.Provider>;
      }
</code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Context: Consumer</h3>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <ul>
            <li class="fragment">
              In allen Komponenten unterhalb der Provider Komponente, kann mit
              <code>useContext</code> auf das bereitgestellte Objekt zugegriffen werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function TextInput() {
const { themeName } = React.useContext(ThemeContext);

return &lt;div className={`theme-${themeName}`}>&lt;input ... />&lt;/div>
}            
    </code></pre>
          <p class="fragment">
            Wenn der Kontext sich √§ndert, werden alle Konsumer automatisch neu gerendert
          </p>
          <pre class="fragment"><code class="javascript">
function ThemeChooser() {
  const { setThemeName } = React.useContext(themeContext);
  return &lt;div>
    &lt;button onClick={() => setThemeName("dark")}>Dark Theme&lt;/button>
    &lt;button onClick={() => setThemeName("light")}>Light Theme&lt;/button>
    &lt;/div>
}                
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hook f√ºr Context-Zugriff</h3>

          <ul>
            <li class="fragment">
              Du kannst einen Custom Hook f√ºr den Zugriff auf deinen Kontext bauen
            </li>
            <li class="fragment">
              Dann ist die Technologie (Context) gekapselt und Du hast eine "fachliche" API
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            export function useTheme() {
              return React.useContext(ThemeContext);
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            function TextInput(props) {
              const { themeName } = useTheme();
              
              // ...
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### M√∂gliche √úbung: React Context

            * In der Datei `ThemeContext.tsx` findest Du bereits einen Rumpf f√ºr einen Theme-Context
            * Verfollst√§ndige diesen, so dass er eine Farbe und eine setter-Funktion zum √Ñndern der Farbe bekommt
            * Passe deine TextInput-Komponente oder ein anderes Input-Feld so an, dass es als Hintergrundfarbe die Farbe aus dem Context verwendet (Property: `style={{backgroundColor: ...}}`)
            * Implementiere eine neue Komponente `ThemeChooser`, die die setter-Funktion aus dem Context benutzt, um eine andere Farbe einzustellen. Die Komponente kann sehr trivial sein, z.B. 
            nur ein oder zwei Buttons, um zwischen zwei Farben hin- und herzuschalten

          </textarea>
        </section>

        <section id="t-redux">
          <h2>Redux</h2>
          <h3>External Statemanagement</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Externes Statemanagement

            * **Externes** Statemanagement bedeutet, dass der Zustand aus deinen Komponenten herauswandert
            * Wird haben das exemplarisch bereits bei `useReducer` gesehen
            * Mit externem Statemanagement wird in der Regel **globaler Zustand** verwaltet
            * Es gibt mehrere Bibliotheken, die beiden bekanntesten sind:
              * [Redux](https://redux.js.org/)
              * [MobX](https://mobx.js.org/README.html)
            * Beide sind zun√§chst React-unabh√§ngig und f√ºr mehrere Webframeworks verf√ºgbar
            * D.h. die Logik, die Du damit entwickelst kannst Du prinzipiell auch mit anderen Webframeworks nutzen
            * Weitere Vertreter: [Recoil](https://recoiljs.org/) ebenfalls von Facebook, [OvermindJS](https://overmindjs.org/), von Codesandbox
          </textarea>
        </section>

        <section>
          <h2>Beispiel: Redux</h2>
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px;" />
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux: Konzepte

            * **Store**: eine Art "Datenbank", die au√üerhalb der Komponentenhierachie liegt. Hier ist der globale Zustand untergebracht. Komponenten werden √ºber Ver√§nderungen informiert und k√∂nnen sich re-rendern
            * **Actions** und **Reducer**: genau wie bei `useReducer` gesehen. Allerdings stehen die in einem Reducer verwalteten Daten der ganzen Anwendung zur Verf√ºgung (und nicht nur einer Komponente)
            * **Action Creator**: Factory-Funktionen, die Action Objekte erzeugen
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux: Reducer

            * Der Store, d.h. der globale Zustand, wird ausschlie√ülich √ºber reducer-Funktionen verwaltet
            * Die reducer-Funktionen entsprechen von API und Konzept den schon gesehenen reducer-Funktionen von `useReducer`
            * Jede reducer-Funktion verwaltet einen "Teil-Zustand" des globalen Zustandes. Die reducer k√∂nnen sich untereinander nicht sehen und nicht auf die anderen Teile des gloablen Zustands zugreifen
            * Wenn Du den Store mit einer Datenbank vergleichst, w√§re ein solcher Teilzustand so etwas wie eine Tabelle
            * Die reducer werden beim Starten der Anwendung in Redux registriert
            * Im Gegensatz zu `useReducer` wird eine Action in redux nicht an _einen_ Reducer geschickt, sondern an _alle_ Reducer. 
            * Dadurch ist eine gute Entkopplung m√∂glich: ein Teil der Anwendung informiert √ºber eine Aktion ("User hat sich eingeloggt", "Theme wurde ver√§ndert") und alle interessierten
            Anwendungsteile k√∂nnen darauf reagieren
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux: Actions</h3>
          <ul>
            <li class="fragment">Actions sind analog zu den Actions mit <code>useReducer</code></li>
            <li class="fragment">Actions werden an <b>alle</b> Reducer-Funktionen verteilt</li>
            <li class="fragment">
              Zum Ausl√∂sen einer Action gibt auch von Redux eine <code>dispatch</code>-Funktion, an
              die Du mit dem <code>useDispatch</code> Hook von Redux gelangst.
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function ThemeChooser() {
              const dispatch = useDispatch();

              function handleSetTheme(themeName) {
                dispatch({ type: "setTheme", payload: { newTheme: themeName } } );
              }

              return &lt;button onClick={() => handleSetTheme("light")}>Light&lt;/button>

            }
          </code></pre>
        </section>

        <section>
          <h3>Redux: Zugriff auf den globalen Zustand</h3>
          <ul>
            <li class="fragment">
              Komponenten k√∂nnen aus dem globalen Zustand (Store) die Daten ausw√§hlen, die sie
              ben√∂tigen
            </li>
            <li class="fragment">
              Die Hierarchie-Ebene spielt dabei keine Rolle, weil der Zustand au√üerhalb, "neben" den
              UI Komponenten liegt
            </li>
            <li class="fragment">
              Nur wenn sich die ausgew√§hlten Daten in einer Kompoente √§ndern, wird die Komponente
              neu gerendert
            </li>
            <li class="fragment">
              Der <code>useSelector</code> Hook von Redux erwartet eine Callback-Funktion, die
              aufgerufen wird, sobald sich <em>irgendetwas</em> im Store ver√§ndert hat
            </li>
            <li class="fragment">Dieser Callback-Funktion wird der komplette Store √ºbergeben.</li>
            <li class="fragment">
              Aus dem Store w√§hlt die Komponente die f√ºr sie relevanten Daten aus und liefert sie
              zur√ºck
            </li>
            <li class="fragment">
              Nur wenn sich diese zur√ºckgelieferten Daten ver√§ndert haben, wird die Komponente neu
              gerendert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
              function TextInput() {
                const { themeName } = useSelector(state => state.theme.themeName);

                //  ...
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useSelector - Details</h3>
          <ul>
            <li class="fragment">
              Um festzustellen, ob sich die ausgew√§hlten Daten ver√§ndert haben, pr√ºft Redux auf
              <b>Identit√§t</b>!
            </li>
            <li class="fragment">
              Es wird deshalb empfohlen, nur einzelne Werte (keine Objekte) aus dem Store
              auszuw√§hlen - stattdessen mehrere useSelector-Aufrufe machen
            </li>
            <li class="fragment">
              Du kannst nat√ºrlich auch "abgeleitete" Daten zur√ºckliefern, Redux vergleicht nur den
              von dir zur√ºckgelieferten Wert, unabh√§ngig davon, ob er "direkt" aus dem Store kommt
              oder basierend auf dem Store "berechnet" wurde
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function LoginCounter() {
              // *Alle* User befinden sich im Store
              // Der Selector liefert aber nur die Anzahl 
              // der eingeloggten Benutzer zur√ºck (berechneter/abgeleiteter State)
              const loggedInUserCount = useSelector(
                state => state.users.filter(u => u.isLoggedIn).count
              );
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux Toolkit

            * Redux erfordert in der Regel sehr viel Boilerplate Code (bitte nicht in kleineren Anwendungen einsetzen!)
            * Au√üerdem ist das Setup und die Konfiguration nicht immer trivial (Redux ist z.B. erweiterbar, welche Erweiterungen brauche ich?)
            * Auch die Verwendung von TypeScript ist nicht immer trivial
            * Aus diesen Gr√ºnden gibt es das [Redux Toolkit](https://redux-toolkit.js.org/), ein "offzielles" Toolset f√ºr Redux-Anwendungen (von den Redux-Leuten selbst)
            * Das kann die Entwicklung mit Redux vereinfachen
            * Aber: es bringt zus√§tzlich zu den Redux "Kernkonzepten" weitere Ideen mit (um die Kernkonzepte zu vereinfachen, zu abstrahieren etc)
            * Deswegen Empfehlung: erst mit Redux vertraut machen, dann aber im "echten Leben" evtl. auf das Toolkit setzen
          </textarea>
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Happy Statemanagement üçª</h3>
          <p>
            Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
        <section>
          <img src="slides/images/Deckblatt-und-Schlussblatt_devmedia_Trainings.png" />
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
    <script>
      const isLocal =
        window.location.hostname.indexOf("localhost") !== -1 ||
        window.location.hostname.indexOf("127.0.0.1") !== -1 ||
        window.location.href.startsWith("file:///");
      Reveal.addEventListener("ready", function (event) {
        $("li").addClass("fragment");

        // make all links open in new tab
        $("a").attr("target", "_blank");

        if (isLocal) {
          // only applies to presentation version
          Reveal.configure({ controls: false });
        } else {
          // only applies to public version
          $(".fragment").removeClass("fragment");
        }
      });
    </script>
  </body>
</html>
