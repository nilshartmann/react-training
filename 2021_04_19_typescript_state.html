<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>TypeScript &amp; State</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem;">
            <b>React Workshop</b>
          </h2>
          <h3>
            TypeScript &amp; Hooks
          </h3>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Vorbereitung</span></h3>
            <p>
              <span class="transparent-bg"
                >git clone https://github.com/nilshartmann/react-training</span
              >
            </p>
          </div>
          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: react-training/2021_04_19_typescript_state.html</span
              >
            </p>
          </div>
        </section>

        <section>
          <img src="slides/images/Deckblatt_devmedia_Trainings.png" />
        </section>

        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center;">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px;">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px;">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px;"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zeitplan Montag und Dienstag

            * 09:30-12:30 
            * 12:30-13:30 Pause üçù
            * 13:30-17:00 

            * Einverstanden?
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Agenda</h3>
          <ul>
            <li><a href="#/typescript">TypeScript</a></li>
            <li>
              <a href="#/react-classes-vs-hooks">React Klassen API vs Hooks und Hooks im Detail</a>
            </li>
            <li>
              <a href="#/data-libs"
                >Arbeiten mit HTTP Endpunkten: React Bibliotheken zur Verwaltung von Daten
                (√úbersicht)</a
              >
            </li>
            <li>
              <a href="/styling">√úbersicht: welche Ans√§tze zum Stylen von Komponenten gibt es?</a>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Workshop statt Schulung!

            * Diese beiden Tagen werden auch von Eurer Beteiligung leben üôã‚Äç‚ôÄÔ∏èüôã‚Äç‚ôÇÔ∏èüôã
            * Bitte stellt Fragen, √§u√üert Meinungen, berichtet aus Eurem t√§glichen arbeiten: wo l√§ufts gut, wo schlecht...
            * Die Agenda ist nur eine grobe Richtschnur
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zum Einstieg...

            * Bitte √ºberlegt Euch ein, zwei oder auch mehr S√§tze zum Thema "React/TypeScript in meiner t√§glichen Arbeit"
            * Zum Beispiel: "mir ist gar nicht klar, wie ich dies-oder-jenes mache" oder "mich nervt an React immer wieder, dass...", "ich finde TypeScript prima", oder "was ist useReducer"
            * Die S√§tze schreibt ihr auf das gemeinsame Miro-Board (Link im Chat)
            * Ihr seid dort anonym, wenn ihr wollt, k√∂nnt ihr hinter Eure S√§tze auch Euren Namen schreiben (ist aber nicht wichtig)
            * Das soll keine wisschenschaftliche Arbeit werden, sondern dient nur der Fokussierung und damit ich ungef√§hrt eine Idee habe, wo ihr steht
            * Wenn Euch im Laufe des Workshops noch was einf√§llt, schreibt es gerne einfach dazu
            * Am Ende werfen da nochmal einen Blick drauf
          </textarea>
        </section>

        <section data-markdown id="typescript">
          <textarea data-template>
            # TypeScript

            * Komplett im Editor bzw. TS Playground
            * Verzeichnis im Worksapce: `ts` 
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            # React
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section id="react-classes-vs-hooks">
          <h3>Klassen vs Hooks</h3>
          <ul>
            <li class="fragment"><em>Gemeinsamkeiten Klassen und Funktionskomponenten</em></li>
            <li class="fragment">State: neu rendern</li>
            <li class="fragment">Properties</li>
            <li class="fragment">Komponente gibt UI zur√ºck</li>
            <li class="fragment">Lebenszyklus: render und commit-Phase</li>
            <li class="fragment">Deklarativ</li>
            <li class="fragment">Klassen und Funktionen k√∂nnen in einer App gemischt werden</li>
            <li class="fragment">Klassen sind nicht deprecated</li>
            <li class="fragment"><b>Neue/k√ºnftige</b> React Features u.U. nur f√ºr Funktionen</li>
          </ul>
        </section>
        <section>
          <h3>Warum dann Funktionskomponenten?</h3>
          <ul>
            <li class="fragment">Einfacher (?) zu implementieren</li>
            <li class="fragment">
              "Klassen verwirren Menschen und Computer" (aus dem Blogpost zur Vorstellung der Hooks
              API)
            </li>
            <li class="fragment">Besseres Tooling m√∂glich (lt. Blogpost)</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>

          <p>Eine Komponente...</p>

          <pre class="fragment"><code class="javascript">
              class Search extends React.Component {
                state = {
                  loading: false
                };
              
                async componentDidMount() {
                  if (!this.props.searchString) {
                    return;
                  }

                  this.setState({
                    loading: true
                  });

                  const result = await executeSearchApiCall(this.props.searchString);

                  this.setState({
                    result
                  });
                }
              
                render() {
                  if (!this.state.result) {
                    return null;
                  }
              
                  if (this.state.loading) {
                    return &lt;h2>Searching...&lt;/h2>;
                  }
              
                  return (
                    &lt;div>
                    &lt;h2>Search Result:&lt;/h2>
                    &lt;p>{this.state.result}&lt;/p>
                    &lt;/div>
                  );
                }
              }           
             </code></pre>

          <p class="fragment">Was passiert, bei dem folgenden Aufruf?</p>

          <pre class="fragment"><code class="javascript">
&lt;Search searchString="React" />               
             </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Eine Komponente...</h3>
          <p>Der State wird nicht korrekt gesetzt: setState f√ºhrt zusammen!</p>

          <pre class="fragment"><code class="javascript">
    async componentDidMount() {
      if (!this.props.searchString) {
        return;
      }
      this.setState({
        loading: true
      });
      const result = await executeSearchApiCall(this.props.searchString);

      // loading weiterhin auf true!
      this.setState({
        result
      });
    }
  </code></pre>
          <p class="fragment">Das Verhalten von <code>setState</code> ist gew√∂hnungsbed√ºrftig...</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>

          <p>
            Welche Probleme hat die folende Implementierung, jetzt mit korrektem Setzen des States?
          </p>

          <pre class="fragment"><code class="javascript">
            class Search extends React.Component {
              state = {
                loading: false
              };
            
              async componentDidMount() {
                if (!this.props.searchString) {
                  return;
                }

                this.setState({
                  loading: true
                });

                const result = await executeSearchApiCall(this.props.searchString);

                this.setState({
                  loading: false,
                  result
                });
              }
            
              render() {
                if (!this.state.result) {
                  return null;
                }
            
                if (this.state.loading) {
                  return &lt;h2>Searching...&lt;/h2>;
                }
            
                return (
                  &lt;div>
                  &lt;h2>Search Result:&lt;/h2>
                  &lt;p>{this.state.result}&lt;/p>
                  &lt;/div>
                );
              }
            }                
          </code></pre>
          <p class="fragment">Was passiert, wenn <b>searchString</b> sich √§ndert?</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>
          <p>Jetzt mit componentDidUpdate...</p>

          <pre class="fragment"><code class="javascript">
async componentDidMount() {
    if (!this.props.searchString) {
      return;
    }
    this.setState({
      loading: true
    });
    const result = await executeSearchApiCall(this.props.searchString);
    this.setState({
      result,
      loading: false
    });
  }

  async componentDidUpdate() {
    if (!this.props.searchString) {
      return;
    }
    this.setState({
      loading: true
    });
    const result = await executeSearchApiCall(this.props.searchString);
    this.setState({
      result,
      loading: false
    });
  }            
          </code></pre>

          <p class="fragment">Was ist jetzt schon wieder falsch? ü•∫</p>
          <p class="fragment">Endlosschleife! üò±</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>
          <p>Reparierte Callback-Methoden: Wir m√ºssen die Properties √ºberpr√ºfen!</p>

          <pre class="fragment"><code class="javascript">
              async componentDidMount() {
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  result,
                  loading: false
                });
              }
            
              async componentDidUpdate(prevProps: SearchProps) {
                if (this.props.searchString === prevProps.searchString) {
                  // do not update if nothing changed
                  return;
                }
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  result,
                  loading: false
                });
              }
                        </code></pre>

          <p class="fragment">Funktioniert üòä</p>
          <p class="fragment">aber: viel redundanter Code üòû</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API</h3>

          <p>Gemeinsame Logik auslagern</p>

          <pre class="fragment"><code class="javascript">
           class Search extends React.Component { 
              async componentDidMount() {
                this.search();
              }
            
              async componentDidUpdate(prevProps: SearchProps) {
                if (this.props.searchString === prevProps.searchString) {
                  // do not update if nothing changed
                  return;
                }
            
                this.search();
              }
            
              async search() {
                if (!this.props.searchString) {
                  return;
                }
                this.setState({
                  loading: true
                });
                const result = await executeSearchApiCall(this.props.searchString);
                this.setState({
                  result,
                  loading: false
                });
              }

              // render...
           }
            </code></pre>

          <p class="fragment">Ganz gut, aber:</p>
          <p class="fragment">Fachlichkeit "Suchen" auf drei Methoden verteilt</p>
          <p class="fragment">
            Was w√ºrde passieren, wenn wir nicht nur suchen, sondern noch zweiten Use-Case haben, der
            technisch √§hnlich implementiert ist?
          </p>
          <p class="fragment">
            Wie k√∂nnten wir den Such-Code verallgemeinern und mehreren Komponenten zur Verf√ºgung
            stellen?
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API: Lebenszyklus</h3>
          <p>
            Unsere Suche dauert sehr lange! Die Komponente wird vor erhalten des Ergebnisses
            entfernt. Was passiert?
          </p>
          <img
            class="fragment"
            src="slides/images/cant-perform-update-on-unmounted-component.png"
          />
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Klassen API: Lebenszyklus</h3>
          <p>Wir m√ºssen componentWillUnmount implementieren</p>

          <pre class="fragment"><code class="javascript">
            class Search extends React.Component {
              state: SearchState = {
                loading: false
              };
            
              // track if component is still mounted
              componentMounted = true;

              componentWillUnmount() {
                this.componentMounted = false;
              }            
            
              async search() {
                // as before
                const result = await executeSearchApiCall(this.props.searchString);

                // component might be unmounted now
                if (!this.componentMounted) {
                  console.log("Compontent already unmounted!");
                  return;
                }
                this.setState({
                  result,
                  loading: false
                });
              }
            
          </code></pre>
        </section>

        <section>
          <h3>Klassen API: Lebenszyklus</h3>
          <p>
            Was passiert eigentlich, wenn die Search-Komponente mit unterschiedlichen Properties,
            zweimal hintereinader gerendert wird?
          </p>
          <p class="fragment">Es werden zwei Suchen gestartet...</p>
          <p class="fragment">Was passiert, wenn die zweite schneller ist als die erste?</p>

          <pre class="fragment"><code class="javascript">
            class Search extends React.Component {

              // ...
            
              async search() {
                // ...
                const result = await executeSearchApiCall(this.props.searchString);

                if (!this.componentMounted) {
                  return;
                }
                this.setState({
                  result,
                  loading: false
                });
              }
            
          </code></pre>
          <p class="fragment">Die 1. Suche "√ºberschreibt" das Ergebnis der 2.-Suche!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Error Boundaries: hier sind Klassen ein Muss!</h3>
          <p>
            Error Boundaries fangen Fehler beim Rendern auf. Wie eine Art try-catch-Handler, aber
            f√ºrs Rendern
          </p>
          <p>
            Um ein <a href="https://reactjs.org/docs/error-boundaries.html">Error Boundary</a> zu
            implementieren, <b>m√ºsst</b> ihr eine Klasse verwenden. Das geht mit Funktionen nicht!
          </p>
          <p>
            Tipp: Ihr solltet in jedem Fall mind. ein Error Boundary um Eure ganze Anwendung legen,
            um im Fall der F√§lle zumindest eine freundliche Fehlermeldung auszugeben
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Funktionskomponenten</h3>
          <ul>
            <li class="fragment">Funktionskomponenten gibt es schon l√§nger in React</li>
            <li class="fragment">Fr√ºher auch Stateless Functional Components (SFC) genannt</li>
            <li class="fragment">
              Man hatte darin keine M√∂glichkeit State zu verwenden oder am Lebenszyklus zu
              partizipieren
            </li>
            <li class="fragment">
              Also man konnte eigentlich nur Properties entgegennehmen und etwas rendern
            </li>
            <li class="fragment">Warum war diese Art von Komponenten (trotzdem) n√ºtzlich? ü§î</li>
            <li class="fragment">
              Funktionskomponenten API plus Hooks API = vollwertiger Klassen API Ersatz
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Search-Komponente als Funktion</h3>
          <p>üëâ hooks_und_mehr/hooks_workspace</p>
        </section>
        <section>
          <h3>Search-Komponente als Funktion</h3>

          <pre class="fragment"><code class="javascript">
              function Search({ searchString }) {
                const [loading, setLoading] = React.useState(false);
                const [result, setResult] = React.useState();
              
                React.useEffect(() => {
                  let cancelled = false;
                  async function search() {
                    setLoading(true);
                    const searchResult = await executeSearchApiCall(searchString);
                    if (cancelled) {
                      console.log("already cancelled");
                      return;
                    }
                    setLoading(false);
                    setResult(searchResult);
                  }
              
                  search();
              
                  return () => {
                    cancelled = true;
                  };
                }, [searchString]);
              
                if (loading) {
                  return &lt;h2>Searching...&lt;/h2>;
                }
              
                if (!result) {
                  return null;
                }
              
                return (
                  &lt;div>
                  &lt;h2>Search Result:&lt;/h2>
                  &lt;p>{result}&lt;/p>
                  &lt;/div>
                );
              }
              
            </code></pre>
        </section>
        <section>
          <h3>Search-Komponente als Funktion</h3>

          <ul>
            <li class="fragment">
              Fachlichkeit "Suche durchf√ºhren" ist an einer Stelle konzentriert (useEffect-Hook).
              Wir k√∂nnten sie sogar mit einem Custom Hook rausziehen
            </li>
            <li class="fragment">
              Lebenszyklus ist mehr oder weniger sauber abgebildet: R√ºckgabe-Wert ist die
              "Aufr√§um-Funktion", wann der Hook ausgef√ºhrt wird, wird mit dem Dependency Array
              beschrieben
            </li>
            <li class="fragment">
              Wir haben hier zwei States, ob das in diesem Fall besser ist, sei dahin gestellt, denn
              die beiden State-Eintr√§ge sind nicht unabh√§ngig. Wir k√∂nnten aber ein Objekt verwenden
            </li>
            <li class="fragment">
              Das Objekt wird mit der setter-Funktion dann komplett gesetzt und nicht
              zusammengef√ºhrt (wie in setState), das ist m√∂glicherweise erwartungskonformer
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Funktionskomponenten mit Hooks</h3>
          <ul>
            <li class="fragment">
              Funktionskomponenten gibt es schon lange in React, aber erst mit der Hooks API (16.8)
              wurden sie gleichwertig zu Klassenkomponenten
            </li>
            <li class="fragment">
              Mit React Hooks kann sich eine Komponente in Zustand und Lebenszyklus "einhaken"
            </li>
            <li class="fragment">
              Hooks machen Funktionskomponenten damit aus Feature-sicht gleichwertig mit
              Klassenkomponenten
            </li>
            <li class="fragment">
              Es gibt eingebaute Hooks (useState, useEffect etc.) und man kann eigene Hooks
              schreiben ("Custom Hooks")
            </li>
            <li class="fragment">
              <b
                >Die Hooks API bzw. eigene Hooks erlauben es Euch, wiederverwenbaren Code zu
                schreiben</b
              >, den ihr in diversen Komponenten einsetzen k√∂nnt
            </li>
            <li class="fragment">
              Ihr k√∂nnt Hooks auch in eigene Module auslagern und anderen Teams/Projekten zur
              Verf√ºgung stellen
            </li>
            <li class="fragment">
              Hooks sind technisch normale Funktionen, ihr k√∂nnt R√ºckgabewert und Parameter v√∂llig
              frei w√§hlen
            </li>
            <li class="fragment">
              Hooks setzen das React Prinzip √§hnlich wie Komponenten um: wenn in einem Hook etwas
              ge√§ndert wird, wird der Hook und die verwendenden Komponente neu gerendert!
            </li>
            <li class="fragment">
              Ich las mal den Satz: Hooks sind wie Komponenten nur ohne die Begrenzung auf Props als
              Parameter und UI als R√ºckgabewert...
            </li>
          </ul>
        </section>

        <section>
          <h3>Hook vs Komponente</h3>

          <pre class="fragment"><code class="javascript">
            // eine Komponente...
            function Dialog(props) {
              const { title, text } = props;
              const [visible, setVisible] = React.useState(true);

              if (!visible) { return null; }

              return &lt;div className="Dialog">
                &lt;h1>{title}&lt;h1>
                &lt;p>{text}&lt;/p>
                &lt;button onClick={() => setVisible(false)}>Close&lt;/button>
            }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // ein hook...
            function useDialog(props) {
              const { title, text } = props;
              const [visible, setVisible] = React.useState(true);

              if (!visible) { return null; }

              return &lt;div className="Dialog">
                &lt;h1>{title}&lt;h1>
                &lt;p>{text}&lt;/p>
                &lt;button onClick={() => setVisible(false)}>Close&lt;/button>
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Hooks vs Komponente 2</h3>
          <pre class="fragment"><code class="javascript">
            // eine Komponente...
            function InfoDialog(props) {
              const { text } = props;

              return &lt;Dialog title="info" text={text} />
            }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // ein hook...
            function useInfoDialog(props) {
              // wie sieht der useInfoDialog aus, der den useDialog-Hook verwendet?
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>useEffect</h2>
          <h3>im Detail</h3>
          <p>
            <em
              >Im folgenden schauen wir uns den useEffect-Hook etwas genauer an. Dabei werden wir
              aber auch Themen betrachten, die f√ºr React allgemein und andere Hooks relevant
              sind</em
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useEffect: clean up-Funktion</h3>

          <pre class="fragment"><code class="javascript">
            React.useEffect(() => {
              async function search() {
                const searchResult = await executeSearchApiCall(searchString);
                setLoading(false);
              }
          
              search();
          
            }, [searchString]);
          </code></pre>

          <ul>
            <li class="fragment">Warum k√∂nnen wir nicht den Effect selbst 'async' deklarieren?</li>
            <li class="fragment">
              Der R√ºckgabe-Wert des useEffect-Hooks muss eine Funktion (oder undefined) sein, aber
              kein Promise!
            </li>
            <li class="fragment">
              async verwandelt jeden R√ºckgabe-Typ (auch undefined!) in ein Promise
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useEffect: Ausf√ºhrungszeitpunkt</h3>
          <ul>
            <li class="fragment">
              Grunds√§tzlich: nach jedem Commit der Komponente (rendern ist abgeschlossen, Komponente
              im DOM)
            </li>
            <li class="fragment">
              Einschr√§nkbar durch das <b>Dependency-Array</b>:
              <ul>
                <li class="fragment">Leeres Array: nur nach erstem Rendern</li>
                <li class="fragment">
                  Ansonsten, wenn sich einer der Werte im Array zwischen zwei Renderzyklen ver√§ndert
                  hat
                </li>
                <li class="fragment">Werte werden per Referenz verglichen!</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useEffect: Ausf√ºhrungszeitpunkt</h3>

          <p>Lasst uns das √ºberpr√ºfen: wir bauen ein zweites Eingabefeld in die App-Komponente!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendering</h3>
          <p>Neue Anforderung: wir m√∂chten das Suchergebnis formatiert zur√ºckbekommen</p>
          <p>
            Wir √ºbergeben eine Callback-Funktion ("resultFormatter"), mit der das Surch-Ergebnis vor
            der Darstellung formatiert werden soll. Was m√ºssen wir beim Verwenden beachten?
          </p>

          <p>üëâ Workspace!</p>
        </section>

        <section>
          <h3>Rendering</h3>
          <p>
            Wir √ºbergeben eine Callback-Funktion ("resultFormatter"), mit der das Surch-Ergebnis vor
            der Darstellung formatiert werden soll. Was m√ºssen wir beim Verwenden beachten?
          </p>

          <pre class="fragment"><code class="javascript">
                function App() {
                  function myFormatter(s) { return s.toUpperCase(); }

                  return &lt;Search searchString={...} resultFormatter={myFormatter} />
                }

                function Search({ searchString, resultFormatter }) {
                  const [loading, setLoading] = React.useState(false);
                  const [result, setResult] = React.useState();
                
                  React.useEffect(() => {
                    let cancelled = false;
                    async function search() {
                      setLoading(true);
                      const searchResult = await executeSearchApiCall(searchString);
                      if (cancelled) {
                        console.log("already cancelled");
                        return;
                      }
                      setLoading(false);
    
                      // Ergebnis formatieren
                      const formattedResult = resultFormatter(searchResult);
                      setResult(formattedResult);
                    }
                
                    search();
                
                    return () => {
                      cancelled = true;
                    };
                  }, [searchString, resultFormatter]);
                
                  if (!result) {
                    return null;
                  }
                
                 // ab hier unver√§ndert: Loading oder Such-Ergebnis anzeigen
                }
                
              </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendering</h3>
          <ul>
            <li class="fragment">
              Wenn eine Komponente sich neu rendert, werden alle Funktionen darin neu "erzeugt", sie
              sind also "neu"
            </li>
            <li class="fragment">
              Wenn Funktionen im Dependency-Array angegeben werden, f√ºhrt das dazu, dass der Effekt
              neu ausgef√ºhrt wird
            </li>
            <li class="fragment">
              Das kann richtig oder falsch sein. In unserem Beispiel wollen wir das <b>nicht</b>
            </li>
            <li class="fragment">
              Wir m√ºssen beim Aufrufer daf√ºr sorgen, dass dieser eine "stabile" Funktion √ºbergibt
            </li>
            <li class="fragment">
              Mit <code>useCallback</code> k√∂nnen wir eine Funktion √ºber mehrere Renderzyklen hinweg
              stabil halten
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function App() {
              const myFormatter = React.useCallback(function myFormatter(s) { return s.toUpperCase(); }, []);

              return &lt;Search searchString={...} resultFormatter={myFormatter} />
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useCallback-Hook</h3>
          <ul>
            <li class="fragment">
              Auch der useCallback-Hook hat als zweiten Parameter ein Dependency-Array, das
              bestimmt, wie lange die Callback-Funktion g√ºltig ist
            </li>
            <li class="fragment">
              Im Gegensatz zu useEffect ist das Array hier <b>pflicht</b> und kann nicht weggelassen
              werden
            </li>
            <li class="fragment">Warum gibt es das Array? Was m√ºssen wir darein schreiben?</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ein erweitertes Beispiel</h3>
          <p>üëâ Workspace: Der Formatter bekommt einen konfigurierbaren Prefix</p>
        </section>

        <section>
          <h3>Hintergrund: Closures und Stale Data</h3>
          <p>Folgendes (fehlerhaftes!!!) Beispiel:</p>

          <pre class="fragment"><code class="javascript">
            function App() {
              const [search, setSearch] = React.useState("typescript");
              const [prefix, setPrefix] = React.useState("");

              const resultFormatter = React.useCallback(
                 function prefixFormatter(s) {return prefix + s}
              , []);

              return &lt;div>
                &lt;input value={change} onChange={...} />
                &lt;input value={prefix} onChange={...} />
                &lt;Search searchString={search} formatter={resultFormatter} />
              &lt;div>
            }
          </code></pre>

          <ol>
            <li class="fragment">Search starts with value="typescript" and formatter</li>
            <li class="fragment">User changes prefix (for example to "a")</li>
            <li class="fragment">App re-renders</li>
            <li class="fragment">
              App invokes Search component with value="typescript" and formatter (same as before)
            </li>
            <li class="fragment">Search finishes, formatter is called</li>
            <li class="fragment">What is prefix now in our formatter function?</li>
          </ol>
        </section>

        <section>
          <h3>Hintergrund: Closures und Stale Data</h3>
          <ul>
            <li class="fragment">
              In einer Closure werden die Daten aus dem umgebenen Kontext "eingefroren" mit dem
              Stand, wenn die Closure erzeugt wird
            </li>
            <li class="fragment">
              Die Formatter-Funktion wird also im fehlerhaften Beispiel <b>immer</b> den allerersten
              prefix zur√ºckliefern
            </li>
            <li class="fragment">
              Wollen wir auf den Prefix zugreifen, m√ºssen wir also eine neue formatter-Funktion
              erzeugen, wenn sich der Prefix √§ndert:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function App() {
              const [search, setSearch] = React.useState("typescript");
              const [prefix, setPrefix] = React.useState("");

              const resultFormatter = React.useCallback(
                 function prefixFormatter(s) {return prefix + s}
              , [prefix]);

              // ...
          </code></pre>
          <ul>
            <li class="fragment">
              Das hat (leider) zur Folge, dass nun die Search-Komponente eine neue Funktion erh√§lt
              und unsere Suche neue ausf√ºhrt
            </li>
            <li class="fragment">Habt ihr andere Ideen, wie wir das Problem l√∂sen k√∂nnten?</li>
            <li class="fragment">
              üëÜ Grunds√§tzlich gilt: <b>React vergleicht per Referenz</b>. Das gilt z.B. auch f√ºr
              <code>useState</code>, <code>useMemo</code> und <code>React.memo</code>
            </li>
          </ul>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>A propos Such-Ergebnis formatieren...</h3>
          <ul>
            <li class="fragment">
              Unabh√§ngig vom technischen Problem: ist unsere Implementierung "gut"?
            </li>
            <li class="fragment">
              Was k√∂nnten wir besser machen? Was w√§re vielleicht mehr "React-like"?
            </li>
            <li class="fragment">
              Insb: vielleicht soll der Formatter ver√§ndert werden, w√§hrend der Request l√§uft und
              nach Request-Ende dann f√ºr das Ergebnis verwendet werden?
            </li>
          </ul>
          <ul>
            <li class="fragment">
              "Abgeleitete" Daten werden in der Regel in React nicht in den State gelegt
            </li>
            <li class="fragment">Man w√ºrde wahrscheinlich den formatter beim rendern verwenden</li>
            <li class="fragment">
              Vorteil: der formatter ist immer aktuell (beeinflusst aber den Request nicht)
            </li>
            <li class="fragment">
              Keine Inkosistenzen (stellt euch vor, wir setzen den Result-State noch an einer
              anderen Stelle...
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>
          <p class="fragment">Wie k√∂nnen wir die bauen, wenn wir "setTimeout" verwenden?</p>
          <p class="fragment">
            Zur Erinnerung
            <a
              href="https://developer.mozilla.org/de/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout"
              >setTimeout</a
            >-JavaScript-Funktion:
          </p>
          <pre class="fragment"><code class="javascript">
const timerId = setTimeout( 
  () => console.log("Nach f√ºnf Sekunden"), // 1. Paramter: Callback-Funktion
  5000 // 2. Parameter: Timeout in ms
);

// Bei Bedarf, mit clearTimeout den Timer vorzeitig beenden:
clearTimeout(timerId);
            </code></pre>
          <p class="fragment">Eure Ideen? Wollt ihr es selbst probieren oder zusammen?</p>
        </section>
        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>
          <p class="fragment">Wie k√∂nnen wir die bauen, wenn wir "setTimeout" verwenden?</p>

          <pre class="fragment"><code class="javascript">
// Sehr naive Implementierung... Was fehlt hier?            
function Message({ message }: MessageProps) {
  const [msgVisible, setMsgVisible] = React.useState(true);

  React.useEffect(() => {
    setTimeout(() => setMsgVisible(false), 2500);
  }, []);

  if (!msgVisible) {
    return null;
  }

  return &lt;h2>{message}&lt;/h2>;
}

          </code></pre>
        </section>

        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>

          <pre class="fragment"><code class="javascript">
// Mit Clean-Up-Funktion           

function Message({ message }: MessageProps) {
  const [msgVisible, setMsgVisible] = React.useState(true);

  React.useEffect(() => {
    const id = setTimeout(() => setMsgVisible(false), 2500);
    return () => {
      clearTimeout(id);
    };
  }, []);

  if (!msgVisible) {
    return null;
  }

  return &lt;h2>{message}&lt;/h2>;
}


          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Neue Anforderung: Per Button soll die Message f√ºr immer angezeigt werden k√∂nnen, der
            timeout muss also abgebrochen werden
          </p>

          <pre class="fragment"><code class="javascript">
              function Message({ message }: MessageProps) {
                const [msgVisible, setMsgVisible] = React.useState(true);
              
                React.useEffect(() => {
                  const id = setTimeout(() => setMsgVisible(false), 2500);
                  return () => {
                    clearTimeout(id);
                  };
                }, []);

                function handleOnClick() {
                   // ????
                }
              
                if (!msgVisible) {
                  return null;
                }
              
                return &lt;div>
                &lt;button onClick={handleOnClick}>Show Message forever&lt;/button>
                &lt;h2>{message}&lt;/h2>
                &lt;/div>;
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Mehr zu Hooks</h3>
          <ul>
            <li class="fragment">
              In einer "Referenz", die wir mit dem useRef-Hook erzeugen, k√∂nnen wir Daten √ºber
              Renderzyklen erhalten
            </li>
            <li class="fragment">Diese Daten liegen unter <code>ref.current</code></li>
            <li class="fragment">
              Das √§ndern der Daten f√ºhrt <b>nicht</b> zu einem neu rendern der Komponente!
            </li>
            <li class="fragment">
              Vergleichbar mit einer Instanz-Variablen in einer Klassen Komponente
            </li>
          </ul>
        </section>

        <section>
          <h3>Mehr zu Hooks</h3>
          <p>
            Eine Message-Komponente, die eine Nachricht darstellt, die von selbst nach x Sekunden
            verschwindet
          </p>
          <p>Zusatzaufgabe:</p>
          <ol>
            <li class="fragment">
              Die Parent-Komponente rendert die Nachricht-Komponente und √ºbergibt ihr nicht nur eine
              Message, sondern auch die Dauer, wie lange diese Nachricht angezeigt werden soll, z.B.
              <b>f√ºnf Sekunden</b>
            </li>
            <li class="fragment">
              Die Parent-Komponente rendert sich nach <b>vier Sekunden</b> erneut, und √ºbergibt nun
              dieselbe Message, aber mit einer anderen Dauer (z.B. <b>sechs Sekunden</b>)
            </li>
            <li class="fragment">
              Die Message-Komponente soll die Dauer nun anpassen. Von <b>ersten</b> Rendern der
              Message bis zum Verschwinden, sollen nicht mehr Zeit vergehen als die √ºbergebene Dauer
              (also im Beispiel: <b>zwei Sekunden</b> nach dem zweiten Aufruf) ü§Ø
            </li>
          </ol>
          <p class="fragment">Puh... üòÆ kriegen wir das gemeinsam hin?</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Stale Data #2 (im Event Handler)</h3>
          <p>
            Beispiel: Eine Komponente, mit der ich Nachrichten laden kann, die in eine Liste
            eingef√ºgt werden. Mit einem Knopf kann ich die Liste der geladenen Nachrichten wieder
            leeren
          </p>
          <p class="fragment">üëâ workspace/EventHandlerApp!</p>
        </section>
        <section>
          <h3>Stale Data #2 (im Event Handler)</h3>
          <p class="fragment">Was kann hier passieren?</p>

          <pre class="fragment"><code class="javascript">
            function EventHandlerApp() {
              const [messages, setMessages] = React.useState([]);
            
              async function loadMore() {
                const newMessage = await executeApiCall();
                setMessages([newMessage, ...messages]);
              }
            
              function clear() {
                setMessages([]);
              }
            
              return (
                &lt;div>
                  &lt;button onClick={loadMore}>Load more&lt;/button>
                  &lt;button onClick={clear}>Clear&lt;/button>
                  &lt;ul>
                    {messages.map(msg => (
                      &lt;li key={msg.key}>{msg.msg}&lt;/li>
                    ))}
                    &lt;/ul>
                    &lt;/div>
              );
            }
          </code></pre>
          <p class="fragment">
            Stale Data! Was passiert, wenn loadMore lange dauert, und in der Zwischenzeit clear
            gedr√ºckt wird?
          </p>
        </section>

        <section>
          <h3>Stale Data #2 (im Event Handler)</h3>

          <p class="fragment">Asynchrones Verhalten und Stale Data im Event Handler</p>
          <p class="fragment">L√∂sungen</p>

          <p class="fragment">
            Eine Option: setState-Callback-Funktion, um aktuellen Wert zu bekommen.
          </p>
          <p class="fragment">
            Einer State setter-Funktion kann eine Callback-Funktion √ºbergeben erden. Diese wird mit
            dem jeweils aktuellen State aufgerufen und liefert neuen State zur√ºck
          </p>

          <pre class="fragment"><code class="javascript">
            const [messages, setMessages] = React.useState([]);
            function loadMore() {
              const newMessage = loadNewMessage();
              setMessages( existingMessages => [newMessage, ...existingMessages]);
            }
          </code></pre>
          <p class="fragment">
            (Alternativ w√ºrde auch useReducer gehen, hier wird auch immer der aktuelle State
            √ºbergeben)
          </p>

          <p class="fragment">
            Andere Ideen? Was m√ºssten wir machen, wenn wir auf den State nur lesend zugreifen
            wollen? Zum Beispiel: Vielleicht haben wir einen zweiten State, den wir ben√∂tigen in der
            loadMore-Funktion, abh√§ngig von diesem soll setMessages ausgef√ºhrt werden oder nicht
          </p>
          <p class="fragment">
            https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function
          </p>
        </section>

        <!-- ============================================================================= -->

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hooks</h3>
          <ul>
            <li class="fragment">
              Custom Hooks erlauben es, wiederverwenbaren Code zu schreiben und zu teilen
            </li>
            <li class="fragment">
              Habt ihr Beispiele in euren bestehenden Anwendungen? Wo k√∂nnten Custom Hooks Sinn
              machen und helfen?
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hook</h3>
          <p>üëâ Workspace, gemeinsam einen Custom Hook bauen</p>
        </section>

        <section>
          <h3>Custom Hook</h3>
          <p>Wollt ihr es auch selbst probieren? üôã</p>
          <p class="fragment">
            Ihr k√∂nnt <code>hooks_worksapce/CustomHook.tsx</code> daf√ºr verwenden
          </p>
          <p class="fragment">
            Bitte in <code>hooks_worksapce/index.tsx</code> den Import und die Verwendung
            entsprechend anpassen
          </p>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>Ein Beispiel: Daten Laden mit eigenem Hook</p>

          <pre class="fragment"><code class="javascript">
            function useDataLoader(url, defaultData) {
              const [loading, setLoading] = React.useState(false);
              const [result, setResult] = React.useState(defaultData);
            
              React.useEffect(() => {
                let cancelled = false;
                async function search() {
                  setLoading(true);
                  const searchResult = await executeApiCall(url);
                  if (cancelled) {
                    return;
                  }
                  setLoading(false);
                  setResult(searchResult);
                }
            
                search();
            
                return () => {
                  cancelled = true;
                };
              }, [url]);
            
              return {
                loading,
                result
              };
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hooks</h3>
          <p>Diskussion: R√ºckgabe-Wert: Array oder Object?</p>

          <pre class="fragment"><code class="javascript">
            function UserList() {
              // Hook liefert Objekt zur√ºck, Object Destructuring
              const {data, loading} = useDataLoader("/api/users");

              return ...;
            }

            function UserList() {
              // Hook liefert Array zur√ºck => Array Destructuring
              const [data, loading] = useDataLoader("/api/users");

              return ...;
            }
          </code></pre>
        </section>
        <section>
          <h3>Custom Hooks</h3>
          <p>Diskussion: R√ºckgabe-Wert: Array oder Object?</p>

          <p>Ein etwas komplexerer Fall...</p>
          <pre class="fragment"><code class="javascript">
              function UserWithComments() {
                // hmmm...?
                const {data, loading} = useDataLoader("/api/users");
                const {data, loading} = useDataLoader("/api/comments");

                // data und loading doppelt :-/
            }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              function UserWithComments() {
                // aha!
                const [users, usersLoading] = useDataLoader("/api/users");
                const [comments, commentsLoading] = useDataLoader("/api/comments");
              }
            </code></pre>

          <p class="fragment">Was k√∂nnte hier problematisch sein?</p>

          <pre class="fragment"><code class="javascript">
              function Users() {
                // hmmm...?
                const [data, loading, error, refetch] = useDataLoader("/api/users");
            }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              function Users() {
                // aha!
                const {data, loading, refetch, error, loading} = useDataLoader("/api/users");
            }
            </code></pre>

          <p class="fragment">Und noch eins, ben√∂tigt wird nur data und refetch:</p>

          <pre class="fragment"><code class="javascript">
                function Users() {
                  // Funktioniert, aber...?
                  const [data, , , refetch] = useDataLoader("/api/users");
              }
              </code></pre>

          <pre class="fragment"><code class="javascript">
                function Users() {
                  // aha!
                  const {data, refetch} = useDataLoader("/api/users");
              }
              </code></pre>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>
            <em
              >Ein erweiterter fetch-Hook: ich m√∂chte in meiner Komponente einen "reload"-Button,
              der die Daten erneut l√§dt (also nicht nur "on render")</em
            >
          </p>
          <ul>
            <li class="fragment">Wie machen wir das?</li>
            <li class="fragment">√Ñndern wir die Komponente oder auch den Hook?</li>
            <li class="fragment">Wie k√∂nnte der R√ºckgabe-Wert des Hooks aussehen?</li>
            <li class="fragment">Wollt ihr es selbst probieren? √úbung? üôã</li>
          </ul>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>
            <b
              >√úbung:
              <em
                >Ein erweiterter fetch-Hook: ich m√∂chte in meiner Komponente einen "reload"-Button,
                der die Daten erneut l√§dt (also nicht nur "on render")</em
              ></b
            >
          </p>
          <ul>
            <li class="fragment">
              Als Start-Punkt k√∂nnt ihr <code>hooks_und_mehr/hooks/10_custom_hook</code> verwenden
            </li>
            <li class="fragment">
              Daraus die Datei <code>CustomHookApp.tsx</code> in den Worksapce
              (<code>hooks_workspace</code>) kopieren und in <code>index.tsx</code> import
              entsprechend anpassen (s. TODO)
            </li>
            <li class="fragment">Die App-Komponente soll dann einen Reload-Button bekommen</li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <section>
          <h3>Custom Hooks</h3>
          <p>
            Problem: (alle) Hooks d√ºrfen nur am Anfang stehen und m√ºssen in selber Reihenfolge
            gerendert werden
          </p>

          <pre class="fragment"><code class="javascript">
            function BlogPost({postId}) {
              const blogPost = useBlogLoader(postId); // ok

              return ...;
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            function BlogPost({postId}) {
              if (postId !== null) {
                // DAS geht nicht:
              const blogPost = postId != null ? useBlogLoader(postId) : null; // üò±üò±üò±
              
              return ...;
            }
          </code></pre>
          <p class="fragment">Was machen wir hier? Ideen? üôã</p>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>
            Problem: (alle) Hooks d√ºrfen nur am Anfang stehen und m√ºssen in selber Reihenfolge
            gerendert werden
          </p>

          <pre class="fragment"><code class="javascript">
            // Option 1: useBlogLoader liefert eine Funktion zur√ºck,
            //           die das eigentliche Laden durchf√ºhrt
            function BlogPost({postId}) {
              const loadBlog = useBlogLoader();
              
              const blogPost = postId !== null ? loadBlog(postId):null; // ok

              return ...;
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Option 2: useBlogLoader kann mit null umgehen
            function BlogPost({postId}) {
              const blogPost = useBlogLoader(null); // ok

              return ...;
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Option 3: useBlogLoader bekommt 'skip' option
            //           (wird z.B. in den folgenden Fetch-Bibliotheken so gemacht,
            //           weil die ohnehin viele Konfigurationsparameter haben)
            function BlogPost({postId}) {
              const blogPost = useBlogLoader(postId, { skip: postId === null}); // ok

              return ...;
            }
          </code></pre>
        </section>

        <section>
          <h3>Custom Hooks</h3>
          <p>
            Problem: (alle) Hooks d√ºrfen nur am Anfang stehen und m√ºssen in selber Reihenfolge
            gerendert werden
          </p>

          <p>Warum ist das eigentlich so?</p>
        </section>

        <!-- ============================================================================= -->
        <section id="data-libs">
          <h2>Data Libraries f√ºr React</h2>
        </section>

        <!-- <ul>
           
            <li class="fragment">
              Anforderungen: Daten laden, Caching samt korrektem Invalidieren..., Requests sollen
              nicht bei jedem Rendern ausgef√ºhrt werden, globales(!) Caching: Daten sollen √ºber
              Komponetengrenzen und -wechsel erhalten bleiben, Fehlerbehandlung bzw. Abbildung
              Request-Lebenszyklus...
            </li>
            <li class="fragment">
              
            </li>
            <li class="fragment">
              
            </li>
            <li class="fragment">SWT, React Query und RTK Query, alle React-spezifisch</li>
            <li class="fragment">
              Die Idee ist bei allen √§hnlich und vermutlich von Apollo inspiriert: per Hooks API
              wird der Lebenszyklus eines Requests abgebildet.
            </li>
            <li class="fragment">Je nach Request Status unterscheidet sich der R√ºckgabewert</li>
            <li class="fragment">
              Die gelesenen Daten werden global gecached, deswegen Provider-Kompponente (bzw. Redux
              bei RTK) notwendig
            </li>
          </ul>
        </section> -->

        <section data-markdown>
          <textarea data-template>
            ### Basis Libraries

            * fetch: Browser Standard API, Low-Level, keinerlei Abstraktionen, quasi HTTP "pur"
            * [axios](https://github.com/axios/axios) bzw. [redaxios](https://github.com/developit/redaxios): Quasi-standard (aber kein Browser API). 
            * Etwas h√∂here Abstraktion als fetch: HTTP Fehlercodes werden auf Exceptions gemappt, Payload automatisch von/nach
            JSON konvertiert)
            * axios benutzt "Ajax", Redaxios selbe API aber basiert auf fetch (sehr kleine lib)
            * alle React-unabh√§ngig!

            
          
            
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: axios</h3>
          <pre class="fragment"><code class="javascript">
            try {
              const newPost = await axios.post('/blogpost', {
                title: 'Learning React',
                body: 'Lorem ipsum'
              });
            } catch (e) {
              // ...
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Data Libraries f√ºr React

            * Was k√∂nnten Anforderungen an eine React-spezifische Bibliothek sein?
            * üëâ Architektur in Miro oder Excalidraw diskutieren
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Data Libraries f√ºr React: Anforderungen

            * Daten laden/schreiben, HTTP GET, POST, PUT, DELETE, ...
            * Caching samt korrektem Invalidieren...
            * Requests sollen nicht bei jedem Rendern ausgef√ºhrt werden
            * globales(!) Caching: Daten sollen √ºber Komponetengrenzen und -wechsel erhalten bleiben
            * Re-fetching?
            * Fehlerbehandlung
            * Request-Lebenszyklus: L√§uft mein Request noch? (Wie) wurde er beendet? 
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Data Libraries f√ºr React: Typische Vertreter

            * [SWR](https://swr.vercel.app/) und [React Query](https://react-query.tanstack.com/)
            * Neu f√ºr Redux (Beta!): [Redux Toolkit Query](https://rtk-query-docs.netlify.app/)
            * Erste(?) Lib dieser Art: [Apollo](https://www.apollographql.com/docs/react/) (f√ºr GraphQL)
            * Idee bei allen √§hnlich: es gibt einen Custom-Hook, der Daten l√§dt/schreibt, man bekommt Request Status/Daten zur√ºck, Ergebnisse werden gecached
            * Man braucht einen Context (bzw. Redux), mit dem gecached wird
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Beispiel: SWR

            * Workspace `hooks_und_mehr/data-libs`
          </textarea>
        </section>

        <section id="styling">
          <h2>Styling</h2>
        </section>

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
            ### Styling: Herausforderungen

            * App soll einheitlich aussehen
            * CSS Code soll versteh- und wartbar bleiben
            * App soll (nicht) durch Styles von au√üen ver√§ndert werden (z.B. wenn als Widget auf einer anderen Seite eingebettet)
            * Mehr ?
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Styling Optionen

            * Pr√§prozessor ja/nein (Sass, Less)
            * CSS Modules
            * CSS-in-JS (Styled Components)
            * (WebComponents)
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Styling: Grunds√§tzliches</h3>
          <ul>
            <li class="fragment">
              React Anwendungen werden in der Regel per CSS (-Klassen) gestylt
            </li>
            <li class="fragment">Die Frage ist nur, wo kommen die CSS-Dateien her?</li>
            <li class="fragment">
              Variante 1: (externes) CSS, bindet ihr in Eurer HTML-Datei ein (oder ist schon
              eingebunden)
            </li>
            <li class="fragment">
              Variante 2: ihr importiert eine (oder mehrere) CSS-Dateien in Eurer Anwendung
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            // index.tsx
            import styles from "./styles.css"
          </code></pre>

          <ul>
            <li class="fragment">
              Das
              <a href="https://create-react-app.dev/docs/adding-a-stylesheet"
                >React Build Tooling</a
              >
              baut aus den importierten Styling-Dateien eine minifizerte Datei und bettet sie in
              Eure HTML-Seite ein
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Preprozessoren Sass/Less

            * Ein Preprozessor hilft beim Schreiben von CSS
            * Es gibt zum Beispiel Funktionen/Makros, Berechnungen, Inkludes 
            * Ihr k√∂nnt Sass und Less auch f√ºr CSS Modules verwenden
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Option: CSS Custom Properties

            * Man kann in CSS eigene [Variablen](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties) definieren
            * Damit l√§sst sich viel redundanter Code vermeiden, der gleichzeit anpassbar ist (z.B. f√ºr Themeing)
            * Daher in vielen F√§llen m√∂glicherweise Ersatz f√ºr Sass/Less
            * Achtung: CSS Custom Properties werden nicht vom IE unterst√ºtzt!
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### CSS Modules
            
            * [PostCSS](https://postcss.org/): Ein Tool, dass CSS-Code umschreibt
            * Damit kann man ganz viel machen, unter anderem "[Module](https://github.com/css-modules/css-modules)"
            * Die Idee dahinter: ihr teilt Euren CSS-Code auf mehrere Dateien auf (wie Komponenten in React)
            * Jede dieser Dateien bekommt mit PostCSS im Build einen eigenen Namensraum
            * Alle CSS Klassen, die ihr in einer Datei definiert, haben dann zur Laufzeit ein eigens Prefix
            * Die CSS-Dateien k√∂nnen auch mit Sass/Less geschrieben werden
            * Support f√ºr CSS Modules ist in React eingebaut (bzw. in den [react-scripts](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/))
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>CSS Modules</h3>
          <p><em>Problem: ihr kennt die CSS Klassennamen nicht mehr zur Build-Zeit! </em></p>
          <pre class="fragment"><code class="javascript">
            // Main.css
            .Main {
              width: 100%;
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Main hei√üt die CSS Klasse nicht zur Laufzeit :-(
            function Main() {
              return &lt;div className="Main">
                 ...
              &lt;/Main>
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // ihr k√∂nnt CSS Dateien importieren!
            import * as styles from "./Main.module.css"

            // styles is jetzt ein Objekt, das als Key die Namen aus der CSS-Datei
            // und als Wert die Lautzeit Klassennamen enth√§lt
            function Main() {
              return &lt;div className={styles.Main}>
                 ...
              &lt;/Main>
            }
          </code></pre>
        </section>

        <section>
          <h3>Styling Option: CSS-in-JS</h3>
          <ul>
            <li class="fragment">
              Eine Idee f√ºr CSS mit React wird <b>CSS-in-JS</b> genannt. Dabei schreibt ihr den
              CSS-Code direkt in Eurer JavaScript-Anwendung und zwar auch in JavaScript
            </li>
            <li class="fragment">
              Bekannt f√ºr diesen Ansatz ist
              <a href="https://styled-components.com/">Styled Components</a>
            </li>
            <li class="fragment">
              Aus Euren in JavaScript geschrieben Styles erzeugt die Bibliothek
              <code>style</code>-Elemente mit CSS-Klassen. Die Styles werden also nicht "inline" auf
              die Elemente angewandt, sondern weiterhin durch (zur Laufzeit) generierte
              CSS-Klassennamen
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Styling: Styled Components</h3>

          <ul>
            <li class="fragment">
              Bei dieser Variante erzeugt man eine neue, gestylte, Komponente aus einer bestehenden
              Komponente oder einem HTML-Element.
            </li>
            <li class="fragment">
              Das eigenet sich besonders gut f√ºr wiederverwendbare Basis-Komponenten
            </li>
            <!-- <li class="fragment">Dabei kann man auch auf die Properties der Komponente zugreifen, und CSS-Eigenschaften in Abh√§ngigkeit davon setzen!</li> -->
          </ul>

          <pre class="fragment"><code class="javascript">
  const Input = styled.input`
    font-size: 2rem;
    border: 2px solid black
  `;
            </code></pre>
          <pre class="fragment"><code class="javascript">
  // Verwendung wie eine "normale" Komponente
  &lt;Input value={...} onChange={...} />            
                        </code></pre>

          <ul>
            <li class="fragment">
              Dabei kann man auch auf die Properties der Komponente zugreifen, und CSS-Eigenschaften
              in Abh√§ngigkeit davon setzen!
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
                          const Input = styled.input`
                            font-size: ${props => props.large ? "2rem" : "1rem"};
                            border: 2px solid black;
                          `;                          

                          &lt;Input large={true} value={...} onChange={...} />  

                        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Styling: Styled Components</h3>
          <ul>
            <li class="fragment">Das funktioniert auch mit eigenen Komponenten</li>
            <li class="fragment">Dazu werden diese ebenfalls mit <code>styled</code> ummantelt</li>
            <li class="fragment">
              Styled Components erzeugt dann eine Wrapper Komponente, und √ºbergibt euch ein
              <code>className</code>-Property, das den generierten Klassennamen enth√§lt
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function UnstyledMain({className}) {
  return &lt;div className={className}>
    &lt;h1>Hello!&lt;/h1>
    &lt;/div>
}

export default function Main = styled(Main)`
  padding: 2rem;
  background-color: white;
`
}            
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Happy Statemanagement üçª</h3>
          <p>
            Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
        <section>
          <img src="slides/images/Deckblatt-und-Schlussblatt_devmedia_Trainings.png" />
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
    <script>
      const isLocal =
        window.location.hostname.indexOf("localhost") !== -1 ||
        window.location.hostname.indexOf("127.0.0.1") !== -1 ||
        window.location.href.startsWith("file:///");
      Reveal.addEventListener("ready", function (event) {
        $("li").addClass("fragment");

        // make all links open in new tab
        $("a").attr("target", "_blank");

        if (isLocal) {
          // only applies to presentation version
          Reveal.configure({ controls: false });
        } else {
          // only applies to public version
          $(".fragment").removeClass("fragment");
        }
      });
    </script>
  </body>
</html>
