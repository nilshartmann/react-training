<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React hands-on: Statemanagement</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem;">
            <b>React hands-on</b>
          </h2>
          <h3>
            Statemanagement
          </h3>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Vorbereitung</span></h3>
            <p>
              <span class="transparent-bg"
                >git clone https://github.com/nilshartmann/react-training</span
              >
            </p>
          </div>
          <p style="margin-top: 4rem;"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: react-training/2020_3_tage_react.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >oder online:
                <a href="https://nils.buzz/3_tage_react.html"
                  >https://nils.buzz/3_tage_react.html</a
                ></span
              >
            </p>
          </div>
        </section>

        <section>
          <img src="slides/images/Deckblatt_devmedia_Trainings.png" />
        </section>

        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center;">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px;">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px;">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px;"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zur Erinnerung

            * **State**: Interner Zustand (Model) einer Komponente
            * **Properties**: Daten, die einer Komponente von au√üen √ºbergeben werden
            * Wenn sich **State** √§ndert, wird die Komponente (und alle Unterkomponenten) neu gerendert
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>State</h3>
          <ul>
            <li class="fragment">Darf nicht ver√§ndert werden</li>
          </ul>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            function UserEditor() {
              const [user, setUser] = React.useState({ name: "Klaus", age: 32});

              function onSetAge(newAge) {
                // ???
                user.age = newAge;
              }

              return &lt;input value={user.age} onChange={e => onSetAge(e.target.value)} />
            }
                        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>State</h3>
          <ul>
            <li class="fragment">Darf nicht ver√§ndert werden</li>
          </ul>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
          function UserEditor() {
            const [user, setUser] = React.useState({ name: "Klaus", age: 32});

            function onSetAge(newAge) {
              // ???
              user.age = newAge;
              // ???
              setUser(user);
            }

            return &lt;input value={user.age} onChange={e => onSetAge(e.target.value)} />
          }
                      </code></pre>
        </section>

        <section>
          <h3>Initialisieren von State</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
        function UserEditor() {
          const [user, setUser] = React.useState({ name: "Klaus", age: 32});

          // ...
        }
                    </code></pre>

          <h3 class="fragment">(Lazy) Initialisieren √ºber Callback-Funktion</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
                      function UserEditor() {
                        // Uebergebene Funktion muss Seiteneffekt-frei sein!
                        const [user, setUser] = React.useState( () => newUserObject() );
              
                        // ...
                      }
                                  </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
        // Objekt-Spread-Operator zum Kopieren und ver√§ndern

        const newObject = {
          ...oldObject, // altes Objekt hier "einf√ºgen"
          updatedProperty: "new value" // (ausgew√§hlte) Werte in NEUEM Objekt ver√§ndern
        }
                    </code></pre>
          <h3 class="fragment">Object-Spread-Operator kopiert nur "flach"</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// Beispiel mit Verschachtelung:
const oldPerson = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };                      

const newPerson = {
  ...oldPerson, // altes Objekt hier "einf√ºgen"

  // address muss nun auch kopiert werden:
  address: { ...newPerson.address, city: "Hamburg" } 
}
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <pre class="fragment"><code class="javascript">
        // Spread-Operator bei Arrays

        const oldArray = [ "b", "c" ];

        // Anf√ºgen eines Elementes
        const newArray = [
          "a",  // vorne anf√ºgen
          ...oldArray, // hier altes Array reinkopieren
          "c" // hinten anf√ºgen
        ]

      </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <h3 class="fragment">Ver√§ndern von Objekten in Arrays</h3>

          <pre class="fragment"><code class="javascript">
        // Ver√§ndern von Arrays:

        const newArray = oldArray.map(oldEntry => {
          if (oldEntry.id === "user-1") { // dieses Element soll ver√§ndert werden
            return { ...oldEntry, name: "Klaus" }
          }
          return oldEntry; // unver√§ndert
        });

        // newArray ist eine Kopie, mit ggf. ver√§nderten Eintr√§gen
      </code></pre>

          <h3 class="fragment">Eintr√§ge aus Arrays entfernen</h3>

          <pre class="fragment"><code class="javascript">
        const newArray = oldArray.filter(oldEntry => oldEntry.id === idToBeRemoved);

        // newArray ist eine Kopie ohne die rausgefilterten Eintraege
        
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
          ## Immer f√ºr Arbeiten mit unver√§nderlichen Datenstrukturen

          <img src="slides/images/immer.png" /> 

          * [ImmerJs](https://immerjs.github.io/immer/docs/introduction): _Create the next immutable state tree by simply modifying the current tree_
          * Konzept: altes Objekt wird in eine Funktion gesteckt, die daraus ein _Draft_ erzeugt
          * Das _Draft_ wird mit regul√§ren JavaScript APIs ver√§ndert, als wenn es mutable w√§re
          * Immer zeichnet die √Ñnderungen auf
          * Zum Schluss werden die √Ñnderungen auf eine Kopie des alten Objektes angewendet

        </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Immer: produce-Funktion</h3>

          <p>
            Die <b>produce</b>-Funktion bekommt ein Objekt √ºbergeben, sowie eine zweite Funktion,
            die von immer mit einem Draft aufgerufen wird.
          </p>
          <p>Dieses Draft kann ver√§ndert werden</p>
          <p>
            Der R√ºckgabe-Typ der produce-Funktion ist dann eine Kopie des alten Objektes mit den
            √Ñnderungen, die auf dem Draft vorgenommen wurden.
          </p>

          <pre class="fragment"><code class="javascript">
              import produce from "immer";

              const person = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };

              const newPerson = produce(person, draft => {
                person.name = "Susi";
                person.address.city = "Hamburg";
              })

              newPerson; // Neues Objekt!
              newPerson.name; // Susi
              newPerson.address // Neues Objekt!
              newPerson.address.city; // Hamburg
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Immer</h3>

          <pre class="fragment"><code class="javascript">
          function handleLastNameChange(newLastName: string) {
              const newUser = produce(user, draft => {
                // draft kann ver√§ndert werden, als ob es ein mutable Objekt sei
                draft.lastName = newLastName;
              })
            );
            setUser(newUser);
          }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          function handleContactTypeChange(contactId: string, newType: string) {
            setUser(
              produce(user, draft => {
                const ix = draft.contacts.findIndex(contact => contact.id === contactId);
                draft.contacts[ix].type = newType;
              })
            );
          }
        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Erste √úbung: Mit ES6 Operatoren und immer vertraut machen</h3>

          * Verzeichnis: **state/workspace** * In `App.tsx` die leeren Handler-Funktionen
          implementieren * Du kannst jeweils ES6 Operatoren oder immer verwenden, je nachdem was
          besser passt
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>N√§chster Schritt</h3>
          <h2>Zustand "verteilen"</h2>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### Erinnerung:

    * **Zustand** wird von Parent-Komponenten nach unten gereicht (√ºber **Properties**)
    * Die Unterkomponenten k√∂nnen den Zustand darstellen (oder andere Dinge davon ableiten), aber ihn nicht **ver√§ndern**
    * (Unterkomponenten k√∂nnen zus√§tzlich eigenen Zustand haben)
    * Oberkomponenten k√∂nnen au√üerdem Callback-Funktionen an ihre Unterkomponenten √ºbergeben
    * √úber die Callback-Funktionen k√∂nnen Unterkomponenten den Oberkomponenten Ereignisse schicken
    * Die Oberkomponente kann auf das Ereignis z.B. mit einer State-√Ñnderung reagieren, so dass Ober- und Unterkomponente neu gerendert werden
    * Das Durchreichen von State- und Callbacks ist √ºber mehr als eine Ebene erlaubt (und gew√∂hnlich)

    <img class="fragment" style="height:600px" src="slides/images/state/datenfluss.svg" />
  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel</h3>
          <pre class="fragment"><code class="javascript">
    function App() {
      const [user, setUser] = React.useState(...);

      function handleFullNameChange(newFullName: string) { setUser(...) }

      return &lt;...>
        &lt;TextInput label="Full Name" value={user.fullName} 
           onTextChange={handleFullNameChange} />
      &lt;...>
    }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          // kein eigener State!
          function TextInput(props) {
            return &lt;...>
              &lt;input value={props.value}
                 onChange={e => props.onTextChange(e.target.value)} />
            &lt;...>
          }
              </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### M√∂gliche √úbung

    * **Baue eine _TextInput_-Komponente.** Diese Komponente soll nur ein Wrapper um ein `input`-Element darstellen (also einen Wert entgegennehmen und eine Callback-Funktion, die 
    aufgerufen wird, wenn der Wert ver√§ndert wird). Setze die Komponente anstatt der `input`-Felder ein
    * **Baue eine _Passwort_-Komponente**. Auch diese Komponente soll nur ein Wrapper um ein `input`-Element darstellen. Allerdings soll sie noch eine M√∂glichkeit haben, dass man
    umstellen kann, ob das Passwort sichtbar oder unsichtbar angezeigt wird (`<input type="text" ... />` bzw. `<input type="password"... />`). Dazu kannst Du z.B. eine Checkbox-verwenden
    (`<input type="checkbox">`) Verwende diese Komponente f√ºr die Eingabe von `user.password`.

  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendern unterdr√ºcken</h3>
          <ul>
            <li class="fragment">
              Wenn sich der Zustand √§ndert, wird die Komponente und alle darunterliegenden
              Komponenten erneut gerendert
            </li>
            <li class="fragment">
              Nicht immer <b>m√ºssen</b> alle Komponenten aus fachlicher Sicht neu gerendert werden
            </li>
            <li class="fragment">
              Eine Komponente kann "memoiziert" werden, und rendert sich dann nur erneut, wenn
              mindestens <b>ein</b> Property sich ver√§ndert hat (Identit√§tsvergleich)
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
    // Nur neu rendern, wenn Properties sich ver√§ndert haben
    const InvalidContactDisplay = React.memo(function InvalidContactDisplay(props) {
      return ...;
    });

    // Verwendung wie gewohnt:
    &lt;InvalidContactDisplay contacts={...} />
  </code></pre>
          <p class="fragment">
            <b>Achtung!</b>: Diese Optimierungen bitte nicht auf "vorrat" vornehmen, sondern nur,
            wenn wirklich n√∂tig! Auch das Caching/Memoization hat seinen Preis!
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendern unterdr√ºcken: Stabile Funktionsreferenzen</h3>
          <ul>
            <li class="fragment">
              Wenn eine Komponente sich neu rendert, werden alle darin enthaltenen Funktionen "neu
              erzeugt"
            </li>
            <li class="fragment">
              Wenn eine solche Funktion als Callback-Funktion an eine memoizierte Komponente
              √ºbergeben wird, ist sie "ver√§ndert", es wird also neu gerendert
            </li>
            <li class="fragment">
              Mit <code>React.useCallback</code> k√∂nnen stabile Funktionsreferenzen erzeugt werden,
              die √ºber einen Renderzyklus hinaus g√ºltig sind:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
    function UserInput(props) {
      const handleFullNameChange = React.useCallback(function(...) { ... }, []);
    }
  </code></pre>

          <ul class="fragment">
            <li>
              Mit dem zweiten Paramater k√∂nnen - wie bei <code>React.useEffect</code> -
              Abh√§ngigkeiten angegeben werden, wann die Funktion neu erzeugt werden soll
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Rendern unterdr√ºcken: Stabile Funktionsreferenzen #2</h3>
          <ul>
            <li class="fragment">
              In einer "stabilen" Funktion m√ºsst ihr darauf achten, Werte, die ihr in der Funktion
              verwendet, als Dependency anzugeben
            </li>
            <li class="fragment">
              F√ºr den Zustand gibt es die M√∂glichkeit, die Callback-Notation von
              <code>setState</code> zu verwenden. Damit bekommst Du immer den aktuellen Wert des
              Zustandes, und brauchst ihn nicht in den Dependencies anzugeben:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
      const handleUpdate = React.useCallback(function()  {
        // der Callback-Funktion wird der aktuelle Zustand √ºbergeben
        // ihr R√ºckgabewert wird als neuer State gesetzt
        setState(oldState => ...);
      }, []);
    </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### M√∂gliche √úbung: Memoization von Komponenten

    * Die `TextInput`-Komponente soll sich nur neu rendern, wenn sich eines ihrer Properties ver√§ndert hat
    * Du musst die TextInput-Komponente als "memoizieren"
    * Und die Aufrufe an die Komponente anpassen?

  </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung von komplexem Zustand

        ## Reducer-Funktionen und useReducer-Hook
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung und √Ñnderung von Zustand

        * Wir halten den Zustand lokal in einer Komponente
        * S√§mtliche √Ñnderungen daran passieren innerhalb der Komponente
        * Mit einer reducer-Funktion kann die Verwaltung des Zustandes aus der Komponente herausgel√∂st werden
        * Warum sollte man das tun? Ideen? ü§î
      </textarea
          >
        </section>

        <section>
          <h3>useReducer-Hook</h3>
          <p>Hintergrund: Eine reducer-Funktion...</p>
          <ul>
            <li class="fragment">
              ...erh√§lt einen (vorherigen) Zustand und eine Action als Parameter √ºbergeben
            </li>
            <li class="fragment">
              <b>Actions</b> sind anwendungsspezifische, beliebige JavaScript-Objekte
            </li>
            <li class="fragment">...verarbeitet die Action</li>
            <li class="fragment">...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li class="fragment">...muss Seiteneffekt frei sein ("pure function")</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
          reducer(old_state, action) => new_state
        </code></pre>

          <p class="fragment">
            <em
              >Reducer sind zentrales Konzept von Redux, kommen aber auch in anderen Bereichen vor
              (z.B. <code>Array.reduce</code>)</em
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Actions</h3>
          <ul>
            <li class="fragment">Pure JavaScript-Objekte</li>
            <li class="fragment">Haben √ºblicherweise <b>type</b> und <b>payload</b></li>
            <li class="fragment">√úber das <b>type</b>-Property k√∂nnen sie identifiziert werden</li>
            <li class="fragment">Der <b>Payload</b> enth√§lt Action-spezifische Daten</li>
          </ul>

          <pre class="fragment"><code class="javascript">
        const apiRequestStartedAction = {
          type: "requestStarted"; // kein Payload erforderlich
        }

        const apiRequestFinishedAction = {
          type: "requesFinished",
          dataReceived: data  // Action-spezifischer Payload (hier: geladene Daten)
        }
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion</h3>
          <ul>
            <li class="fragment">
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li class="fragment">
              Zustand ist immutable! Kann mit <code>immer</code> kombiniert werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function apiReducer(state, action) {
  switch (action.type) {
    case "requestStarted": {
      // vorherigen Zustand teilweise √ºbernehmen
      return { ...state, status: "loading" };
    }

    case "requestFinished": {
      // komplett neuen Zustand zur√ºckliefern
      return { status: "finished", data: action.dataReceived };
    }

    return state; // alle anderen Actions: Zustand unver√§ndert zur√ºck
  }
}            
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useReducer-Hook</h3>
          <ul>
            <li class="fragment">
              Mit dem <b>useReducer</b>-Hook wird die reducer-Funktion in der Komponente registriert
            </li>
            <li class="fragment">
              Der Hook bekommt die reducer-Funktion √ºbergeben und den initialen Zustand (√§hnlich wie
              useState)
            </li>
            <li class="fragment">
              Der Hook liefert ein Array zur√ºck mit zwei Eintr√§gen: dem aktuellen Zustand und der
              <b>dispatch</b>-Funktion. Auch hier √§hnlich wie bei useState: Zustand und Funktion zum
              √Ñndern des Zustandes
            </li>
            <li class="fragment">
              Mit der dispatch-Funktion k√∂nnen Actions an den Reducer gesendet werden
            </li>
            <li class="fragment">
              Der reducer aktualisiert verarbeitet die Action, liefert neuen Zustand zur√ºck,
              Komponente wird neu gerendert (wie bei useState)
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
        function App() {
          const [apiState, dispatch] = React.useReducer(apiReducer, { status: "loading" });

          function loadData() {
            dispatch({ type: "requestStarted "});
            // ...Daten laden...
            dispatch({ type: "requestFinished", dataReceived: "..."});
          }

          // ...

        }
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
        ### M√∂gliche √úbung: Reducer-Funktion

        _Baue eine Komponente, die Daten mit `fetch` l√§dt._
        
          * Du kannst den Endpunkt `/api/user` mit HTTP GET aufrufen, da kommt eine Mock-Antwort (ein valides User-Objekt). Auf der n√§chsten Slide findest Du
          ein Beispiel dazu, falls dir `fetch` nicht mehr gel√§ufig ist.
          * Der Zustand in der Komponente wird in einem Reducer verwaltet.
          * Der Zustand soll mindestens die beiden API-Status "started" und "finished" unterst√ºtzen. Im `finished`-Status soll der Zustand au√üerdem die geladenen Daten halten.
          * Du brauchst also auch zwei Actions
          * W√§hrend die Daten geladen werden, zeige eine "Bitte warten Sie"-Meldung an
          * Wenn die Daten geladen sind, zeige die Komponente mit dem User-Editor an. Diese Komponente sollte nun das User-Objekt als Property entgegennehmen.
          * Sollte die Komponente das User-Objekt direkt ver√§ndern? Oder w√§re eine Kopie schlauer? 
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: fetch</h3>

          <pre><code class="javascript">
        function App() {
          React.useEffect(() => {
            // todo: Action ausl√∂sen
            fetch("/api/user")
              .then(response => response.json())
              .then(data => {
                // todo: Action ausl√∂sen
                // "data" ist ein g√ºltiges User-Objekt
              });
          }, []);
  
          ...
        }
          
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
        ### N√§chster Schritt: Globaler Zustand

        * Man kann Zustand in **lokalen Zustand** und **globalen Zustand** einteilen
        * **Lokaler Zustand** ist Zustand, der "mehr oder weniger" einer Komponente zur Verf√ºgung steht
        * **Globlaer Zustand** hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon zust√§ndig
        * Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition

        * Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme
        * Es spricht nichts dagegen, globalen Zustand, mit useState/useReducer zu verwalten, aber...
        * Du musst ihn mit unter weit nach unten reichen
        * oder andersrum: er muss sehr weit oben aufgeh√§ngt sein, um z.B. f√ºr verschiedene Ansichten zur Verf√ºgung zu stehen, oder Ansichtswechsel zu "√ºberleben"
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### React Context

        * Der **React Context** ist eine M√∂glichkeit, globalen Zustand Komponenten zur Verf√ºgung zu stellen, ohne ihn √ºber Properties durchreichen zu m√ºssen
        * Es gibt dabei eine **Provider** Komponente, die ein beliebiges Objekt, den Kontext, allen unterhalb liegenden Komponenten zur Verf√ºgung stellt
        * Das Objekt kann Daten und (Callback-)Funktionen enthalten
        * Das Prinzip ist √§hnlich wie wir es schon gesehen haben, nur dass diese Daten nicht explizit per Properties von einer Ebene zur n√§chsten weitergerreicht werden m√ºssen.
        Stattdessen findet das Durchreichen transparent statt
        * Du kannst beliebig viele Kontexte in deiner Anwendung verwenden. Dann hast Du entsprechend mehr Provider-Komponenten.
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Factory</h3>
          <ul>
            <li class="fragment">Der Provider stellt ein beliebiges Objekt zur Verf√ºgung</li>
            <li class="fragment">
              Daf√ºr muss ein Context-Objekt mit <code>React.createContext</code> erzeugt werden.
              Dieses Objekt enth√§lt die Provider- und die Consumer-Komponente
            </li>
            <li class="fragment">(Consumer-Komponente ist mit Hooks API irrelevant)</li>
          </ul>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        import react from "React";

        const ThemeContext = React.createContext();

        // erzeugt:
        // ThemeContext.Provider 
        // ThemeContext.Consumer (irrelevant mit Hooks API)
                </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Provider</h3>
          <ul>
            <li class="fragment">
              Die mit <code>createContext</code> erzeugte Provider Komponente erh√§lt ein Objekt als
              Properties, das sie allen unterhalb liegenden Komponenten (<code>children</code>) zur
              Verf√ºgung stellt.
            </li>
            <li class="fragment">Die Verwendung ist wie eine "normale" Komponente</li>
            <li class="fragment">
              √úblicherweise baut man sich eine Komponente darum, die dann auch die Daten h√§lt, die
              √ºber den Context zur Verf√ºgung gestellt werden sollen
            </li>
            <li class="fragment">Auch hierbei handelt es sich um eine "normale" Komponente:</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        const ThemeContext = React.createContext();

        function ThemeContextProvider(props) {
          const [themeName, setThemeName] = React.useState();


          return &lt;ThemeContext.Provider value={{
            currentTheme: themeName,
            setCurrentTheme: setThemeName 
          }}>
          {props.children}
        &lt;/AuthContext.Provider>;
      }
</code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Context: Consumer</h3>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <ul>
            <li class="fragment">
              In allen Komponenten unterhalb der Provider Komponente, kann mit
              <code>useContext</code> auf das bereitgestellte Objekt zugegriffen werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function TextInput() {
const { themeName } = React.useContext(ThemeContext);

return &lt;div className={`theme-${themeName}`}>&lt;input ... />&lt;/div>
}            
    </code></pre>
          <p class="fragment">
            Wenn der Kontext sich √§ndert, werden alle Konsumer automatisch neu gerendert
          </p>
          <pre class="fragment"><code class="javascript">
function ThemeChooser() {
  const { setThemeName } = React.useContext(themeContext);
  return &lt;div>
    &lt;button onClick={() => setThemeName("dark")}>Dark Theme&lt;/button>
    &lt;button onClick={() => setThemeName("light")}>Light Theme&lt;/button>
    &lt;/div>
}                
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hook f√ºr Context-Zugriff</h3>

          <ul>
            <li class="fragment">
              Du kannst einen Custom Hook f√ºr den Zugriff auf deinen Kontext bauen
            </li>
            <li class="fragment">
              Dann ist die Technologie (Context) gekapselt und Du hast eine "fachliche" API
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            export function useTheme() {
              return React.useContext(ThemeContext);
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            function TextInput(props) {
              const { themeName } = useTheme();
              
              // ...
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### M√∂gliche √úbung: React Context

            ## todo: √úbung vorbereiten
          </textarea>
        </section>

        <section id="t-redux">
          <h2>Redux</h2>
          <h3>External Statemanagement</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Externes Statemanagement

            * **Externes** Statemanagement bedeutet, dass der Zustand aus deinen Komponenten herauswandert
            * Wird haben das exemplarisch bereits bei `useReducer` gesehen
            * Mit externem Statemanagement wird in der Regel **globaler Zustand** verwaltet
            * Es gibt mehrere Bibliotheken, die beiden bekanntesten sind:
              * [Redux](https://redux.js.org/)
              * [MobX](https://mobx.js.org/README.html)
            * Beide sind zun√§chst React-unabh√§ngig und f√ºr mehrere Webframeworks verf√ºgbar
            * D.h. die Logik, die Du damit entwickelst kannst Du prinzipiell auch mit anderen Webframeworks nutzen
            * Weitere Vertreter: [Recoil](https://recoiljs.org/) ebenfalls von Facebook, [OvermindJS](https://overmindjs.org/), von Codesandbox
          </textarea>
        </section>

        <section>
          <h2>Beispiel: Redux</h2>
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px;" />
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux: Konzepte

            * **Store**: eine Art "Datenbank", die au√üerhalb der Komponentenhierachie liegt. Hier ist der globale Zustand untergebracht. Komponenten werden √ºber Ver√§nderungen informiert und k√∂nnen sich re-rendern
            * **Actions** und **Reducer**: genau wie bei `useReducer` gesehen. Allerdings stehen die in einem Reducer verwalteten Daten der ganzen Anwendung zur Verf√ºgung (und nicht nur einer Komponente)
            * **Action Creator**: Factory-Funktionen, die Action Objekte erzeugen
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux: Reducer

            * Der Store, d.h. der globale Zustand, wird ausschlie√ülich √ºber reducer-Funktionen verwaltet
            * Die reducer-Funktionen entsprechen von API und Konzept den schon gesehenen reducer-Funktionen von `useReducer`
            * Jede reducer-Funktion verwaltet einen "Teil-Zustand" des globalen Zustandes. Die reducer k√∂nnen sich untereinander nicht sehen und nicht auf die anderen Teile des gloablen Zustands zugreifen
            * Wenn Du den Store mit einer Datenbank vergleichst, w√§re ein solcher Teilzustand so etwas wie eine Tabelle
            * Die reducer werden beim Starten der Anwendung in Redux registriert
            * Im Gegensatz zu `useReducer` wird eine Action in redux nicht an _einen_ Reducer geschickt, sondern an _alle_ Reducer. 
            * Dadurch ist eine gute Entkopplung m√∂glich: ein Teil der Anwendung informiert √ºber eine Aktion ("User hat sich eingeloggt", "Theme wurde ver√§ndert") und alle interessierten
            Anwendungsteile k√∂nnen darauf reagieren
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux: Actions</h3>
          <ul>
            <li class="fragment">Actions sind analog zu den Actions mit <code>useReducer</code></li>
            <li class="fragment">Actions werden an <b>alle</b> Reducer-Funktionen verteilt</li>
            <li class="fragment">
              Zum Ausl√∂sen einer Action gibt auch von Redux eine <code>dispatch</code>-Funktion, an
              die Du mit dem <code>useDispatch</code> Hook von Redux gelangst.
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function ThemeChooser() {
              const dispatch = useDispatch();

              function handleSetTheme(themeName) {
                dispatch({ type: "setTheme", payload: { newTheme: themeName } } );
              }

              return &lt;button onClick={() => handleSetTheme("light")}>Light&lt;/button>

            }
          </code></pre>
        </section>

        <section>
          <h3>Redux: Zugriff auf den globalen Zustand</h3>
          <ul>
            <li class="fragment">
              Komponenten k√∂nnen aus dem globalen Zustand (Store) die Daten ausw√§hlen, die sie
              ben√∂tigen
            </li>
            <li class="fragment">
              Die Hierarchie-Ebene spielt dabei keine Rolle, weil der Zustand au√üerhalb, "neben" den
              UI Komponenten liegt
            </li>
            <li class="fragment">
              Nur wenn sich die ausgew√§hlten Daten in einer Kompoente √§ndern, wird die Komponente
              neu gerendert
            </li>
            <li class="fragment">
              Der <code>useSelector</code> Hook von Redux erwartet eine Callback-Funktion, die
              aufgerufen wird, sobald sich <em>irgendetwas</em> im Store ver√§ndert hat
            </li>
            <li class="fragment">Dieser Callback-Funktion wird der komplette Store √ºbergeben.</li>
            <li class="fragment">
              Aus dem Store w√§hlt die Komponente die f√ºr sie relevanten Daten aus und liefert sie
              zur√ºck
            </li>
            <li class="fragment">
              Nur wenn sich diese zur√ºckgelieferten Daten ver√§ndert haben, wird die Komponente neu
              gerendert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
              function TextInput() {
                const { themeName } = useSelector(state => state.theme.themeName);

                //  ...
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useSelector - Details</h3>
          <ul>
            <li class="fragment">
              Um festzustellen, ob sich die ausgew√§hlten Daten ver√§ndert haben, pr√ºft Redux auf
              <b>Identit√§t</b>!
            </li>
            <li class="fragment">
              Es wird deshalb empfohlen, nur einzelne Werte (keine Objekte) aus dem Store
              auszuw√§hlen - stattdessen mehrere useSelector-Aufrufe machen
            </li>
            <li class="fragment">
              Du kannst nat√ºrlich auch "abgeleitete" Daten zur√ºckliefern, Redux vergleicht nur den
              von dir zur√ºckgelieferten Wert, unabh√§ngig davon, ob er "direkt" aus dem Store kommt
              oder basierend auf dem Store "berechnet" wurde
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function LoginCounter() {
              // *Alle* User befinden sich im Store
              // Der Selector liefert aber nur die Anzahl 
              // der eingeloggten Benutzer zur√ºck (berechneter/abgeleiteter State)
              const loggedInUserCount = useSelector(
                state => state.users.filter(u => u.isLoggedIn).count
              );
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux Toolkit

            * Redux erfordert in der Regel sehr viel Boilerplate Code (bitte nicht in kleineren Anwendungen einsetzen!)
            * Au√üerdem ist das Setup und die Konfiguration nicht immer trivial (Redux ist z.B. erweiterbar, welche Erweiterungen brauche ich?)
            * Auch die Verwendung von TypeScript ist nicht immer trivial
            * Aus diesen Gr√ºnden gibt es das [Redux Toolkit](https://redux-toolkit.js.org/), ein "offzielles" Toolset f√ºr Redux-Anwendungen (von den Redux-Leuten selbst)
            * Das kann die Entwicklung mit Redux vereinfachen
            * Aber: es bringt zus√§tzlich zu den Redux "Kernkonzepten" weitere Ideen mit (um die Kernkonzepte zu vereinfachen, zu abstrahieren etc)
            * Deswegen Empfehlung: erst mit Redux vertraut machen, dann aber im "echten Leben" evtl. auf das Toolkit setzen
          </textarea>
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Happy Statemanagement üçª</h3>
          <p>
            Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
        <section>
          <img src="slides/images/Deckblatt-und-Schlussblatt_devmedia_Trainings.png" />
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
    <script>
      const isLocal =
        window.location.hostname.indexOf("localhost") !== -1 ||
        window.location.hostname.indexOf("127.0.0.1") !== -1 ||
        window.location.href.startsWith("file:///");
      Reveal.addEventListener("ready", function (event) {
        $("li").addClass("fragment");

        // make all links open in new tab
        $("a").attr("target", "_blank");

        if (isLocal) {
          // only applies to presentation version
          Reveal.configure({ controls: false });
        } else {
          // only applies to public version
          $(".fragment").removeClass("fragment");
        }
      });
    </script>
  </body>
</html>
